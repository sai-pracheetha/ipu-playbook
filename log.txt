commit 59c3ff2835a7b25799ac66b71deff6946241b14a
Author: Sai Pracheetha Beeyam <sai.pracheetha.beeyam@intel.com>
Date:   Tue Dec 10 19:01:18 2024 -0800

    Addressed comments, deleted unused files, included untarring of p4 tarball
    
    Signed-off-by: Sai Pracheetha Beeyam <sai.pracheetha.beeyam@intel.com>

diff --git a/common/base.py b/common/base.py
deleted file mode 100644
index bea50f5..0000000
--- a/common/base.py
+++ /dev/null
@@ -1,59 +0,0 @@
-import argparse
-import logging
-import re
-import os
-
-# Configure logging to write logs to a file
-log = logging.getLogger()
-logging.basicConfig(level=logging.DEBUG, format='%(levelname)s      %(funcName)s.%(filename)s:%(lineno)d %(message)s')
-
-class CliParams:
-    def __init__(self):
-        self.args = None
-        pass
-
-    def get_input_params(self):
-        parser = argparse.ArgumentParser(description="Get Cli Params")
-        parser.add_argument("--test_config", action="store", required=True, help="test_config_path")
-        parser.add_argument("--topology_config", action="store", required=True, help="topology_config_path")
-
-        self.args = parser.parse_args()
-        return vars(self.args) 
-
-def get_acc_mac_vsi(ces_base,acc_iface):
-    acc_ssh=ces_base.get_def_acc_ssh()
-    lines = acc_ssh.exec_command("ifconfig {} | grep ether".format(acc_iface))
-    log.info(lines)
-    print("get_acc_mac_vsi=",lines)
-    acc_mac = lines[0].split()[1]
-    print("acc_mac:",acc_mac)
-
-    #get acc vsi
-    imc=ces_base.get_def_imc_ssh()
-    lines = imc.exec_command("cli_client -q -c | grep {}".format(acc_mac))
-    for line in lines:
-        if not re.match("fn_id",line):
-            continue
-        fields = line.split()
-        #print("fields=",fields)
-        mac = fields[-1]
-        if mac == acc_mac:
-
-            acc_vsi = fields[7]
-
-            print("acc_vsi=",acc_vsi)
-            break
-    return acc_mac,acc_vsi
-    
-def test_prepare(ces_base):
-    acc_ssh=ces_base.get_def_acc_ssh()
-
-    #copy the tdishell that support to run tdi script
-    #this help to run tdi by ssh
-    tdi_shell_path = f"{os.getcwd()}/workloads/p4/common/tdishell"
-    log.info(tdi_shell_path)
-    acc_ssh.put_file(tdi_shell_path,"/opt/p4/p4sde/bin/tdishell")
-    acc_ssh.exec_command("chmod 777 /opt/p4/p4sde/bin/tdishell")
-
-    #check if need untar p4.tar.gz
-    acc_ssh.exec_command("cd /opt;[ -d p4 ] && echo 1 || tar xzvf p4.tar.gz > /dev/null 2>&1")
diff --git a/common/tdishell b/common/tdishell
deleted file mode 100644
index 03137b3..0000000
--- a/common/tdishell
+++ /dev/null
@@ -1,40 +0,0 @@
-import socket
-import re
-import argparse
-
-parser = argparse.ArgumentParser()
-parser.add_argument('--tdi_file',"-t",help="tdi_python commands")
-args = parser.parse_args()
-
-f=open(args.tdi_file,"r")
-lines=f.readlines()
-f.close()
-
-msg =[]
-msg.append("tdi_python\n")
-msg.extend(lines)
-msg.append("exit\n")
-
-s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
-s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
-s.connect(('127.0.0.1',9999))
-
-for line in msg:
-    s.send(bytes(line,"utf-8"))
-    #time.sleep(1)
-
-msg=""
-while True:
-    ret=s.recv(1024)
-    msg += ret.decode("utf-8")
-    if msg.count("tdishell>") == 2 or msg.count("bfshell>") == 2: #there are two tdishell>
-        break
-
-#remove all the lines that has escape characters.
-#test shows that this will not loss the useful info.
-for line in msg.split("\n"):
-    if re.search(r'\x1b\[[\x30-\x3f]*[\x20-\x2f]*',line):   #ignore the lines with escape
-        continue
-    print(line)
-
-s.close()
diff --git a/common/utils.py b/common/utils.py
index 59d9f40..9172c58 100644
--- a/common/utils.py
+++ b/common/utils.py
@@ -3,7 +3,7 @@
 # Copyright 2022-2024 Intel Corporation
 # SPDX-License-Identifier: Apache-2.0
 #
-# Common python APIs and utilities for Intel速 Infrastructure Processing Unit (Intel速 IPU)
+# Common Python APIs and utilities for Intel速 Infrastructure Processing Unit (Intel速 IPU)
 
 import subprocess, os, time, re
 import yaml
diff --git a/ipsec_accel/README.md b/ipsec_accel/README.md
index 1e81f7d..bc5a2e3 100644
--- a/ipsec_accel/README.md
+++ b/ipsec_accel/README.md
@@ -11,7 +11,7 @@
 
 ## Test Environment Setup
 
-Before running the script, make sure `/etc/ssh/ssd_config` contains the line.
+Before running the script, make sure `/etc/ssh/sshd_config` contains the line for root user.
 
 ```bash
 PermitRootLogin yes
diff --git a/ipsec_accel/config_host1.yaml b/ipsec_accel/config_host1.yaml
index f15f5f2..053391a 100644
--- a/ipsec_accel/config_host1.yaml
+++ b/ipsec_accel/config_host1.yaml
@@ -49,6 +49,6 @@ test_params:
     local_br_tun_ip: ['1.1.1.1']
     remote_br_tun_ip: ['1.1.1.2']
     #Directory where strongswan is built on the host
-    strongSwan_build: '/home/admin12/ipsec/ipsec_combined_sep16/ipsec-recipe/'
+    strongSwan_build: '/root/ipsec-recipe/'
     #Host 1 or Host 2
     ipsec_host: '1'
diff --git a/ipsec_accel/config_host2.yaml b/ipsec_accel/config_host2.yaml
index c398736..c48c13e 100644
--- a/ipsec_accel/config_host2.yaml
+++ b/ipsec_accel/config_host2.yaml
@@ -49,6 +49,6 @@ test_params:
     local_br_tun_ip: ['1.1.1.2']
     remote_br_tun_ip: ['1.1.1.1']
     #Directory where strongswan is built on the host
-    strongSwan_build: '/home/admin12/ipsec/ipsec_combined_sep16/ipsec-recipe/'
+    strongSwan_build: '/root/ipsec-recipe/'
     #Host 1 or Host 2
     ipsec_host: '2'
diff --git a/ipsec_accel/ipsec_accel.py b/ipsec_accel/ipsec_accel.py
index 0bf2feb..c1e3627 100755
--- a/ipsec_accel/ipsec_accel.py
+++ b/ipsec_accel/ipsec_accel.py
@@ -49,18 +49,15 @@ modprobe idpf
 sleep 4
 
 echo ""
-echo "Check the Interfaces are up"
+echo "Checking if the interfaces are up"
 ip -br a
 
-echo ""
-echo "Check the Interfaces are up"
-ip -br a
 #Setup number of sriov devices on the IDPF interface
 echo "Create SRIOV VFs on IDPF interface '''+host_idpf_intf+'''"
 echo 8 > /sys/class/net/'''+host_idpf_intf+'''/device/sriov_numvfs
 
 echo ""
-echo "Wait for the interfaces to come up"
+echo "Waiting for the interfaces to come up"
 sleep 5
 ip -br a
 
@@ -69,7 +66,6 @@ EOF
 
     host_command_list.append(host_idpf)
     host_command_list.append(f"chmod +x ./{file}")
-    #host_command_list.append(f"./{file}")
 
 
     file = f'{path}/setup_host_comm_channel.sh'
@@ -263,7 +259,7 @@ ip addr add '''+comm_ip_acc+'''/24 dev enp0s1f0d3
 ip link set up dev enp0s1f0d3
 
 #Untar P4 tarball
-#tar -xzvf /opt/p4.tar.gz -C /opt/
+tar -xzvf /opt/p4.tar.gz -C /opt/
 EOF
 '''
     command_list.append(host_acc_comm_channel)
@@ -929,7 +925,7 @@ if __name__ == "__main__":
 
 
         print("\n----------------Configure ACC for Host - ACC communication----------------")
-        result = acc_comm.tmux_send_keys('./setup_acc_comm_channel.sh', delay=15, output=True)
+        result = acc_comm.tmux_send_keys('./setup_acc_comm_channel.sh', delay=90, output=True)
         print(result)
 
 
diff --git a/ovs_offload/README.md b/ovs_offload/README.md
index f27f5c7..0014a5a 100644
--- a/ovs_offload/README.md
+++ b/ovs_offload/README.md
@@ -9,7 +9,7 @@
 
 ## Test Environment Setup
 
-Before running the script, make sure `/etc/ssh/ssd_config` contains the line.
+Before running the script, make sure `/etc/ssh/sshd_config` contains the line for root user.
 
 ```bash
 PermitRootLogin yes

commit 1c6ef7008b20679c7648259f87e51134c40ab548
Author: Sai Pracheetha Beeyam <sai.pracheetha.beeyam@intel.com>
Date:   Fri Nov 22 17:22:52 2024 +0000

    Moved duplicated modules out to common
    
    Signed-off-by: Sai Pracheetha Beeyam <sai.pracheetha.beeyam@intel.com>

diff --git a/common/__init__.py b/common/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/common/base.py b/common/base.py
new file mode 100644
index 0000000..bea50f5
--- /dev/null
+++ b/common/base.py
@@ -0,0 +1,59 @@
+import argparse
+import logging
+import re
+import os
+
+# Configure logging to write logs to a file
+log = logging.getLogger()
+logging.basicConfig(level=logging.DEBUG, format='%(levelname)s      %(funcName)s.%(filename)s:%(lineno)d %(message)s')
+
+class CliParams:
+    def __init__(self):
+        self.args = None
+        pass
+
+    def get_input_params(self):
+        parser = argparse.ArgumentParser(description="Get Cli Params")
+        parser.add_argument("--test_config", action="store", required=True, help="test_config_path")
+        parser.add_argument("--topology_config", action="store", required=True, help="topology_config_path")
+
+        self.args = parser.parse_args()
+        return vars(self.args) 
+
+def get_acc_mac_vsi(ces_base,acc_iface):
+    acc_ssh=ces_base.get_def_acc_ssh()
+    lines = acc_ssh.exec_command("ifconfig {} | grep ether".format(acc_iface))
+    log.info(lines)
+    print("get_acc_mac_vsi=",lines)
+    acc_mac = lines[0].split()[1]
+    print("acc_mac:",acc_mac)
+
+    #get acc vsi
+    imc=ces_base.get_def_imc_ssh()
+    lines = imc.exec_command("cli_client -q -c | grep {}".format(acc_mac))
+    for line in lines:
+        if not re.match("fn_id",line):
+            continue
+        fields = line.split()
+        #print("fields=",fields)
+        mac = fields[-1]
+        if mac == acc_mac:
+
+            acc_vsi = fields[7]
+
+            print("acc_vsi=",acc_vsi)
+            break
+    return acc_mac,acc_vsi
+    
+def test_prepare(ces_base):
+    acc_ssh=ces_base.get_def_acc_ssh()
+
+    #copy the tdishell that support to run tdi script
+    #this help to run tdi by ssh
+    tdi_shell_path = f"{os.getcwd()}/workloads/p4/common/tdishell"
+    log.info(tdi_shell_path)
+    acc_ssh.put_file(tdi_shell_path,"/opt/p4/p4sde/bin/tdishell")
+    acc_ssh.exec_command("chmod 777 /opt/p4/p4sde/bin/tdishell")
+
+    #check if need untar p4.tar.gz
+    acc_ssh.exec_command("cd /opt;[ -d p4 ] && echo 1 || tar xzvf p4.tar.gz > /dev/null 2>&1")
diff --git a/common/tdishell b/common/tdishell
new file mode 100644
index 0000000..03137b3
--- /dev/null
+++ b/common/tdishell
@@ -0,0 +1,40 @@
+import socket
+import re
+import argparse
+
+parser = argparse.ArgumentParser()
+parser.add_argument('--tdi_file',"-t",help="tdi_python commands")
+args = parser.parse_args()
+
+f=open(args.tdi_file,"r")
+lines=f.readlines()
+f.close()
+
+msg =[]
+msg.append("tdi_python\n")
+msg.extend(lines)
+msg.append("exit\n")
+
+s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
+s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
+s.connect(('127.0.0.1',9999))
+
+for line in msg:
+    s.send(bytes(line,"utf-8"))
+    #time.sleep(1)
+
+msg=""
+while True:
+    ret=s.recv(1024)
+    msg += ret.decode("utf-8")
+    if msg.count("tdishell>") == 2 or msg.count("bfshell>") == 2: #there are two tdishell>
+        break
+
+#remove all the lines that has escape characters.
+#test shows that this will not loss the useful info.
+for line in msg.split("\n"):
+    if re.search(r'\x1b\[[\x30-\x3f]*[\x20-\x2f]*',line):   #ignore the lines with escape
+        continue
+    print(line)
+
+s.close()
diff --git a/common/utils.py b/common/utils.py
new file mode 100644
index 0000000..59d9f40
--- /dev/null
+++ b/common/utils.py
@@ -0,0 +1,327 @@
+#!/usr/bin/python
+#
+# Copyright 2022-2024 Intel Corporation
+# SPDX-License-Identifier: Apache-2.0
+#
+# Common python APIs and utilities for Intel速 Infrastructure Processing Unit (Intel速 IPU)
+
+import subprocess, os, time, re
+import yaml
+
+
+def run_cmd(cmd, output=False, check_returncode=True):
+    """
+    Execute a command in a subprocess.
+    :param cmd: The command to be executed as a string.
+    :param output: If True, capture and return the command's stdout.
+    :param check_returncode: If True, check the command's return code and raise an error if not 0.
+    :return: The stdout of the command if output is True, otherwise None.
+    """
+    print(f'Executing: {cmd}')
+    # Use a context manager to ensure the subprocess is cleaned up after execution
+    with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE if output else None, stderr=subprocess.PIPE, encoding="utf-8") as s:
+        outs, errs = s.communicate() if output else (None, None)
+        # Check the return code if required
+        if check_returncode and s.returncode != 0:
+            raise subprocess.CalledProcessError(s.returncode, cmd, output=outs, stderr=errs)
+        return outs.strip() if output else None
+
+
+def ping_test(dst_ip, count=4, vm = None):
+    if vm:
+        cmd = f"ip netns exec {vm} ping {dst_ip} -c {count}"
+    else:
+        cmd = f"ping {dst_ip} -c {count}"
+    try:
+        result = run_cmd(cmd, output=True)
+        pkt_loss = 100
+        if result:
+            match = re.search('(\d*)% packet loss', result)
+            if match:
+                pkt_loss = int(match.group(1))
+            if f"{count} received, 0% packet loss" in result:
+                print(f"PASS: Ping successful to destination {dst_ip}\n")
+                return True
+            else:
+                raise RuntimeError(f"FAIL: Ping Failed to destination {dst_ip} with" f" {pkt_loss}% loss\n")
+    except Exception as E:
+        print(f"Ping run failed with error:'{E}'\n")
+        return False
+
+
+def split_mac(mac_address):
+    # Split the MAC address by colons
+    octets = mac_address.split(":")
+
+    # Join the first three octets and the last three octets
+    first_octet = "".join(octets[:2])
+    second_octet = "".join(octets[2:4])
+    third_octet = "".join(octets[4:])
+
+    print("first octet {} second octet {} third octet {}".format(first_octet, second_octet, third_octet))
+    return first_octet, second_octet, third_octet
+
+
+def split_mac_2(mac_address):
+    # Split the MAC address by colons
+    octets = mac_address.split(":")
+
+    # Join the first three octets and the last three octets
+    first_split = "".join(octets[:2])
+    second_split = "".join(octets[2:])
+
+    return first_split, second_split
+
+
+def ip_dec_to_hex(ip_address):
+    octets = ip_address.split('.')
+    hex_octets = [f"{int(octet):02X}" for octet in octets]
+    return "".join(hex_octets)
+
+
+class TestSetup:
+    def __init__(self, config_file=''):
+        self.config_file = config_file
+        self.test_config = {}
+
+        with open(self.config_file, "r") as file:
+            self.test_config = yaml.safe_load(file)
+
+        if self.test_config == None:
+            print("Unable to parse the config.yaml to generate test configuration")
+            sys.exit()
+
+
+    def ssh_command(self, server_name, command, output=True, check_returncode=True):
+        """
+        Execute a command on a remote server via SSH.
+        :param server_name: The name of the server ('host', 'imc', or 'acc').
+        :param command: The command to be executed on the remote server.
+        :return: A dictionary with the return code and the command's output.
+        """
+        imc_ip = self.test_config['imc']['ssh']['ip']
+        acc_ip = self.test_config['acc']['ssh']['ip']
+        # SSH command templates
+        imc_access = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
+        acc_access = f'{imc_access} ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
+
+        # Determine the appropriate SSH command based on the server name
+        if server_name == 'host':
+            full_cmd = command
+        elif server_name == 'imc':
+            full_cmd = f'{imc_access} "{command}"'
+        elif server_name == 'acc':
+            full_cmd = f'{acc_access} "{command}"'
+        else:
+            raise ValueError(f"Unknown server name: {server_name}")
+
+        # Execute the command and capture the output
+        output = run_cmd(full_cmd, output = output, check_returncode = check_returncode)
+
+        # Return the result as a dictionary
+        return {'rc': 0, 'output': output}
+
+
+    def copy_scripts(self):
+        """
+        Copies configuration scripts from the host to the IMC and then to the ACC.
+
+        :param host_path: Path to the configuration scripts on the host machine
+        :param imc_path: Destination path on the IMC
+        :param acc_path: Destination path on the ACC
+        """
+        host_path = self.test_config['test_params']['host_path']
+        imc_path = self.test_config['test_params']['imc_path']
+        acc_path = self.test_config['test_params']['acc_path']
+        imc_ip = self.test_config['imc']['ssh']['ip']
+        acc_ip = self.test_config['acc']['ssh']['ip']
+
+        command = f'mkdir -p {imc_path}'
+        try:
+            result = self.ssh_command('imc', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+
+        command = f'mkdir -p {acc_path}'
+        try:
+            result = self.ssh_command('acc', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+
+        # Copy the configuration scripts from host to IMC
+        command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {host_path}  root@{imc_ip}:{imc_path}/'
+        try:
+            result = self.ssh_command('host', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+
+        command = f'chmod +x {imc_path}/{host_path}/*'
+        try:
+            result = self.ssh_command('imc', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+
+        # Copy the configuration scripts from IMC to ACC
+        command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {imc_path}/{host_path} root@{acc_ip}:{acc_path}/'
+        try:
+            result = self.ssh_command('imc', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+
+        command = f'chmod +x {acc_path}/{host_path}/*'
+        try:
+            result = self.ssh_command('acc', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+
+
+    def get_interface_info(self, server_name, interface_name):
+        """
+        Retrieve information about a network interface on a remote server.
+
+        :param server_name: The name of the server where the interface is located.
+        :param interface_name: The name of the network interface to query.
+        :return: A dictionary containing various pieces of information about the interface.
+        """
+        # Initialize an empty dictionary to store interface information
+        interface_info = {}
+
+        # Define a mapping of server names to host IDs
+        host_id = {
+            'host': '0x0',
+            'acc': '0x4',
+            'imc': '0x5'
+        }
+
+        # Command to get basic interface information using ifconfig
+        cmd = f"ifconfig {interface_name}"
+        try:
+            result = self.ssh_command(server_name, cmd)
+        except Exception as e:
+            print(f"Failed to run ifconfig on '{interface_name}': {e}")
+            return interface_info
+
+        output = result['output']
+
+        # Regex patterns to extract IP, MAC, and other fields
+        ip_pattern = re.compile(r'inet (\d+\.\d+\.\d+\.\d+)')
+        mac_pattern = re.compile(r'ether ([0-9a-fA-F:]{17})')
+        mtu_pattern = re.compile(r'mtu (\d+)')
+
+        # Search for patterns in the output and populate the dictionary
+        interface_info['ip'] = ip_pattern.search(output).group(1) if ip_pattern.search(output) else None
+        interface_info['mac'] = mac_pattern.search(output).group(1) if mac_pattern.search(output) else None
+        interface_info['mtu'] = mtu_pattern.search(output).group(1) if mtu_pattern.search(output) else None
+
+        # Command to get detailed interface information using ethtool
+        cmd = f"ethtool -i {interface_name}"
+        try:
+            result = self.ssh_command(server_name, cmd)
+        except Exception as e:
+            print(f"Failed to run ethtool on '{interface_name}': {e}")
+            return interface_info
+
+        output = result['output']
+
+        # Parse ethtool output and add to the dictionary
+        for line in output.split('\n'):
+            field = line.split(': ')
+            if len(field) == 2:
+                interface_info[field[0].strip()] = field[1].strip()
+
+        # Check if the driver is not 'idpf' and return the info collected so far
+        if interface_info.get('driver') != 'idpf':
+            return interface_info
+
+        # Command to get additional interface information for 'idpf' interface from IMC
+        cmd = f"cli_client -q -c | grep 'host_id: {host_id[server_name]}' | grep '{interface_info['mac']}'"
+        try:
+            result = self.ssh_command('imc', cmd)
+        except Exception as e:
+            print(f"Failed to run cli_client on '{interface_name}': {e}")
+            return interface_info
+
+        output = result['output']
+
+        # Regex pattern to extract additional fields for 'idpf' driver
+        pattern = re.compile(r'fn_id:\s+(\w+)\s+host_id:\s+(\w+)\s+is_vf:\s+(\w+)\s+vsi_id:\s+(\w+)\s+vport_id\s+(\w+)\s+is_created:\s+(\w+)\s+is_enabled:\s+(\w+)\s+mac\s+addr:\s+([0-9a-fA-F:]{17})')
+        match = pattern.search(output)
+
+        # Populate the dictionary with additional information if available
+        if match:
+            interface_info.update({
+                'fn_id': match.group(1),
+                'host_id': match.group(2),
+                'is_vf': match.group(3),
+                'vsi_id': match.group(4),
+                'vport_id': match.group(5),
+                'is_created': match.group(6),
+                'is_enabled': match.group(7),
+                'mac_addr': match.group(8)
+            })
+
+            # Calculate additional fields based on 'vsi_id'
+            if interface_info['vsi_id']:
+                interface_info['vsi_num'] = str(int(interface_info['vsi_id'], 16))
+                port_offset = str(int(interface_info['vsi_id'], 16) + 16)
+                interface_info['port'] = port_offset
+
+        return interface_info
+
+
+class tmux_term:
+    def __init__(self, test_setup, tmux_name="", tmux_override=False):
+        # Initialize a new tmux terminal session
+        if not tmux_name:
+            raise ValueError("Error: No tmux name specified!")
+        self.tmux_name = tmux_name
+        self.test_setup = test_setup
+        # Check if the specified tmux session already exists
+        command = 'tmux ls'
+        try:
+            result = self.test_setup.ssh_command('host', command, check_returncode=False)
+        except Exception as e:
+            raise Exception(f"Failed to list tmux sessions with exception:\n{e}")
+
+        # Parse the output to find an existing session
+        lines = result['output']
+        found = any(self.tmux_name in line for line in lines.split('\n'))
+
+        # If the session is found and override is allowed, kill the existing session
+        if found and tmux_override:
+            command = f'tmux kill-session -t {self.tmux_name}'
+            self.test_setup.ssh_command('host', command)
+
+        # If the session was not found or was killed, create a new one
+        if not found or tmux_override:
+            command = f'tmux new-session -d -s {self.tmux_name}'
+            self.test_setup.ssh_command('host', command)
+
+    def tmux_send_keys(self, cmd, delay=1, output=True):
+        # Send a command to the tmux session and optionally capture the output
+        time.sleep(0.5)  # Short delay before sending the command
+
+        if output:
+            # Set up piping to capture the output of the command
+            output_file = os.path.join(os.getcwd(), 'tmux_output.txt')
+            command = f'tmux pipe-pane -t {self.tmux_name} "cat > {output_file}"'
+            self.test_setup.ssh_command('host', command)
+
+        # Send the actual command to the tmux session
+        command = f'tmux send-keys -t {self.tmux_name} "{cmd}" C-m'
+        self.test_setup.ssh_command('host', command)
+
+        if output:
+            # Wait for the specified delay to allow the command to execute and output to be captured
+            if delay > 0:
+                time.sleep(delay)
+
+            # Stop piping the output
+            command = f'tmux pipe-pane -t {self.tmux_name}'
+            self.test_setup.ssh_command('host', command)
+
+            # Read the captured output from the file
+            with open(output_file, "r") as f:
+                result = f.read()
+
+        return result
diff --git a/ipsec_accel/README.md b/ipsec_accel/README.md
index 53b818c..1e81f7d 100644
--- a/ipsec_accel/README.md
+++ b/ipsec_accel/README.md
@@ -94,7 +94,7 @@ usage: tmux [-2CDlNuvV] [-c shell-command] [-f file] [-L socket-name]
  
 
 ```bash
-> cd ipsec_accel
+> cd ipu-playbook/ipsec_accel
 ```
 
 ```bash
@@ -159,7 +159,7 @@ test_params:
 Use python venv:
 
 ```bash
-cd ipsec_accel/
+cd ipu-playbook
 python -m venv --copies venv
 ```
 
@@ -181,15 +181,16 @@ Run python script **ipsec_accel.py** as a root user.
 
 ```bash
 sudo -i
-cd ipdk/ipsec_accel
+cd ipu-playbook
 source venv/bin/activate
+cd ipsec_accel
 ```
 
 ## Test Script
 
 ### ipsec_accel.py : (P4:fxp-net_linux-networking.p4, IPU SDK Release >= 1.8.0)
 
-1. This is a python script : **ipsec_accel/ipsec_accel.py** that can be used with **P4: fxp-net_linux-networking.p4** for release 1.7.0 and later
+1. This is a python script : **ipsec_accel/ipsec_accel.py** that can be used with **P4: fxp-net_linux-networking.p4** for release 1.7.0 and later.
 
     ```bash
     > python ipsec_accel.py
@@ -213,6 +214,7 @@ source venv/bin/activate
     ```
 
 2. create_script: This will create the configuration scripts in the script directory (the path can be changed in **host_path** in **config.yaml**) at **ipsec_accel/ipsec_accel_scripts/**
+   If host 1, copy config_host1.yaml to config.yaml. If host 2,  config_host2.yaml to config.yaml. Change the configs according to your setup.
 
     ```bash
     > python ipsec_accel.py create_script
@@ -369,7 +371,7 @@ host# ./setup_host_comm_channel.sh
 
 On ACC
 
-acc# cd /opt/ipsec_accel_scripts/
+acc# cd /opt/ipsec_accel_scripts
 acc# ./setup_acc_comm_channel.sh
 ```
 
@@ -392,7 +394,7 @@ host# ./sync_host_acc_date.sh
 
 On ACC
 
-acc# cd /opt/ipsec_accel_scripts/
+acc# cd /opt/ipsec_accel_scripts
 acc# ./generate_certs.sh
 
 ```
@@ -519,7 +521,7 @@ rtt min/avg/max/mdev = 0.317/303.674/1107.126/465.909 ms, pipe 2
 ```bash
 
 
-host# cd ipsec_accel/ipsec_accel_scripts/
+host# cd ipsec_accel/ipsec_accel_scripts
 host# ./host_ipsec_config.sh
 host# source proxy.sh
 host# yes|cp -f ipsec.secrets {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/
@@ -542,7 +544,7 @@ In the same terminal as above execute ipsec application on both hosts.
 host# cd {strongSwan_build}
 host# source env_setup_acc.sh
 
-host# cd {strongSwan_build}//ipsec_offload_plugin/output_strongswan/usr/sbin
+host# cd {strongSwan_build}/ipsec_offload_plugin/output_strongswan/usr/sbin
 host# ./ipsec start
 
 ```
@@ -550,7 +552,7 @@ host# ./ipsec start
 In the same terminal Check for IPsec status 
 
 ```bash
-host# cd {strongSwan_build}//ipsec_offload_plugin/output_strongswan/usr/sbin
+host# cd {strongSwan_build}/ipsec_offload_plugin/output_strongswan/usr/sbin
 host# ./ipsec status
 
 [root@Aurora sbin]# ./ipsec status
@@ -611,7 +613,7 @@ cisp tx bad pkts: 0
 ```bash
 On ACC
 
-acc# cd /opt/ipsec_accel_scripts/
+acc# cd /opt/ipsec_accel_scripts
 acc# ./ipsec_tunnel_config.sh
 ```
 
@@ -619,7 +621,7 @@ acc# ./ipsec_tunnel_config.sh
 ```bash
 On Host
 
-host# cd ipsec_accel/ipsec_accel_scripts/
+host# cd ipsec_accel/ipsec_accel_scripts
 host# ./host_ipsec_config.sh
 host# source proxy.sh
 host# yes|cp -f ipsec.secrets {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/
@@ -642,7 +644,7 @@ In the same terminal as above execute ipsec application on both hosts.
 host# cd {strongSwan_build}
 host# source env_setup_acc.sh
 
-host# cd {strongSwan_build}//ipsec_offload_plugin/output_strongswan/usr/sbin
+host# cd {strongSwan_build}/ipsec_offload_plugin/output_strongswan/usr/sbin
 host# ./ipsec start
 
 ```
@@ -650,7 +652,7 @@ host# ./ipsec start
 In the same terminal check for IPsec status
 
 ```bash
-host# cd {strongSwan_build}//ipsec_offload_plugin/output_strongswan/usr/sbin
+host# cd {strongSwan_build}/ipsec_offload_plugin/output_strongswan/usr/sbin
 host# ./ipsec status
 
 [root@Aurora sbin]# ./ipsec status
diff --git a/ipsec_accel/__init__.py b/ipsec_accel/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/ipsec_accel/common/utils.py b/ipsec_accel/common/utils.py
deleted file mode 100644
index 82ba811..0000000
--- a/ipsec_accel/common/utils.py
+++ /dev/null
@@ -1,315 +0,0 @@
-#!/usr/bin/python
-#
-# Copyright 2022-2024 Intel Corporation
-# SPDX-License-Identifier: Apache-2.0
-#
-# Common python APIs and utilities for Intel速 Infrastructure Processing Unit (Intel速 IPU)
-
-import subprocess, os, time, re
-import yaml
-
-def fetch_configurations(config_file=''):
-    with open(config_file, "r") as file:
-        config_data = yaml.safe_load(file)
-    return config_data
-
-#Fetch test configuration
-test_config = fetch_configurations(f'{os.path.dirname(os.path.abspath(__file__))}/../config.yaml')
-
-def run_cmd(cmd, output=False, check_returncode=True):
-    """
-    Execute a command in a subprocess.
-    :param cmd: The command to be executed as a string.
-    :param output: If True, capture and return the command's stdout.
-    :param check_returncode: If True, check the command's return code and raise an error if not 0.
-    :return: The stdout of the command if output is True, otherwise None.
-    """
-    print(f'Executing: {cmd}')
-    # Use a context manager to ensure the subprocess is cleaned up after execution
-    with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE if output else None, stderr=subprocess.PIPE, encoding="utf-8") as s:
-        outs, errs = s.communicate() if output else (None, None)
-        # Check the return code if required
-        if check_returncode and s.returncode != 0:
-            raise subprocess.CalledProcessError(s.returncode, cmd, output=outs, stderr=errs)
-        return outs.strip() if output else None
-
-def ssh_command(server_name, command, output=True, check_returncode=True):
-    """
-    Execute a command on a remote server via SSH.
-    :param server_name: The name of the server ('host', 'imc', or 'acc').
-    :param command: The command to be executed on the remote server.
-    :return: A dictionary with the return code and the command's output.
-    """
-    imc_ip = test_config['imc']['ssh']['ip']
-    acc_ip = test_config['acc']['ssh']['ip']
-    # SSH command templates
-    imc_access = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
-    acc_access = f'{imc_access} ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
-
-    # Determine the appropriate SSH command based on the server name
-    if server_name == 'host':
-        full_cmd = command
-    elif server_name == 'imc':
-        full_cmd = f'{imc_access} "{command}"'
-    elif server_name == 'acc':
-        full_cmd = f'{acc_access} "{command}"'
-    else:
-        raise ValueError(f"Unknown server name: {server_name}")
-
-    # Execute the command and capture the output
-    output = run_cmd(full_cmd, output = output, check_returncode = check_returncode)
-
-    # Return the result as a dictionary
-    return {'rc': 0, 'output': output}
-
-
-def copy_scripts(host_path='ovs_offload_lnw_scripts', imc_path = '/mnt/imc/p4_test', acc_path = '/opt/p4/p4sde/p4_test'):
-    """
-    Copies configuration scripts from the host to the IMC and then to the ACC.
-
-    :param host_path: Path to the configuration scripts on the host machine
-    :param imc_path: Destination path on the IMC
-    :param acc_path: Destination path on the ACC
-    """
-    imc_ip = test_config['imc']['ssh']['ip']
-    acc_ip = test_config['acc']['ssh']['ip']
-
-    command = f'mkdir -p {imc_path}'
-    try:
-        result = ssh_command('imc', command)
-    except Exception as e:
-        print(f"Failed with exception:\n{e}")
-
-    command = f'mkdir -p {acc_path}'
-    try:
-        result = ssh_command('acc', command)
-    except Exception as e:
-        print(f"Failed with exception:\n{e}")
-
-    # Copy the configuration scripts from host to IMC
-    command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {host_path}  root@{imc_ip}:{imc_path}/'
-    try:
-        result = ssh_command('host', command)
-    except Exception as e:
-        print(f"Failed with exception:\n{e}")
-
-    command = f'chmod +x {imc_path}/{host_path}/*'
-    try:
-        result = ssh_command('imc', command)
-    except Exception as e:
-        print(f"Failed with exception:\n{e}")
-
-    # Copy the configuration scripts from IMC to ACC
-    command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {imc_path}/{host_path} root@{acc_ip}:{acc_path}/'
-    try:
-        result = ssh_command('imc', command)
-    except Exception as e:
-        print(f"Failed with exception:\n{e}")
-
-    command = f'chmod +x {acc_path}/{host_path}/*'
-    try:
-        result = ssh_command('acc', command)
-    except Exception as e:
-        print(f"Failed with exception:\n{e}")
-
-
-def get_interface_info(server_name, interface_name):
-    """
-    Retrieve information about a network interface on a remote server.
-
-    :param server_name: The name of the server where the interface is located.
-    :param interface_name: The name of the network interface to query.
-    :return: A dictionary containing various pieces of information about the interface.
-    """
-    # Initialize an empty dictionary to store interface information
-    interface_info = {}
-
-    # Define a mapping of server names to host IDs
-    host_id = {
-        'host': '0x0',
-        'acc': '0x4',
-        'imc': '0x5'
-    }
-
-    # Command to get basic interface information using ifconfig
-    cmd = f"ifconfig {interface_name}"
-    try:
-        result = ssh_command(server_name, cmd)
-    except Exception as e:
-        logging.error(f"Failed to run ifconfig on '{interface_name}': {e}")
-        return interface_info
-
-    output = result['output']
-
-    # Regex patterns to extract IP, MAC, and other fields
-    ip_pattern = re.compile(r'inet (\d+\.\d+\.\d+\.\d+)')
-    mac_pattern = re.compile(r'ether ([0-9a-fA-F:]{17})')
-    mtu_pattern = re.compile(r'mtu (\d+)')
-
-    # Search for patterns in the output and populate the dictionary
-    interface_info['ip'] = ip_pattern.search(output).group(1) if ip_pattern.search(output) else None
-    interface_info['mac'] = mac_pattern.search(output).group(1) if mac_pattern.search(output) else None
-    interface_info['mtu'] = mtu_pattern.search(output).group(1) if mtu_pattern.search(output) else None
-
-    # Command to get detailed interface information using ethtool
-    cmd = f"ethtool -i {interface_name}"
-    try:
-        result = ssh_command(server_name, cmd)
-    except Exception as e:
-        logging.warning(f"Failed to run ethtool on '{interface_name}': {e}")
-        return interface_info
-
-    output = result['output']
-
-    # Parse ethtool output and add to the dictionary
-    for line in output.split('\n'):
-        field = line.split(': ')
-        if len(field) == 2:
-            interface_info[field[0].strip()] = field[1].strip()
-
-    # Check if the driver is not 'idpf' and return the info collected so far
-    if interface_info.get('driver') != 'idpf':
-        return interface_info
-
-    # Command to get additional interface information for 'idpf' interface from IMC
-    cmd = f"cli_client -q -c | grep 'host_id: {host_id[server_name]}' | grep '{interface_info['mac']}'"
-    try:
-        result = ssh_command('imc', cmd)
-    except Exception as e:
-        logging.warning(f"Failed to run cli_client on '{interface_name}': {e}")
-        return interface_info
-
-    output = result['output']
-
-    # Regex pattern to extract additional fields for 'idpf' driver
-    pattern = re.compile(r'fn_id:\s+(\w+)\s+host_id:\s+(\w+)\s+is_vf:\s+(\w+)\s+vsi_id:\s+(\w+)\s+vport_id\s+(\w+)\s+is_created:\s+(\w+)\s+is_enabled:\s+(\w+)\s+mac\s+addr:\s+([0-9a-fA-F:]{17})')
-    match = pattern.search(output)
-
-    # Populate the dictionary with additional information if available
-    if match:
-        interface_info.update({
-            'fn_id': match.group(1),
-            'host_id': match.group(2),
-            'is_vf': match.group(3),
-            'vsi_id': match.group(4),
-            'vport_id': match.group(5),
-            'is_created': match.group(6),
-            'is_enabled': match.group(7),
-            'mac_addr': match.group(8)
-        })
-
-        # Calculate additional fields based on 'vsi_id'
-        if interface_info['vsi_id']:
-            interface_info['vsi_num'] = str(int(interface_info['vsi_id'], 16))
-            port_offset = str(int(interface_info['vsi_id'], 16) + 16)
-            interface_info['port'] = port_offset
-
-    return interface_info
-
-
-def ping_test(dst_ip, count=4, vm = None):
-    if vm:
-        cmd = f"ip netns exec {vm} ping {dst_ip} -c {count}"
-    else:
-        cmd = f"ping {dst_ip} -c {count}"
-    try:
-        result = run_cmd(cmd, output=True)
-        pkt_loss = 100
-        if result:
-            match = re.search('(\d*)% packet loss', result)
-            if match:
-                pkt_loss = int(match.group(1))
-            if f"{count} received, 0% packet loss" in result:
-                print(f"PASS: Ping successful to destination {dst_ip}\n")
-                return True
-            else:
-                raise RuntimeError(f"FAIL: Ping Failed to destination {dst_ip} with" f" {pkt_loss}% loss\n")
-    except Exception as E:
-        print(f"Ping run failed with error:'{E}'\n")
-        return False
-
-
-
-def split_mac(mac_address):
-    # Split the MAC address by colons
-    octets = mac_address.split(":") 
-
-    # Join the first three octets and the last three octets
-    first_octet = "".join(octets[:2])
-    second_octet = "".join(octets[2:4])
-    third_octet = "".join(octets[4:])
-    
-    print("first octet {} second octet {} third octet {}".format(first_octet, second_octet, third_octet))
-    return first_octet, second_octet, third_octet
-
-def split_mac_2(mac_address):
-    # Split the MAC address by colons
-    octets = mac_address.split(":")
-
-    # Join the first three octets and the last three octets
-    first_split = "".join(octets[:2])
-    second_split = "".join(octets[2:])
-
-    return first_split, second_split
-
-def ip_dec_to_hex(ip_address):
-    octets = ip_address.split('.')
-    hex_octets = [f"{int(octet):02X}" for octet in octets]
-    return "".join(hex_octets)
-
-class tmux_term:
-    def __init__(self, tmux_name="", tmux_override=False):
-        # Initialize a new tmux terminal session
-        if not tmux_name:
-            raise ValueError("Error: No tmux name specified!")
-        self.tmux_name = tmux_name
-
-        # Check if the specified tmux session already exists
-        command = 'tmux ls'
-        try:
-            result = ssh_command('host', command, check_returncode=False)
-        except Exception as e:
-            raise Exception(f"Failed to list tmux sessions with exception:\n{e}")
-
-        # Parse the output to find an existing session
-        lines = result['output']
-        found = any(self.tmux_name in line for line in lines.split('\n'))
-
-        # If the session is found and override is allowed, kill the existing session
-        if found and tmux_override:
-            command = f'tmux kill-session -t {self.tmux_name}'
-            ssh_command('host', command)
-
-        # If the session was not found or was killed, create a new one
-        if not found or tmux_override:
-            command = f'tmux new-session -d -s {self.tmux_name}'
-            ssh_command('host', command)
-
-    def tmux_send_keys(self, cmd, delay=1, output=True):
-        # Send a command to the tmux session and optionally capture the output
-        time.sleep(0.5)  # Short delay before sending the command
-
-        if output:
-            # Set up piping to capture the output of the command
-            output_file = os.path.join(os.getcwd(), 'tmux_output.txt')
-            command = f'tmux pipe-pane -t {self.tmux_name} "cat > {output_file}"'
-            ssh_command('host', command)
-
-        # Send the actual command to the tmux session
-        command = f'tmux send-keys -t {self.tmux_name} "{cmd}" C-m'
-        ssh_command('host', command)
-
-        if output:
-            # Wait for the specified delay to allow the command to execute and output to be captured
-            if delay > 0:
-                time.sleep(delay)
-
-            # Stop piping the output
-            command = f'tmux pipe-pane -t {self.tmux_name}'
-            ssh_command('host', command)
-
-            # Read the captured output from the file
-            with open(output_file, "r") as f:
-                result = f.read()
-
-        return result
diff --git a/ipsec_accel/config_host1.yaml b/ipsec_accel/config_host1.yaml
index 8da4301..f15f5f2 100644
--- a/ipsec_accel/config_host1.yaml
+++ b/ipsec_accel/config_host1.yaml
@@ -1,9 +1,9 @@
 host:
   ssh:
-    ip: 10.232.27.15
-    username: admin12
+    ip: 127.0.0.1
+    username: root
     # Update the login password for the IPU Host
-    password: "bfn123"
+    password: ""
 
 imc:
   ssh:
diff --git a/ipsec_accel/config_host2.yaml b/ipsec_accel/config_host2.yaml
index acfe55f..c398736 100644
--- a/ipsec_accel/config_host2.yaml
+++ b/ipsec_accel/config_host2.yaml
@@ -1,9 +1,9 @@
 host:
   ssh:
-    ip: 10.232.27.15
-    username: admin12
+    ip: 127.0.0.1
+    username: root
     # Update the login password for the IPU Host
-    password: "bfn123"
+    password: ""
 
 imc:
   ssh:
diff --git a/ipsec_accel/ipsec_accel.py b/ipsec_accel/ipsec_accel.py
index 8d196c0..0bf2feb 100755
--- a/ipsec_accel/ipsec_accel.py
+++ b/ipsec_accel/ipsec_accel.py
@@ -6,9 +6,29 @@
 # Python tool to setup Linux Networking with OVS Offload on Intel速 Infrastructure Processing Unit (Intel速 IPU)
 
 import sys,argparse
+import os
+
+# Add the parent directory to the system path
+sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
 from common.utils import *
 
-def build_p4rt_config(vf_list=[], acc_pr_list=[],vm_ip_list=[], host_idpf_intf='', path='', comm_ip_host='', comm_ip_acc='', ipsec_host=''):
+def build_p4rt_config(test_setup = None):
+
+    if test_setup == None:
+        print("Unable to parse the config.yaml to generate test configuration")
+        sys.exit()
+
+    host_idpf_intf= test_setup.test_config['test_params']['idpf_interface']
+    vf_list = test_setup.test_config['test_params']['vf_interfaces']
+    acc_pr_list = test_setup.test_config['test_params']['acc_pr_interfaces']
+    vm_ip_list = test_setup.test_config['test_params']['ip_list']
+    path = test_setup.test_config['test_params']['host_path']
+    comm_ip_host = test_setup.test_config['test_params']['comm_ip_host']
+    comm_ip_acc = test_setup.test_config['test_params']['comm_ip_acc']
+    ipsec_host = test_setup.test_config['test_params']['ipsec_host']
+    local_vxlan_tunnel_mac =  test_setup.test_config['test_params']['local_vxlan_tunnel_mac']
+    remote_vxlan_ip = test_setup.test_config['test_params']['remote_vxlan_ip']
+    remote_vxlan_mac = test_setup.test_config['test_params']['remote_vxlan_mac']
 
     print("---------- Generating Configs to run infrap4d, p4rt, OVS and IPsec ----------")
 
@@ -72,7 +92,7 @@ EOF
 
     for command in host_command_list:
         try:
-            result = ssh_command('host', command)
+            result = test_setup.ssh_command('host', command)
         except Exception as e:
             print(f"Failed with exception:\n{e}")
     time.sleep(5)
@@ -82,11 +102,11 @@ EOF
     phy_to_acc = ''
     vf_to_vm = ''
     ovs_vxlan = ''
-    local_vtep = test_config['test_params']['local_vtep']
-    remote_vtep = test_config['test_params']['remote_vtep']
-    local_br_tun = test_config['test_params']['local_br_tun_ip']
-    remote_br_tun = test_config['test_params']['remote_br_tun_ip']
-    comm_ip_acc: test_config['test_params']['comm_ip_acc']
+    local_vtep = test_setup.test_config['test_params']['local_vtep']
+    remote_vtep = test_setup.test_config['test_params']['remote_vtep']
+    local_br_tun = test_setup.test_config['test_params']['local_br_tun_ip']
+    remote_br_tun = test_setup.test_config['test_params']['remote_br_tun_ip']
+    comm_ip_acc: test_setup.test_config['test_params']['comm_ip_acc']
 
     vm_id = 0
     command_list = []
@@ -94,12 +114,12 @@ EOF
     command_list.append(cmd)
     vf_list_len = len(vf_list)
     for i in range(vf_list_len):
-        print("vf list len {} i is {} vf_list is {}".format(vf_list_len, i, vf_list[i])) 
+        print("vf list len {} i is {} vf_list is {}".format(vf_list_len, i, vf_list[i]))
         if str(vf_list[i]) == '0' or str(vf_list[i]) == '1':
         #Physical port   VSI_ID  PORT             ACC port representer  VSI_ID    PORT
         #Phy port 0      (0x0)    0     <---->    enp0s1f0d10         (0x11) 17   33
             print(acc_pr_list[i])
-            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            acc_pr = test_setup.get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
             phy_to_acc += f"""echo ""
 echo "IPU Physical Port {vf_list[i]} maps to "
 echo "ACC IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
@@ -119,8 +139,8 @@ ovs-vsctl add-br br-tun-{vf_list[i]}
 ovs-vsctl add-port br-tun-{vf_list[i]} {acc_pr_list[i]}
 """
         else:
-            vf = get_interface_info(server_name='host', interface_name=vf_list[i])
-            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            vf = test_setup.get_interface_info(server_name='host', interface_name=vf_list[i])
+            acc_pr = test_setup.get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
             vf_to_acc += f"""echo ""
 echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']})  PORT ({vf['port']}) maps to"
 echo "ACC  IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
@@ -175,7 +195,7 @@ p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.la
 p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=7/7,priority=1,action=linux_networking_control.bypass"
 """
 
-    acc_path = test_config['test_params']['acc_path']
+    acc_path = test_setup.test_config['test_params']['acc_path']
     acc_p4_path = f'{acc_path}/fxp-net_linux-networking'
     file = f'{path}/es2k_skip_p4.conf'
     p4_config = 'cat <<EOF > ./'+file+'''
@@ -290,7 +310,7 @@ EOF
     file = f'{path}/copy_certs.sh'
     copy_certs = 'cat <<EOF > ./'+file+'''
 #!/bin/sh
-#Copy certs 
+#Copy certs
 echo ""
 echo "Copy the certs from ACC to host"
 mkdir -p /usr/share/stratum/
@@ -443,7 +463,7 @@ alias p4rt-ctl='p4rt-ctl -g  '''+comm_ip_acc+''':9559 '
 
 echo ""
 echo "p4rt-ctl dump-entries br0 linux_networking_control.rx_source_port "
-p4rt-ctl dump-entries br0 
+p4rt-ctl dump-entries br0
 
 EOF
 '''
@@ -815,7 +835,7 @@ EOF
 
     for command in command_list:
         try:
-            result = ssh_command('host', command)
+            result = test_setup.ssh_command('host', command)
         except Exception as e:
             print(f"Failed with exception:\n{e}")
 
@@ -842,46 +862,37 @@ def build_args():
 
 
 if __name__ == "__main__":
-    host_path = test_config['test_params']['host_path']
-    imc_path = test_config['test_params']['imc_path']
-    acc_path = test_config['test_params']['acc_path']
-    idpf_interface = test_config['test_params']['idpf_interface']
-    comm_ip_host = test_config['test_params']['comm_ip_host']
-    comm_ip_acc = test_config['test_params']['comm_ip_acc']    
-    vf_interfaces = test_config['test_params']['vf_interfaces']
-    acc_pr_interfaces = test_config['test_params']['acc_pr_interfaces']
-    ip_list=test_config['test_params']['ip_list']
-    imc_ip = test_config['imc']['ssh']['ip']
-    acc_ip = test_config['acc']['ssh']['ip']
+    test_setup = TestSetup(config_file = f'{os.path.dirname(os.path.abspath(__file__))}/config.yaml')
+    host_path = test_setup.test_config['test_params']['host_path']
+    imc_path = test_setup.test_config['test_params']['imc_path']
+    acc_path = test_setup.test_config['test_params']['acc_path']
+    ip_list = test_setup.test_config['test_params']['ip_list']
+    imc_ip = test_setup.test_config['imc']['ssh']['ip']
+    acc_ip = test_setup.test_config['acc']['ssh']['ip']
     acc_p4_path = f'{acc_path}/fxp-net_linux-networking'
-    host_password = test_config['host']['ssh']['password']
+    host_password = test_setup.test_config['host']['ssh']['password']
     imc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
     acc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
-    strongSwan_build = test_config['test_params']['strongSwan_build']
-    ipsec_host = test_config['test_params']['ipsec_host']
-    local_vxlan_tunnel_mac =  test_config['test_params']['local_vxlan_tunnel_mac']
-    remote_vxlan_ip = test_config['test_params']['remote_vxlan_ip']
-    remote_vxlan_mac = test_config['test_params']['remote_vxlan_mac']
-
+    strongSwan_build = test_setup.test_config['test_params']['strongSwan_build']
+    ipsec_host = test_setup.test_config['test_params']['ipsec_host']
 
     parser = build_args()
     # Parse the arguments
     args = parser.parse_args()
 
-    host_ipsec = tmux_term(tmux_name="test_host_ipsec",tmux_override=True)
+    host_ipsec = tmux_term(test_setup=test_setup, tmux_name="test_host_ipsec",tmux_override=True)
     # Execute the appropriate function based on the subcommand
     if args.command == 'create_script':
-
         print("\n----------------Create IPsec Offload scripts----------------")
-        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list, host_idpf_intf=idpf_interface, path=host_path, \
-                            comm_ip_host=comm_ip_host, comm_ip_acc=comm_ip_acc, ipsec_host=ipsec_host)
+        build_p4rt_config(test_setup = test_setup)
 
     elif args.command == 'copy_script':
         print("\n----------------Create IPsec Offload scripts----------------")
-        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list, host_idpf_intf=idpf_interface, path=host_path, \
-                            comm_ip_host=comm_ip_host, comm_ip_acc=comm_ip_acc, ipsec_host=ipsec_host)
+        build_p4rt_config(test_setup = test_setup)
+        #build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list, host_idpf_intf=idpf_interface, path=host_path, \
+        #                    comm_ip_host=comm_ip_host, comm_ip_acc=comm_ip_acc, ipsec_host=ipsec_host)
         print("\n----------------Copy IPsec Offload scripts to the ACC----------------")
-        copy_scripts(host_path = host_path, imc_path = imc_path , acc_path = acc_path)
+        test_setup.copy_scripts()
 
     elif args.command == 'setup':
 
@@ -892,9 +903,9 @@ if __name__ == "__main__":
         print("\n----------------Setup Linux Networking for IPsec Offload----------------")
 
 
-        # Setup a TMUX session, for host comm channel 
+        # Setup a TMUX session, for host comm channel
         print("\n----------------Setup TMUX Session and Login to the Host----------------")
-        host_comm = tmux_term(tmux_name="test_host_comm",tmux_override=True)
+        host_comm = tmux_term(test_setup=test_setup, tmux_name="test_host_comm",tmux_override=True)
         cwd = os.getcwd()
         print("cwd  {}".format(cwd))
         result = host_comm.tmux_send_keys('sudo -s', delay=2, output=True)
@@ -908,9 +919,9 @@ if __name__ == "__main__":
         print(result)
 
 
-        # Setup a TMUX session, Login to ACC and configure ACC comm channel for Host - ACC Communication 
+        # Setup a TMUX session, Login to ACC and configure ACC comm channel for Host - ACC Communication
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        acc_comm = tmux_term(tmux_name="test_acc_comm",tmux_override=True)
+        acc_comm = tmux_term(test_setup=test_setup, tmux_name="test_acc_comm",tmux_override=True)
         result = acc_comm.tmux_send_keys(imc_login, delay=2, output=True)
         result = acc_comm.tmux_send_keys(acc_login, delay=2, output=True)
         result = acc_comm.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
@@ -944,7 +955,7 @@ if __name__ == "__main__":
 
         # Setup a TMUX session, Login to ACC and start infrap4d
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        infrap4d = tmux_term(tmux_name="test_infrap4d",tmux_override=True)
+        infrap4d = tmux_term(test_setup=test_setup, tmux_name="test_infrap4d",tmux_override=True)
         result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
         result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
 
@@ -962,7 +973,7 @@ if __name__ == "__main__":
 
         # Setup a TMUX session, Login to ACC, configure p4rt rules and ovs bridges
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        p4rt = tmux_term(tmux_name="test_p4rt",tmux_override=True)
+        p4rt = tmux_term(test_setup=test_setup, tmux_name="test_p4rt",tmux_override=True)
         result = p4rt.tmux_send_keys(imc_login, delay=2)
         result = p4rt.tmux_send_keys(acc_login, delay=2)
         result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
@@ -983,7 +994,7 @@ if __name__ == "__main__":
 
         # Setup a TMUX session for the IPU host, configure the VMs, idpf interfaces, Link partner interfaces and run ping checks
         print("\n----------------Setup TMUX Session and Login to the Host----------------")
-        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        host = tmux_term(test_setup=test_setup, tmux_name="test3_host",tmux_override=True)
         result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
         result = host.tmux_send_keys('sudo -s', delay=2, output=True)
         result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
@@ -1014,7 +1025,7 @@ if __name__ == "__main__":
 
     elif args.command == 'ipsec_tunnel':
         print("\n----------------Configuration for tunnel mode----------------")
-        p4rt = tmux_term(tmux_name="test_p4rt",tmux_override=True)
+        p4rt = tmux_term(test_setup=test_setup, tmux_name="test_p4rt",tmux_override=True)
         result = p4rt.tmux_send_keys(imc_login, delay=2)
         result = p4rt.tmux_send_keys(acc_login, delay=2)
         result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
@@ -1050,7 +1061,7 @@ if __name__ == "__main__":
         print("\n----------------Teardown Linux Networking with IPsec Offload----------------")
 
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        p4rt = tmux_term(tmux_name="test_p4rt",tmux_override=True)
+        p4rt = tmux_term(test_setup=test_setup, tmux_name="test_p4rt",tmux_override=True)
         result = p4rt.tmux_send_keys(imc_login, delay=2)
         result = p4rt.tmux_send_keys(acc_login, delay=2)
         result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
@@ -1081,7 +1092,7 @@ ovs-vsctl show
         print(result)
 
         print("\n----------------Stop Infrap4d on the ACC----------------")
-        infrap4d = tmux_term(tmux_name="test_infrap4d",tmux_override=True)
+        infrap4d = tmux_term(test_setup=test_setup, tmux_name="test_infrap4d",tmux_override=True)
         result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
         result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
         result = infrap4d.tmux_send_keys('ps -aux | grep infrap4d', delay=2, output=True)
diff --git a/ovs_offload/__init__.py b/ovs_offload/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/ovs_offload/common/utils.py b/ovs_offload/common/utils.py
deleted file mode 100644
index 326eab9..0000000
--- a/ovs_offload/common/utils.py
+++ /dev/null
@@ -1,286 +0,0 @@
-#!/usr/bin/python
-#
-# Copyright 2022-2024 Intel Corporation
-# SPDX-License-Identifier: Apache-2.0
-#
-# Common python APIs and utilities for Intel速 Infrastructure Processing Unit (Intel速 IPU)
-
-import subprocess, os, time, re
-import yaml
-
-def fetch_configurations(config_file=''):
-    with open(config_file, "r") as file:
-        config_data = yaml.safe_load(file)
-    return config_data
-
-#Fetch test configuration
-test_config = fetch_configurations(f'{os.path.dirname(os.path.abspath(__file__))}/../config.yaml')
-
-def run_cmd(cmd, output=False, check_returncode=True):
-    """
-    Execute a command in a subprocess.
-    :param cmd: The command to be executed as a string.
-    :param output: If True, capture and return the command's stdout.
-    :param check_returncode: If True, check the command's return code and raise an error if not 0.
-    :return: The stdout of the command if output is True, otherwise None.
-    """
-    print(f'Executing: {cmd}')
-    # Use a context manager to ensure the subprocess is cleaned up after execution
-    with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE if output else None, stderr=subprocess.PIPE, encoding="utf-8") as s:
-        outs, errs = s.communicate() if output else (None, None)
-        # Check the return code if required
-        if check_returncode and s.returncode != 0:
-            raise subprocess.CalledProcessError(s.returncode, cmd, output=outs, stderr=errs)
-        return outs.strip() if output else None
-
-def ssh_command(server_name, command, output=True, check_returncode=True):
-    """
-    Execute a command on a remote server via SSH.
-    :param server_name: The name of the server ('host', 'imc', or 'acc').
-    :param command: The command to be executed on the remote server.
-    :return: A dictionary with the return code and the command's output.
-    """
-    imc_ip = test_config['imc']['ssh']['ip']
-    acc_ip = test_config['acc']['ssh']['ip']
-    # SSH command templates
-    imc_access = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
-    acc_access = f'{imc_access} ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
-
-    # Determine the appropriate SSH command based on the server name
-    if server_name == 'host':
-        full_cmd = command
-    elif server_name == 'imc':
-        full_cmd = f'{imc_access} "{command}"'
-    elif server_name == 'acc':
-        full_cmd = f'{acc_access} "{command}"'
-    else:
-        raise ValueError(f"Unknown server name: {server_name}")
-
-    # Execute the command and capture the output
-    output = run_cmd(full_cmd, output = output, check_returncode = check_returncode)
-
-    # Return the result as a dictionary
-    return {'rc': 0, 'output': output}
-
-
-def copy_scripts(host_path='ovs_offload_lnw_scripts', imc_path = '/mnt/imc/p4_test', acc_path = '/opt/p4/p4sde/p4_test'):
-    """
-    Copies configuration scripts from the host to the IMC and then to the ACC.
-
-    :param host_path: Path to the configuration scripts on the host machine
-    :param imc_path: Destination path on the IMC
-    :param acc_path: Destination path on the ACC
-    """
-    imc_ip = test_config['imc']['ssh']['ip']
-    acc_ip = test_config['acc']['ssh']['ip']
-
-    command = f'mkdir -p {imc_path}'
-    try:
-        result = ssh_command('imc', command)
-    except Exception as e:
-        print(f"Failed with exception:\n{e}")
-
-    command = f'mkdir -p {acc_path}'
-    try:
-        result = ssh_command('acc', command)
-    except Exception as e:
-        print(f"Failed with exception:\n{e}")
-
-    # Copy the configuration scripts from host to IMC
-    command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {host_path}  root@{imc_ip}:{imc_path}/'
-    try:
-        result = ssh_command('host', command)
-    except Exception as e:
-        print(f"Failed with exception:\n{e}")
-
-    command = f'chmod +x {imc_path}/{host_path}/*'
-    try:
-        result = ssh_command('imc', command)
-    except Exception as e:
-        print(f"Failed with exception:\n{e}")
-
-    # Copy the configuration scripts from IMC to ACC
-    command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {imc_path}/{host_path} root@{acc_ip}:{acc_path}/'
-    try:
-        result = ssh_command('imc', command)
-    except Exception as e:
-        print(f"Failed with exception:\n{e}")
-
-    command = f'chmod +x {acc_path}/{host_path}/*'
-    try:
-        result = ssh_command('acc', command)
-    except Exception as e:
-        print(f"Failed with exception:\n{e}")
-
-
-def get_interface_info(server_name, interface_name):
-    """
-    Retrieve information about a network interface on a remote server.
-
-    :param server_name: The name of the server where the interface is located.
-    :param interface_name: The name of the network interface to query.
-    :return: A dictionary containing various pieces of information about the interface.
-    """
-    # Initialize an empty dictionary to store interface information
-    interface_info = {}
-
-    # Define a mapping of server names to host IDs
-    host_id = {
-        'host': '0x0',
-        'acc': '0x4',
-        'imc': '0x5'
-    }
-
-    # Command to get basic interface information using ifconfig
-    cmd = f"ifconfig {interface_name}"
-    try:
-        result = ssh_command(server_name, cmd)
-    except Exception as e:
-        logging.error(f"Failed to run ifconfig on '{interface_name}': {e}")
-        return interface_info
-
-    output = result['output']
-
-    # Regex patterns to extract IP, MAC, and other fields
-    ip_pattern = re.compile(r'inet (\d+\.\d+\.\d+\.\d+)')
-    mac_pattern = re.compile(r'ether ([0-9a-fA-F:]{17})')
-    mtu_pattern = re.compile(r'mtu (\d+)')
-
-    # Search for patterns in the output and populate the dictionary
-    interface_info['ip'] = ip_pattern.search(output).group(1) if ip_pattern.search(output) else None
-    interface_info['mac'] = mac_pattern.search(output).group(1) if mac_pattern.search(output) else None
-    interface_info['mtu'] = mtu_pattern.search(output).group(1) if mtu_pattern.search(output) else None
-
-    # Command to get detailed interface information using ethtool
-    cmd = f"ethtool -i {interface_name}"
-    try:
-        result = ssh_command(server_name, cmd)
-    except Exception as e:
-        logging.warning(f"Failed to run ethtool on '{interface_name}': {e}")
-        return interface_info
-
-    output = result['output']
-
-    # Parse ethtool output and add to the dictionary
-    for line in output.split('\n'):
-        field = line.split(': ')
-        if len(field) == 2:
-            interface_info[field[0].strip()] = field[1].strip()
-
-    # Check if the driver is not 'idpf' and return the info collected so far
-    if interface_info.get('driver') != 'idpf':
-        return interface_info
-
-    # Command to get additional interface information for 'idpf' interface from IMC
-    cmd = f"cli_client -q -c | grep 'host_id: {host_id[server_name]}' | grep '{interface_info['mac']}'"
-    try:
-        result = ssh_command('imc', cmd)
-    except Exception as e:
-        logging.warning(f"Failed to run cli_client on '{interface_name}': {e}")
-        return interface_info
-
-    output = result['output']
-
-    # Regex pattern to extract additional fields for 'idpf' driver
-    pattern = re.compile(r'fn_id:\s+(\w+)\s+host_id:\s+(\w+)\s+is_vf:\s+(\w+)\s+vsi_id:\s+(\w+)\s+vport_id\s+(\w+)\s+is_created:\s+(\w+)\s+is_enabled:\s+(\w+)\s+mac\s+addr:\s+([0-9a-fA-F:]{17})')
-    match = pattern.search(output)
-
-    # Populate the dictionary with additional information if available
-    if match:
-        interface_info.update({
-            'fn_id': match.group(1),
-            'host_id': match.group(2),
-            'is_vf': match.group(3),
-            'vsi_id': match.group(4),
-            'vport_id': match.group(5),
-            'is_created': match.group(6),
-            'is_enabled': match.group(7),
-            'mac_addr': match.group(8)
-        })
-
-        # Calculate additional fields based on 'vsi_id'
-        if interface_info['vsi_id']:
-            interface_info['vsi_num'] = str(int(interface_info['vsi_id'], 16))
-            port_offset = str(int(interface_info['vsi_id'], 16) + 16)
-            interface_info['port'] = port_offset
-
-    return interface_info
-
-
-def ping_test(dst_ip, count=4, vm = None):
-    if vm:
-        cmd = f"ip netns exec {vm} ping {dst_ip} -c {count}"
-    else:
-        cmd = f"ping {dst_ip} -c {count}"
-    try:
-        result = run_cmd(cmd, output=True)
-        pkt_loss = 100
-        if result:
-            match = re.search('(\d*)% packet loss', result)
-            if match:
-                pkt_loss = int(match.group(1))
-            if f"{count} received, 0% packet loss" in result:
-                print(f"PASS: Ping successful to destination {dst_ip}\n")
-                return True
-            else:
-                raise RuntimeError(f"FAIL: Ping Failed to destination {dst_ip} with" f" {pkt_loss}% loss\n")
-    except Exception as E:
-        print(f"Ping run failed with error:'{E}'\n")
-        return False
-
-class tmux_term:
-    def __init__(self, tmux_name="", tmux_override=False):
-        # Initialize a new tmux terminal session
-        if not tmux_name:
-            raise ValueError("Error: No tmux name specified!")
-        self.tmux_name = tmux_name
-
-        # Check if the specified tmux session already exists
-        command = 'tmux ls'
-        try:
-            result = ssh_command('host', command, check_returncode=False)
-        except Exception as e:
-            raise Exception(f"Failed to list tmux sessions with exception:\n{e}")
-
-        # Parse the output to find an existing session
-        lines = result['output']
-        found = any(self.tmux_name in line for line in lines.split('\n'))
-
-        # If the session is found and override is allowed, kill the existing session
-        if found and tmux_override:
-            command = f'tmux kill-session -t {self.tmux_name}'
-            ssh_command('host', command)
-
-        # If the session was not found or was killed, create a new one
-        if not found or tmux_override:
-            command = f'tmux new-session -d -s {self.tmux_name}'
-            ssh_command('host', command)
-
-    def tmux_send_keys(self, cmd, delay=1, output=True):
-        # Send a command to the tmux session and optionally capture the output
-        time.sleep(0.5)  # Short delay before sending the command
-
-        if output:
-            # Set up piping to capture the output of the command
-            output_file = os.path.join(os.getcwd(), 'tmux_output.txt')
-            command = f'tmux pipe-pane -t {self.tmux_name} "cat > {output_file}"'
-            ssh_command('host', command)
-
-        # Send the actual command to the tmux session
-        command = f'tmux send-keys -t {self.tmux_name} "{cmd}" C-m'
-        ssh_command('host', command)
-
-        if output:
-            # Wait for the specified delay to allow the command to execute and output to be captured
-            if delay > 0:
-                time.sleep(delay)
-
-            # Stop piping the output
-            command = f'tmux pipe-pane -t {self.tmux_name}'
-            ssh_command('host', command)
-
-            # Read the captured output from the file
-            with open(output_file, "r") as f:
-                result = f.read()
-
-        return result
diff --git a/ovs_offload/ovs_offload_lnw.py b/ovs_offload/ovs_offload_lnw.py
index 23b74bf..778312b 100755
--- a/ovs_offload/ovs_offload_lnw.py
+++ b/ovs_offload/ovs_offload_lnw.py
@@ -6,9 +6,23 @@
 # Python tool to setup Linux Networking with OVS Offload on Intel速 Infrastructure Processing Unit (Intel速 IPU)
 
 import sys,argparse
+import os
+
+# Add the parent directory to the system path
+sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
 from common.utils import *
 
-def build_p4rt_config(vf_list=[], acc_pr_list=[],vm_ip_list=[], host_idpf_intf='', path=''):
+def build_p4rt_config(test_setup = None):
+
+    if test_setup == None:
+        print("Unable to parse the config.yaml to generate test configuration")
+        sys.exit()
+
+    host_idpf_intf= test_setup.test_config['test_params']['idpf_interface']
+    vf_list = test_setup.test_config['test_params']['vf_interfaces']
+    acc_pr_list = test_setup.test_config['test_params']['acc_pr_interfaces']
+    vm_ip_list = test_setup.test_config['test_params']['ip_list']
+    path = test_setup.test_config['test_params']['host_path']
 
     print("---------- Generating Configs to run infrap4d, p4rt and OVS ----------")
 
@@ -47,7 +61,7 @@ EOF
 
     for command in host_command_list:
         try:
-            result = ssh_command('host', command)
+            result = test_setup.ssh_command('host', command)
         except Exception as e:
             print(f"Failed with exception:\n{e}")
     time.sleep(5)
@@ -57,10 +71,10 @@ EOF
     phy_to_acc = ''
     vf_to_vm = ''
     ovs_vxlan = ''
-    local_vtep = test_config['test_params']['local_vtep']
-    remote_vtep = test_config['test_params']['remote_vtep']
-    local_br_tun = test_config['test_params']['local_br_tun_ip']
-    remote_br_tun = test_config['test_params']['remote_br_tun_ip']
+    local_vtep = test_setup.test_config['test_params']['local_vtep']
+    remote_vtep = test_setup.test_config['test_params']['remote_vtep']
+    local_br_tun = test_setup.test_config['test_params']['local_br_tun_ip']
+    remote_br_tun = test_setup.test_config['test_params']['remote_br_tun_ip']
     vm_id = 0
     command_list = []
     cmd = f"mkdir -p {path}"
@@ -70,7 +84,7 @@ EOF
         if str(vf_list[i]) == '0' or str(vf_list[i]) == '1':
         #Physical port   VSI_ID  PORT             ACC port representer  VSI_ID    PORT
         #Phy port 0      (0x0)    0     <---->    enp0s1f0d10         (0x11) 17   33
-            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            acc_pr = test_setup.get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
             phy_to_acc += f"""echo ""
 echo "IPU Physical Port {vf_list[i]} maps to "
 echo "ACC IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
@@ -91,8 +105,8 @@ ovs-vsctl add-port br-tun-{vf_list[i]} {acc_pr_list[i]}
 
 """
         else:
-            vf = get_interface_info(server_name='host', interface_name=vf_list[i])
-            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            vf = test_setup.get_interface_info(server_name='host', interface_name=vf_list[i])
+            acc_pr = test_setup.get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
             vf_to_acc += f"""echo ""
 echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']})  PORT ({vf['port']}) maps to"
 echo "ACC  IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
@@ -147,7 +161,7 @@ p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.la
 p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=7/7,priority=1,action=linux_networking_control.bypass"
 """
 
-    acc_path = test_config['test_params']['acc_path']
+    acc_path = test_setup.test_config['test_params']['acc_path']
     acc_p4_path = f'{acc_path}/fxp-net_linux-networking'
     file = f'{path}/es2k_skip_p4.conf'
     p4_config = 'cat <<EOF > ./'+file+'''
@@ -536,7 +550,7 @@ EOF
 
     for command in command_list:
         try:
-            result = ssh_command('host', command)
+            result = test_setup.ssh_command('host', command)
         except Exception as e:
             print(f"Failed with exception:\n{e}")
 
@@ -559,19 +573,17 @@ def build_args():
 
 
 if __name__ == "__main__":
-    host_path = test_config['test_params']['host_path']
-    imc_path = test_config['test_params']['imc_path']
-    acc_path = test_config['test_params']['acc_path']
-    idpf_interface = test_config['test_params']['idpf_interface']
-    vf_interfaces = test_config['test_params']['vf_interfaces']
-    acc_pr_interfaces = test_config['test_params']['acc_pr_interfaces']
-    ip_list=test_config['test_params']['ip_list']
-    imc_ip = test_config['imc']['ssh']['ip']
-    acc_ip = test_config['acc']['ssh']['ip']
+    test_setup = TestSetup(config_file = f'{os.path.dirname(os.path.abspath(__file__))}/config.yaml')
+    host_path = test_setup.test_config['test_params']['host_path']
+    imc_path = test_setup.test_config['test_params']['imc_path']
+    acc_path = test_setup.test_config['test_params']['acc_path']
+    ip_list = test_setup.test_config['test_params']['ip_list']
+    imc_ip = test_setup.test_config['imc']['ssh']['ip']
+    acc_ip = test_setup.test_config['acc']['ssh']['ip']
     acc_p4_path = f'{acc_path}/fxp-net_linux-networking'
-    lp_interfaces = test_config['host']['lp_interfaces']
-    lp_interface_ip = test_config['host']['lp_interface_ip']
-    host_password = test_config['host']['ssh']['password']
+    lp_interfaces = test_setup.test_config['host']['lp_interfaces']
+    lp_interface_ip = test_setup.test_config['host']['lp_interface_ip']
+    host_password = test_setup.test_config['host']['ssh']['password']
     imc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
     acc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
 
@@ -583,13 +595,13 @@ if __name__ == "__main__":
     if args.command == 'create_script':
 
         print("\n----------------Create OVS OFFLOAD scripts----------------")
-        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list,host_idpf_intf=idpf_interface, path=host_path)
+        build_p4rt_config(test_setup = test_setup)
 
     elif args.command == 'copy_script':
         print("\n----------------Create OVS OFFLOAD scripts----------------")
-        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list,host_idpf_intf=idpf_interface, path=host_path)
+        build_p4rt_config(test_setup = test_setup)
         print("\n----------------Copy OVS OFFLOAD scripts to the ACC----------------")
-        copy_scripts(host_path = host_path, imc_path = imc_path , acc_path = acc_path)
+        test_setup.copy_scripts()
 
     elif args.command == 'setup':
 
@@ -601,7 +613,7 @@ if __name__ == "__main__":
 
         # Setup a TMUX session, Login to ACC and start infrap4d
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        infrap4d = tmux_term(tmux_name="test1_infrap4d",tmux_override=True)
+        infrap4d = tmux_term(test_setup=test_setup, tmux_name="test1_infrap4d",tmux_override=True)
         result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
         result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
 
@@ -617,7 +629,7 @@ if __name__ == "__main__":
 
         # Setup a TMUX session, Login to ACC, configure p4rt rules and ovs bridges
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        p4rt = tmux_term(tmux_name="test2_p4rt",tmux_override=True)
+        p4rt = tmux_term(test_setup=test_setup, tmux_name="test2_p4rt",tmux_override=True)
         result = p4rt.tmux_send_keys(imc_login, delay=2)
         result = p4rt.tmux_send_keys(acc_login, delay=2)
         result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
@@ -638,7 +650,7 @@ if __name__ == "__main__":
 
         # Setup a TMUX session for the IPU host, configure the VMs, idpf interfaces, Link partner interfaces and run ping checks
         print("\n----------------Setup TMUX Session and Login to the Host----------------")
-        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        host = tmux_term(test_setup=test_setup, tmux_name="test3_host",tmux_override=True)
         result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
         result = host.tmux_send_keys('sudo -s', delay=2, output=True)
         result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
@@ -670,7 +682,7 @@ if __name__ == "__main__":
         print("\n----------------Teardown Linux Networking with OVS OFFLOAD----------------")
 
         print("\n----------------Setup TMUX Session and Login to the Host----------------")
-        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        host = tmux_term(test_setup=test_setup, tmux_name="test3_host",tmux_override=True)
         result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
         result = host.tmux_send_keys('sudo -s', delay=2, output=True)
         result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
@@ -695,7 +707,7 @@ ip netns del VM7
         print(result)
 
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        p4rt = tmux_term(tmux_name="test2_p4rt",tmux_override=True)
+        p4rt = tmux_term(test_setup=test_setup, tmux_name="test2_p4rt",tmux_override=True)
         result = p4rt.tmux_send_keys(imc_login, delay=2)
         result = p4rt.tmux_send_keys(acc_login, delay=2)
         result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
@@ -742,7 +754,7 @@ ovs-vsctl show
         print(result)
 
         print("\n----------------Stop Infrap4d on the ACC----------------")
-        infrap4d = tmux_term(tmux_name="test1_infrap4d",tmux_override=True)
+        infrap4d = tmux_term(test_setup=test_setup, tmux_name="test1_infrap4d",tmux_override=True)
         result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
         result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
         result = infrap4d.tmux_send_keys('ps -aux | grep infrap4d', delay=2, output=True)
diff --git a/ovs_offload/ovs_offload_lnw_v2.py b/ovs_offload/ovs_offload_lnw_v2.py
index 93be7bf..452dfba 100755
--- a/ovs_offload/ovs_offload_lnw_v2.py
+++ b/ovs_offload/ovs_offload_lnw_v2.py
@@ -6,9 +6,23 @@
 # Python tool to setup Linux Networking with OVS Offload on Intel速 Infrastructure Processing Unit (Intel速 IPU)
 
 import sys,argparse
+import os
+
+# Add the parent directory to the system path
+sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
 from common.utils import *
 
-def build_p4rt_config(vf_list=[], acc_pr_list=[],vm_ip_list=[], host_idpf_intf='', path=''):
+def build_p4rt_config(test_setup = None):
+
+    if test_setup == None:
+        print("Unable to parse the config.yaml to generate test configuration")
+        sys.exit()
+
+    host_idpf_intf= test_setup.test_config['test_params']['idpf_interface']
+    vf_list = test_setup.test_config['test_params']['vf_interfaces']
+    acc_pr_list = test_setup.test_config['test_params']['acc_pr_interfaces']
+    vm_ip_list = test_setup.test_config['test_params']['ip_list']
+    path = test_setup.test_config['test_params']['host_path']
 
     print("---------- Generating Configs to run infrap4d, p4rt and OVS ----------")
 
@@ -47,7 +61,7 @@ EOF
 
     for command in host_command_list:
         try:
-            result = ssh_command('host', command)
+            result = test_setup.ssh_command('host', command)
         except Exception as e:
             print(f"Failed with exception:\n{e}")
     time.sleep(5)
@@ -57,10 +71,10 @@ EOF
     phy_to_acc = ''
     vf_to_vm = ''
     ovs_vxlan = ''
-    local_vtep = test_config['test_params']['local_vtep']
-    remote_vtep = test_config['test_params']['remote_vtep']
-    local_br_tun = test_config['test_params']['local_br_tun_ip']
-    remote_br_tun = test_config['test_params']['remote_br_tun_ip']
+    local_vtep = test_setup.test_config['test_params']['local_vtep']
+    remote_vtep = test_setup.test_config['test_params']['remote_vtep']
+    local_br_tun = test_setup.test_config['test_params']['local_br_tun_ip']
+    remote_br_tun = test_setup.test_config['test_params']['remote_br_tun_ip']
     vm_id = 0
     command_list = []
     cmd = f"mkdir -p {path}"
@@ -70,7 +84,7 @@ EOF
         if str(vf_list[i]) == '0' or str(vf_list[i]) == '1':
         #Physical port   VSI_ID  PORT             ACC port representer  VSI_ID    PORT
         #Phy port 0      (0x0)    0     <---->    enp0s1f0d10         (0x11) 17   33
-            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            acc_pr = test_setup.get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
             phy_to_acc += f"""echo ""
 echo "IPU Physical Port {vf_list[i]} maps to "
 echo "ACC IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
@@ -91,8 +105,8 @@ ovs-vsctl add-port br-tun-{vf_list[i]} {acc_pr_list[i]}
 
 """
         else:
-            vf = get_interface_info(server_name='host', interface_name=vf_list[i])
-            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            vf = test_setup.get_interface_info(server_name='host', interface_name=vf_list[i])
+            acc_pr = test_setup.get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
             vf_to_acc += f"""echo ""
 echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']})  PORT ({vf['port']}) maps to"
 echo "ACC  IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
@@ -147,7 +161,7 @@ p4rt-ctl add-entry br0  linux_networking_control.tx_lag_table "user_meta.cmeta.l
 p4rt-ctl add-entry br0  linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0,hash=7,action=linux_networking_control.bypass"
 """
 
-    acc_path = test_config['test_params']['acc_path']
+    acc_path = test_setup.test_config['test_params']['acc_path']
     acc_p4_path = f'{acc_path}/fxp-net_linux-networking-v2'
     file = f'{path}/es2k_skip_p4.conf'
     p4_config = 'cat <<EOF > ./'+file+'''
@@ -536,7 +550,7 @@ EOF
 
     for command in command_list:
         try:
-            result = ssh_command('host', command)
+            result = test_setup.ssh_command('host', command)
         except Exception as e:
             print(f"Failed with exception:\n{e}")
 
@@ -559,19 +573,17 @@ def build_args():
 
 
 if __name__ == "__main__":
-    host_path = test_config['test_params']['host_path']
-    imc_path = test_config['test_params']['imc_path']
-    acc_path = test_config['test_params']['acc_path']
-    idpf_interface = test_config['test_params']['idpf_interface']
-    vf_interfaces = test_config['test_params']['vf_interfaces']
-    acc_pr_interfaces = test_config['test_params']['acc_pr_interfaces']
-    ip_list=test_config['test_params']['ip_list']
-    imc_ip = test_config['imc']['ssh']['ip']
-    acc_ip = test_config['acc']['ssh']['ip']
+    test_setup = TestSetup(config_file = f'{os.path.dirname(os.path.abspath(__file__))}/config.yaml')
+    host_path = test_setup.test_config['test_params']['host_path']
+    imc_path = test_setup.test_config['test_params']['imc_path']
+    acc_path = test_setup.test_config['test_params']['acc_path']
+    ip_list = test_setup.test_config['test_params']['ip_list']
+    imc_ip = test_setup.test_config['imc']['ssh']['ip']
+    acc_ip = test_setup.test_config['acc']['ssh']['ip']
     acc_p4_path = f'{acc_path}/fxp-net_linux-networking'
-    lp_interfaces = test_config['host']['lp_interfaces']
-    lp_interface_ip = test_config['host']['lp_interface_ip']
-    host_password = test_config['host']['ssh']['password']
+    lp_interfaces = test_setup.test_config['host']['lp_interfaces']
+    lp_interface_ip = test_setup.test_config['host']['lp_interface_ip']
+    host_password = test_setup.test_config['host']['ssh']['password']
     imc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
     acc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
 
@@ -583,13 +595,13 @@ if __name__ == "__main__":
     if args.command == 'create_script':
 
         print("\n----------------Create OVS OFFLOAD scripts----------------")
-        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list,host_idpf_intf=idpf_interface, path=host_path)
+        build_p4rt_config(test_setup = test_setup)
 
     elif args.command == 'copy_script':
         print("\n----------------Create OVS OFFLOAD scripts----------------")
-        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list,host_idpf_intf=idpf_interface, path=host_path)
+        build_p4rt_config(test_setup = test_setup)
         print("\n----------------Copy OVS OFFLOAD scripts to the ACC----------------")
-        copy_scripts(host_path = host_path, imc_path = imc_path , acc_path = acc_path)
+        test_setup.copy_scripts()
 
     elif args.command == 'setup':
 
@@ -601,7 +613,7 @@ if __name__ == "__main__":
 
         # Setup a TMUX session, Login to ACC and start infrap4d
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        infrap4d = tmux_term(tmux_name="test1_infrap4d",tmux_override=True)
+        infrap4d = tmux_term(test_setup=test_setup, tmux_name="test1_infrap4d",tmux_override=True)
         result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
         result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
 
@@ -617,7 +629,7 @@ if __name__ == "__main__":
 
         # Setup a TMUX session, Login to ACC, configure p4rt rules and ovs bridges
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        p4rt = tmux_term(tmux_name="test2_p4rt",tmux_override=True)
+        p4rt = tmux_term(test_setup=test_setup, tmux_name="test2_p4rt",tmux_override=True)
         result = p4rt.tmux_send_keys(imc_login, delay=2)
         result = p4rt.tmux_send_keys(acc_login, delay=2)
         result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
@@ -638,7 +650,7 @@ if __name__ == "__main__":
 
         # Setup a TMUX session for the IPU host, configure the VMs, idpf interfaces, Link partner interfaces and run ping checks
         print("\n----------------Setup TMUX Session and Login to the Host----------------")
-        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        host = tmux_term(test_setup=test_setup, tmux_name="test3_host",tmux_override=True)
         result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
         result = host.tmux_send_keys('sudo -s', delay=2, output=True)
         result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
@@ -670,7 +682,7 @@ if __name__ == "__main__":
         print("\n----------------Teardown Linux Networking with OVS OFFLOAD----------------")
 
         print("\n----------------Setup TMUX Session and Login to the Host----------------")
-        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        host = tmux_term(test_setup=test_setup, tmux_name="test3_host",tmux_override=True)
         result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
         result = host.tmux_send_keys('sudo -s', delay=2, output=True)
         result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
@@ -695,7 +707,7 @@ ip netns del VM7
         print(result)
 
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        p4rt = tmux_term(tmux_name="test2_p4rt",tmux_override=True)
+        p4rt = tmux_term(test_setup=test_setup, tmux_name="test2_p4rt",tmux_override=True)
         result = p4rt.tmux_send_keys(imc_login, delay=2)
         result = p4rt.tmux_send_keys(acc_login, delay=2)
         result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
@@ -742,7 +754,7 @@ ovs-vsctl show
         print(result)
 
         print("\n----------------Stop Infrap4d on the ACC----------------")
-        infrap4d = tmux_term(tmux_name="test1_infrap4d",tmux_override=True)
+        infrap4d = tmux_term(test_setup=test_setup, tmux_name="test1_infrap4d",tmux_override=True)
         result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
         result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
         result = infrap4d.tmux_send_keys('ps -aux | grep infrap4d', delay=2, output=True)
diff --git a/ovs_offload/ovs_offload_lnw_v3.py b/ovs_offload/ovs_offload_lnw_v3.py
index b93a939..b120b00 100755
--- a/ovs_offload/ovs_offload_lnw_v3.py
+++ b/ovs_offload/ovs_offload_lnw_v3.py
@@ -6,9 +6,23 @@
 # Python tool to setup Linux Networking with OVS Offload on Intel速 Infrastructure Processing Unit (Intel速 IPU)
 
 import sys,argparse
+import os
+
+# Add the parent directory to the system path
+sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
 from common.utils import *
 
-def build_p4rt_config(vf_list=[], acc_pr_list=[],vm_ip_list=[], host_idpf_intf='', path=''):
+def build_p4rt_config(test_setup = None):
+
+    if test_setup == None:
+        print("Unable to parse the config.yaml to generate test configuration")
+        sys.exit()
+
+    host_idpf_intf= test_setup.test_config['test_params']['idpf_interface']
+    vf_list = test_setup.test_config['test_params']['vf_interfaces']
+    acc_pr_list = test_setup.test_config['test_params']['acc_pr_interfaces']
+    vm_ip_list = test_setup.test_config['test_params']['ip_list']
+    path = test_setup.test_config['test_params']['host_path']
 
     print("---------- Generating Configs to run infrap4d, p4rt and OVS ----------")
 
@@ -47,7 +61,7 @@ EOF
 
     for command in host_command_list:
         try:
-            result = ssh_command('host', command)
+            result = test_setup.ssh_command('host', command)
         except Exception as e:
             print(f"Failed with exception:\n{e}")
     time.sleep(5)
@@ -57,10 +71,10 @@ EOF
     phy_to_acc = ''
     vf_to_vm = ''
     ovs_vxlan = ''
-    local_vtep = test_config['test_params']['local_vtep']
-    remote_vtep = test_config['test_params']['remote_vtep']
-    local_br_tun = test_config['test_params']['local_br_tun_ip']
-    remote_br_tun = test_config['test_params']['remote_br_tun_ip']
+    local_vtep = test_setup.test_config['test_params']['local_vtep']
+    remote_vtep = test_setup.test_config['test_params']['remote_vtep']
+    local_br_tun = test_setup.test_config['test_params']['local_br_tun_ip']
+    remote_br_tun = test_setup.test_config['test_params']['remote_br_tun_ip']
     vm_id = 0
     command_list = []
     cmd = f"mkdir -p {path}"
@@ -70,7 +84,7 @@ EOF
         if str(vf_list[i]) == '0' or str(vf_list[i]) == '1':
         #Physical port   VSI_ID  PORT             ACC port representer  VSI_ID    PORT
         #Phy port 0      (0x0)    0     <---->    enp0s1f0d10         (0x11) 17   33
-            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            acc_pr = test_setup.get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
             phy_to_acc += f"""echo ""
 echo "IPU Physical Port {vf_list[i]} maps to "
 echo "ACC IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
@@ -91,8 +105,8 @@ ovs-vsctl add-port br-tun-{vf_list[i]} {acc_pr_list[i]}
 
 """
         else:
-            vf = get_interface_info(server_name='host', interface_name=vf_list[i])
-            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            vf = test_setup.get_interface_info(server_name='host', interface_name=vf_list[i])
+            acc_pr = test_setup.get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
             vf_to_acc += f"""echo ""
 echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']})  PORT ({vf['port']}) maps to"
 echo "ACC  IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
@@ -147,7 +161,7 @@ p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.la
 p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=7/7,priority=1,action=linux_networking_control.bypass"
 """
 
-    acc_path = test_config['test_params']['acc_path']
+    acc_path = test_setup.test_config['test_params']['acc_path']
     acc_p4_path = f'{acc_path}/fxp-net_linux-networking-v3'
     file = f'{path}/es2k_skip_p4.conf'
     p4_config = 'cat <<EOF > ./'+file+'''
@@ -536,7 +550,7 @@ EOF
 
     for command in command_list:
         try:
-            result = ssh_command('host', command)
+            result = test_setup.ssh_command('host', command)
         except Exception as e:
             print(f"Failed with exception:\n{e}")
 
@@ -559,19 +573,17 @@ def build_args():
 
 
 if __name__ == "__main__":
-    host_path = test_config['test_params']['host_path']
-    imc_path = test_config['test_params']['imc_path']
-    acc_path = test_config['test_params']['acc_path']
-    idpf_interface = test_config['test_params']['idpf_interface']
-    vf_interfaces = test_config['test_params']['vf_interfaces']
-    acc_pr_interfaces = test_config['test_params']['acc_pr_interfaces']
-    ip_list=test_config['test_params']['ip_list']
-    imc_ip = test_config['imc']['ssh']['ip']
-    acc_ip = test_config['acc']['ssh']['ip']
+    test_setup = TestSetup(config_file = f'{os.path.dirname(os.path.abspath(__file__))}/config.yaml')
+    host_path = test_setup.test_config['test_params']['host_path']
+    imc_path = test_setup.test_config['test_params']['imc_path']
+    acc_path = test_setup.test_config['test_params']['acc_path']
+    ip_list = test_setup.test_config['test_params']['ip_list']
+    imc_ip = test_setup.test_config['imc']['ssh']['ip']
+    acc_ip = test_setup.test_config['acc']['ssh']['ip']
     acc_p4_path = f'{acc_path}/fxp-net_linux-networking'
-    lp_interfaces = test_config['host']['lp_interfaces']
-    lp_interface_ip = test_config['host']['lp_interface_ip']
-    host_password = test_config['host']['ssh']['password']
+    lp_interfaces = test_setup.test_config['host']['lp_interfaces']
+    lp_interface_ip = test_setup.test_config['host']['lp_interface_ip']
+    host_password = test_setup.test_config['host']['ssh']['password']
     imc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
     acc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
 
@@ -583,13 +595,13 @@ if __name__ == "__main__":
     if args.command == 'create_script':
 
         print("\n----------------Create OVS OFFLOAD scripts----------------")
-        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list,host_idpf_intf=idpf_interface, path=host_path)
+        build_p4rt_config(test_setup = test_setup)
 
     elif args.command == 'copy_script':
         print("\n----------------Create OVS OFFLOAD scripts----------------")
-        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list,host_idpf_intf=idpf_interface, path=host_path)
+        build_p4rt_config(test_setup = test_setup)
         print("\n----------------Copy OVS OFFLOAD scripts to the ACC----------------")
-        copy_scripts(host_path = host_path, imc_path = imc_path , acc_path = acc_path)
+        test_setup.copy_scripts()
 
     elif args.command == 'setup':
 
@@ -601,7 +613,7 @@ if __name__ == "__main__":
 
         # Setup a TMUX session, Login to ACC and start infrap4d
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        infrap4d = tmux_term(tmux_name="test1_infrap4d",tmux_override=True)
+        infrap4d = tmux_term(test_setup=test_setup, tmux_name="test1_infrap4d",tmux_override=True)
         result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
         result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
 
@@ -617,7 +629,7 @@ if __name__ == "__main__":
 
         # Setup a TMUX session, Login to ACC, configure p4rt rules and ovs bridges
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        p4rt = tmux_term(tmux_name="test2_p4rt",tmux_override=True)
+        p4rt = tmux_term(test_setup=test_setup, tmux_name="test2_p4rt",tmux_override=True)
         result = p4rt.tmux_send_keys(imc_login, delay=2)
         result = p4rt.tmux_send_keys(acc_login, delay=2)
         result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
@@ -638,7 +650,7 @@ if __name__ == "__main__":
 
         # Setup a TMUX session for the IPU host, configure the VMs, idpf interfaces, Link partner interfaces and run ping checks
         print("\n----------------Setup TMUX Session and Login to the Host----------------")
-        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        host = tmux_term(test_setup=test_setup, tmux_name="test3_host",tmux_override=True)
         result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
         result = host.tmux_send_keys('sudo -s', delay=2, output=True)
         result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
@@ -670,7 +682,7 @@ if __name__ == "__main__":
         print("\n----------------Teardown Linux Networking with OVS OFFLOAD----------------")
 
         print("\n----------------Setup TMUX Session and Login to the Host----------------")
-        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        host = tmux_term(test_setup=test_setup, tmux_name="test3_host",tmux_override=True)
         result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
         result = host.tmux_send_keys('sudo -s', delay=2, output=True)
         result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
@@ -695,7 +707,7 @@ ip netns del VM7
         print(result)
 
         print("\n----------------Setup TMUX Session, Login to ACC----------------")
-        p4rt = tmux_term(tmux_name="test2_p4rt",tmux_override=True)
+        p4rt = tmux_term(test_setup=test_setup, tmux_name="test2_p4rt",tmux_override=True)
         result = p4rt.tmux_send_keys(imc_login, delay=2)
         result = p4rt.tmux_send_keys(acc_login, delay=2)
         result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
@@ -742,7 +754,7 @@ ovs-vsctl show
         print(result)
 
         print("\n----------------Stop Infrap4d on the ACC----------------")
-        infrap4d = tmux_term(tmux_name="test1_infrap4d",tmux_override=True)
+        infrap4d = tmux_term(test_setup=test_setup, tmux_name="test1_infrap4d",tmux_override=True)
         result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
         result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
         result = infrap4d.tmux_send_keys('ps -aux | grep infrap4d', delay=2, output=True)
diff --git a/ovs_offload/requirements.txt b/ovs_offload/requirements.txt
deleted file mode 100644
index 5500f00..0000000
--- a/ovs_offload/requirements.txt
+++ /dev/null
@@ -1 +0,0 @@
-PyYAML
diff --git a/ipsec_accel/requirements.txt b/requirements.txt
similarity index 100%
rename from ipsec_accel/requirements.txt
rename to requirements.txt

commit c60c1b421c898c19e9353a10ceb64dd52b18d7fe
Author: Sai Pracheetha Beeyam <sai.pracheetha.beeyam@intel.com>
Date:   Wed Oct 30 18:42:58 2024 +0000

    IPDK IPsec acceleration/offload scripts

diff --git a/ipsec_accel/README.md b/ipsec_accel/README.md
new file mode 100644
index 0000000..53b818c
--- /dev/null
+++ b/ipsec_accel/README.md
@@ -0,0 +1,745 @@
+# IPsec Acceleration Scripts
+
+## Introduction
+
+- The ipsec_accel.py script can be used on an host server connected with Intel速 Infrastructure Processing Unit via PCIe.
+- It creates the configuration to run the Linux Networking Recipe with IPsec Acceleration.
+- It can be used to start infrap4d on the ACC and use the script generated p4rt-ctl rules to configure ACC Port representors for the Host IDPF interfaces and IPU Physical Ports.
+- It can set up OVS bridges on the ACC using the port representors and configure the IDPF and VF interfaces on the Host.
+- It can setup IPsec tunnel/transport mode.
+- The steps menitoned here are for MEV back to back connected setup. Follow these steps in both hosts.
+
+## Test Environment Setup
+
+Before running the script, make sure `/etc/ssh/ssd_config` contains the line.
+
+```bash
+PermitRootLogin yes
+```
+
+### Prerequisites
+
+- The host package `intel-ipu-host-components-<version>.<build number>.tar.gz` contains the example IPU P4 source code, the compiled P4 package, and artifacts that can be used to set up the workload on the IMC and ACC.
+- The compiled artifacts for P4 `fxp-net_linux-networking` can be found in the location below after you extract the tar package.
+
+```bash
+cd intel-ipu-host-components/P4Tools/P4Programs/artifacts/fxp-net_linux-networking
+
+> ls
+total 6.2M
+-rw-r--r--. 1 admin12 admin12 1.5M Aug 30 10:47 fxp-net_linux-networking_3de1c1f569bb44d69043c2fb3093d079.pkgo
+-rw-r--r--. 1 admin12 admin12  46K Sep  3 11:29 p4Info.txt
+-rw-r--r--. 1 admin12 admin12 1.4K Sep  3 11:29 entries.json
+-rw-r--r--. 1 admin12 admin12 128K Sep  3 11:29 tdi.json
+-rw-r--r--. 1 admin12 admin12 639K Sep  3 11:32 context.json
+-rw-r--r--. 1 admin12 admin12 949K Sep  3 11:32 fxp-net_linux-networking.s
+-rw-r--r--. 1 admin12 admin12 1.5M Sep  3 11:32 fxp-net_linux-networking_12d1caf7e380490b96f1df444b5050af.pkgo
+-rw-r--r--. 1 admin12 admin12 1.5M Sep  3 11:32 fxp-net_linux-networking.pkg
+
+```
+
+- Load the P4 package `fxp-net_linux-networking.pkg` on the IMC. Refer section 'Load the P4 pacakge` in `IPDK IPsec (tunnel/transport mode) with strongSwan running on the Host` in `Crytographic Features` in the Intel速 Infrastructure Processing Unit Software User Guide. Additionally on Host 2 need to change MAC in node policy config file. Add the following line in load_custom_pkg.sh after the sed commands in Host 2. 
+
+```bash
+On Host 2
+
+sed -i 's/00:00:00:00:03:14/00:00:00:00:22:01/g' $CP_INIT_CFG
+
+Reboot the IMC
+
+```
+
+- Copy the P4 artifacts folder for the specific release version being tested to the IMC and then to the ACC location `/opt/fxp-net_linux-networking`.
+- Make sure the same version of IDPF driver is loaded on the Host, IMC and ACC, run commands below as a root user
+
+```bash
+sudo -i
+modprobe idpf
+lsmod | grep idpf
+modinfo idpf
+echo 8 > /sys/class/net/ens5f0/device/sriov_numvfs
+```
+
+- Replace `ens5f0` above with the correct Host IDPF Interface to create 8 SR-IOV VFs on the Host.
+- Build strongSwan on host. Follow the instructions in section `strongSwan Build on Host` in `IPDK IPsec (tunnel/transport mode) with strongSwan running on the Host` in `Crytographic Features` in the Intel速 Infrastructure Processing Unit Software User Guide.
+- The tool uses tmux sessions when running the option setup and option teardown.
+- Install TMUX on the IPU Host.
+
+```bash
+Ubuntu/Debian.
+sudo apt-get update && sudo apt-get -y install tmux
+
+Redhat/CentOS and other RHEL Distros.
+sudo yum install update && sudo yum -y install tmux
+
+Check after installing.
+# tmux --help
+usage: tmux [-2CDlNuvV] [-c shell-command] [-f file] [-L socket-name]
+            [-S socket-path] [-T features] [command [flags]]
+```
+
+### Test Topology
+![Topology](https://github.com/user-attachments/assets/2a568b9a-93f0-4b4b-b672-644f6bb52d1f)
+
+### Test Configuration (config.yaml)
+
+- The following configurations can be run in MEV back to back connected setup.
+- There are two config yaml files : config_host1.yaml and config_host2.yaml. On host 1 rename config_host1.yaml to config.yaml. On host 2 rename config_host2.yaml to config.yaml. Update the file config.yaml for the specific test setup. Change the management IP, username, and password for imc and acc if they are different.
+- Update the test_params section as required for the setup with the correct host, imc and acc script paths.
+- Update the idpf_interface, vf_interfaces, local_vxlan_tunnel_mac, remote_vxlan_ip, remote_vxlan_mac on both hosts configs.
+- comm_ip_host, comm_ip_acc are the IPs configured on host and ACC respectively for establishing communication channel between them.
+- local_vxlan_tunnel_mac is the MAC of V0 interface based on the config_host1.yaml.
+- remote_vxlan_ip is the IP on remote host. In this example it is 192.168.1.102.
+- remote_vxlan_mac is the MAC of V0 interface on remote host based on the config_host2.yaml 
+ 
+
+```bash
+> cd ipsec_accel
+```
+
+```bash
+> cat config.yaml
+host:
+  ssh:
+    ip: 10.232.27.15
+    username: admin12
+    # Update the login password for the IPU Host
+    password: "password"
+
+imc:
+  ssh:
+    ip: 100.0.0.100
+    username: root
+    password: ""
+
+acc:
+# SSH to ACC from the IMC
+  ssh:
+    ip: 192.168.0.2
+    username: root
+    password: ""
+
+test_params:
+    #path fields specify the location where the configuration scripts will be copied to on the Host,IMC and ACC
+    host_path: 'ipsec_accel_scripts'
+    imc_path: '/mnt/imc/p4_test'
+    acc_path:  '/opt/'
+    # Update the correct IDPF Interface on the Host
+    idpf_interface: 'ens5f0'
+    # IPs for communication channel between host and ACC
+    comm_ip_host: '10.10.0.1'
+    comm_ip_acc: '10.10.0.2'
+    # Update the list of Host IDPF Interfaces on the Host to Map to ACC Port representors
+    # Interfaces ['0','1'] below represents the IPU Physical Port 0 and Port 1 and the remaining as the Host IDPF Vfs
+    vf_interfaces: ['0','ens5f0v0','ens5f0v1']
+    # These are the ACC Port representors that will be used to map to the interfaces in the above list vf_interfaces. The last PR will be for IPsec application.
+    acc_pr_interfaces:  ['enp0s1f0d4','enp0s1f0d5','enp0s1f0d6']
+    # The ip_list contains the IP addresses that will be used for the Host IDPF VF interfaces that are mapped to the VM config (using: ip netns). The last IP is for IPsec application
+    ip_list: ['192.168.1.101','11.0.0.1']
+    # Host VF MAC and remote LP MAC
+    local_vxlan_tunnel_mac: ['00:1a:00:00:03:14']
+    # Remote vxlan IP
+    remote_vxlan_ip: ['192.168.1.102']
+    remote_vxlan_mac: ['00:1a:00:00:22:01']
+    # User Input for OVS VXLAN Config.
+    # Local and remote vtep(virtual tunnel end-point) IPs are used in OVS vxlan config with ACC PRs mapped to host IDPF VF
+    local_vtep: ['10.1.1.1']
+    remote_vtep: ['10.1.1.2']
+    # Tunnel Termination Bridge IP for local and remote peer.
+    local_br_tun_ip: ['1.1.1.1']
+    remote_br_tun_ip: ['1.1.1.2']
+    #Directory where strongswan is built on the host
+    strongSwan_build: '/home/admin12/ipsec/ipsec_combined_sep16/ipsec-recipe/'
+    #Host 1 or Host 2
+    ipsec_host: '1'
+```
+
+## Python Environment Setup
+
+Use python venv:
+
+```bash
+cd ipsec_accel/
+python -m venv --copies venv
+```
+
+Activate the venv and install requirements:
+
+```bash
+# source venv/bin/activate
+(venv)# pip install -r requirements.txt
+(venv)# deactivate
+```
+
+### requirements.txt
+
+```text
+PyYAML
+```
+
+Run python script **ipsec_accel.py** as a root user.
+
+```bash
+sudo -i
+cd ipdk/ipsec_accel
+source venv/bin/activate
+```
+
+## Test Script
+
+### ipsec_accel.py : (P4:fxp-net_linux-networking.p4, IPU SDK Release >= 1.8.0)
+
+1. This is a python script : **ipsec_accel/ipsec_accel.py** that can be used with **P4: fxp-net_linux-networking.p4** for release 1.7.0 and later
+
+    ```bash
+    > python ipsec_accel.py
+    usage: ipsec_accel.py [-h] {create_script,copy_script,setup,ipsec_transport,ipsec_tunnel,teardown} ...
+
+    Run Linux networking with IPsec Acceleration
+
+    positional arguments:
+       {create_script,copy_script,setup,ipsec_transport,ipsec_tunnel,teardown}
+                           options
+       create_script       Generate configuration scripts in localhost
+       copy_script         Copy configuration scripts to IMC and ACC
+       setup               Setup the complete OVS offload Recipe, prerequisite: run copy_script option once for scripts to be available in ACC
+       ipsec_transport     Setup the IPsec configs for transport mode, prerequisite: run copy_script option once for scripts to be available in Host
+       ipsec_tunnel        Setup the IPsec configs for tunnel mode, prerequisite: run copy_script option once for scripts to be available in Host & ACC
+       teardown            Teardown the IPsec Acceleration Recipe, prerequisite: run copy_script option once for scripts to be available in ACC
+
+    optional arguments:
+      -h, --help            show this help message and exit
+
+    ```
+
+2. create_script: This will create the configuration scripts in the script directory (the path can be changed in **host_path** in **config.yaml**) at **ipsec_accel/ipsec_accel_scripts/**
+
+    ```bash
+    > python ipsec_accel.py create_script
+    ```
+
+    The scripts will be created as shown below.
+
+    ```bash
+    > ls ipsec_accel/ipsec_accel_scripts/
+    total 96
+    -rwxr-xr-x 1 admin12 admin12 1806 Oct 28 23:19 es2k_skip_p4.conf
+    -rwxr-xr-x 1 admin12 admin12  417 Oct 28 23:19 1_host_idpf.sh
+    -rwxr-xr-x 1 admin12 admin12  189 Oct 28 23:19 setup_host_comm_channel.sh
+    -rwxr-xr-x 1 admin12 admin12  219 Oct 28 23:19 setup_acc_comm_channel.sh
+    -rwxr-xr-x 1 admin12 admin12  460 Oct 28 23:19 sync_host_acc_date.sh
+    -rwxr-xr-x 1 admin12 admin12  153 Oct 28 23:19 generate_certs.sh
+    -rwxr-xr-x 1 admin12 admin12  271 Oct 28 23:19 copy_certs.sh
+    -rwxr-xr-x 1 admin12 admin12 1166 Oct 28 23:19 2_acc_infrap4d.sh
+    -rwxr-xr-x 1 admin12 admin12 5362 Oct 28 23:19 3_acc_p4rt.sh
+    -rwxr-xr-x 1 admin12 admin12 3709 Oct 28 23:19 acc_p4rt_delete.sh
+    -rwxr-xr-x 1 admin12 admin12  592 Oct 28 23:19 4_acc_p4rt_dump.sh
+    -rwxr-xr-x 1 admin12 admin12 1288 Oct 28 23:19 5_acc_setup_ovs.sh
+    -rwxr-xr-x 1 admin12 admin12 1100 Oct 28 23:19 6_acc_ovs_bridge.sh
+    -rwxr-xr-x 1 root    root     502 Oct 28 23:19 proxy.sh
+    -rwxr-xr-x 1 admin12 admin12  942 Oct 28 23:19 host_ipsec_config.sh
+    -rwxr-xr-x 1 admin12 admin12  484 Oct 28 23:19 ipsec.conf_transport_1
+    -rwxr-xr-x 1 admin12 admin12  647 Oct 28 23:19 ipsec.conf_tunnel_1
+    -rwxr-xr-x 1 admin12 admin12  482 Oct 28 23:19 ipsec.conf_transport_2
+    -rwxr-xr-x 1 root    root     645 Oct 28 23:19 ipsec.conf_tunnel_2
+    -rwxr-xr-x 1 admin12 admin12 1892 Oct 28 23:19 ipsec_tunnel_config.sh
+    -rwxr-xr-x 1 admin12 admin12   67 Oct 28 23:19 ipsec.secrets
+    -rwxr-xr-x 1 admin12 admin12 1421 Oct 28 23:19 acc_ovs_vxlan.sh
+    -rwxr-xr-x 1 admin12 admin12  204 Oct 28 23:19 7_host_vm.sh
+    ```
+
+3. copy_script: This will create the configuration scripts in the script directory (the path can be changed in **host_path** in **config.yaml**) at **ipsec_accel/ipsec_accel_scripts** and also copy it to the ACC to the acc_path field provided in the **config file:config.yaml**
+
+    ```bash
+    > python ipsec_accel.py copy_script
+    ```
+
+4. setup:
+
+    ```bash
+    > python ipsec_accel.py setup
+    ```
+
+    - This will setup the OVS networking.
+    - Configure TMUX session - test_host_comm, configures host comm channel, sync date between host and ACC, copies certificates.
+    - Configure TMUX session - test_acc_comm, configures ACC comm channel, generates certifcates.
+    - Configure TMUX session - test_infrap4d, login to ACC and launch infrap4d,
+    - Configure TMUX session - test_p4rt configure the p4rt-ctl rules, configure OVS bridges
+    - Configure TMUX session - test3_host configure the VFs on Host IDPF interface.
+    - Run a ping test to check the forwarding.
+    - After running the setup option we can login to each of the tmux sessions.
+
+    > tmux ls
+    test_acc_comm
+    test_host_comm
+    test_infrap4d
+    test_p4rt
+    test3_host
+    
+    ```
+
+    Attach to a tmux session
+
+    ```bash
+    tmux a -t test_p4rt
+    ```
+
+    Detach from inside a tmux session.
+
+    ```bash
+    ctrl+b d
+    ```
+
+5. ipsec_tranport:
+
+    ```bash
+    > python ipsec_accel.py ipsec_transport
+    ```
+    - This will setup transport mode.
+    - Prerequisite: run create_script, copy_script and setup.
+    - Configures TMUX session - test_host_ipsec 
+    - Attach to this TMUX session : tmux a -t test_host_ipsec
+    - Execute './ipsec start' on both ends to establish IPsec Transport mode.
+    - Check for SADB counters in IMC : 'cli_client -qsS' and encrypted/decrypted counters increment.
+    - Execute './ipsec stop' to stop the IPsec session.
+
+
+6. ipsec_tunnel
+
+    ```bash
+    > python ipsec_accel.py ipsec_tunnel
+    ```
+    - This will setup tunnel mode.
+    - Prerequisite: run create_script, copy_script and setup.
+    - Configures TMUX session - test_host_ipsec
+    - Attach to this TMUX session : 'tmux a -t test_host_ipsec'
+    - Execute './ipsec start' on both ends to establish IPsec Tunnel mode.
+    - Check for SADB counters in IMC : 'cli_client -qsS' and encrypted/decrypted counters increment.
+    - Execute './ipsec stop' to stop the IPsec session.
+
+
+7. teardown:
+
+    ```bash
+    > python ipsec_accel.py teardown
+    ```
+
+    - This will tear down the complete OVS setup.
+    - Prerequisite: run copy_script option once for scripts to be available in ACC
+    - Configure TMUX session - test_p4rt delete the p4rt-ctl rules and delete the OVS bridges
+    - Configure TMUX session - test_infrap4d, login to ACC and stop infrap4d,
+
+
+
+
+
+
+## Use the Scripts on the Host and ACC to Setup IPsec Acceleration
+
+- Following needs to be done on both hosts
+- Follow the instructions below to run the recipe on the ACC with the help of configuration scripts which got genereated via create_script and copy_script or
+- Run the tool with setup followed by ipsec_transport/ipsec_tunnel option.
+
+```bash
+> python ipsec_accel.py setup
+> python ipsec_accel.py ipsec_tranpsort
+> python ipsec_accel.py ipsec_tunnel
+```
+
+### 1. IPU P4 Artifacts on ACC
+
+- The scripts expects the P4 artifacts to be available in the folder below in the ACC. Make sure to copy the correct artifacts for the release.
+
+```bash
+[root@ipu-acc ~]# ls /opt/fxp-net_linux-networking
+```
+
+
+### 2. Setup Host to ACC Communication Channel
+
+```bash
+
+On Host
+host# cd ipsec_accel/ipsec_accel_scripts
+host# ./setup_host_comm_channel.sh
+```
+
+
+```bash
+
+On ACC
+
+acc# cd /opt/ipsec_accel_scripts/
+acc# ./setup_acc_comm_channel.sh
+```
+
+### 3. Sync date between Host and ACC
+
+```bash
+
+On Host
+
+host# ipsec_accel/ipsec_accel_scripts
+host# ./sync_host_acc_date.sh
+
+```
+
+
+### 4. Generate certificates in ACC
+
+
+```bash
+
+On ACC
+
+acc# cd /opt/ipsec_accel_scripts/
+acc# ./generate_certs.sh
+
+```
+ 
+
+### 5. Copy certificates to Host
+
+```bash
+
+On Host
+
+host# ipsec_accel/ipsec_accel_scripts
+host# ./copy_certs.sh
+
+```
+
+
+### 6. Infrap4d Configuration file
+
+Copy the infrap4d config in **/opt/ipsec_accel_scripts/es2k_skip_p4.conf** to artifact folder **/opt/fxp-net_linux-networking** in the ACC
+
+```bash
+
+On ACC
+acc# cp /opt/ipsec_accel_scripts/es2k_skip_p4.conf /opt/fxp-net_linux-networking/
+```
+
+### 7. Start Infrap4d
+
+- Use the ipsec_accel_scripts in the ACC to set up infrap4d, p4rt and OVS bridge:
+
+```bash
+acc# cd /opt/ipsec_accel_scripts
+
+acc# ./2_acc_infrap4d.sh
+```
+
+Wait 30 seconds for infrap4d to initialize and start listening on the server.
+
+
+### 8. Configure P4 pipeline and add the ACC PR rules
+
+
+```bash
+acc# cd /opt/ipsec_accel_scripts
+
+acc# ./3_acc_p4rt.sh
+```
+
+
+```bash
+acc# cd /opt/ipsec_accel_scripts
+
+acc# ./4_acc_p4rt_dump.sh
+```
+
+### 9. Set up ACC environment for OVS
+
+
+```bash
+acc# cd /opt/ipsec_accel_scripts
+
+acc# ./5_acc_setup_ovs.sh
+```
+
+### 10. Set up OVS Bridge Configuration
+
+
+```bash
+acc# cd /opt/ipsec_accel_scripts
+
+acc# ./acc_ovs_vxlan.sh
+```
+
+### 11. Set up VF interfaces configuration on the IPU Host 
+
+
+```bash
+host]# cd ipsec_accel/ipsec_accel_scripts
+host]# ./7_host_vm.sh
+```
+
+
+Run a Ping Test to Host 2
+
+```bash
+
+host# ip -br a
+lo               UNKNOWN        127.0.0.1/8 ::1/128
+eno8303          UP             10.232.27.15/23 fe80::c6cb:e1ff:fea7:3c9c/64
+eno8403          UP             100.0.0.1/24
+ens7f0           DOWN
+ens7f1           DOWN
+docker0          DOWN           172.17.0.1/16
+ens5f0           UP
+ens5f0d1         UP
+ens5f0d2         UP             10.10.0.1/24
+ens5f0d3         UP
+ens5f0v0         UP             192.168.1.101/24
+ens5f0v1         UP             11.0.0.1/24
+ens5f0v2         UP
+ens5f0v7         UP
+ens5f0v6         UP
+ens5f0v5         UP
+ens5f0v3         UP
+ens5f0v4         UP
+
+host# ping 192.168.1.102
+PING 192.168.1.102 (192.168.1.102) 56(84) bytes of data.
+64 bytes from 192.168.1.102: icmp_seq=1 ttl=64 time=1107 ms
+64 bytes from 192.168.1.102: icmp_seq=2 ttl=64 time=107 ms
+64 bytes from 192.168.1.102: icmp_seq=3 ttl=64 time=0.344 ms
+64 bytes from 192.168.1.102: icmp_seq=4 ttl=64 time=0.317 ms
+^C
+--- 192.168.1.102 ping statistics ---
+4 packets transmitted, 4 received, 0% packet loss, time 3048ms
+rtt min/avg/max/mdev = 0.317/303.674/1107.126/465.909 ms, pipe 2
+
+```
+
+
+### 11. Set up IPsec transport mode 
+
+```bash
+
+
+host# cd ipsec_accel/ipsec_accel_scripts/
+host# ./host_ipsec_config.sh
+host# source proxy.sh
+host# yes|cp -f ipsec.secrets {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/
+
+
+Host 1
+host1# yes|cp -f ipsec.conf_transport_1 {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/ipsec.conf
+
+
+Host 2
+host2# yes|cp -f ipsec.conf_transport_2 {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/ipsec.conf
+
+
+```
+
+In the same terminal as above execute ipsec application on both hosts.
+
+```bash
+
+host# cd {strongSwan_build}
+host# source env_setup_acc.sh
+
+host# cd {strongSwan_build}//ipsec_offload_plugin/output_strongswan/usr/sbin
+host# ./ipsec start
+
+```
+
+In the same terminal Check for IPsec status 
+
+```bash
+host# cd {strongSwan_build}//ipsec_offload_plugin/output_strongswan/usr/sbin
+host# ./ipsec status
+
+[root@Aurora sbin]# ./ipsec status
+Security Associations (1 up, 0 connecting):
+    sts-base[1]: ESTABLISHED 3 minutes ago, 192.168.1.101[192.168.1.101]...192.168.1.102[192.168.1.102]
+    sts-base{1}:  INSTALLED, TRANSPORT, reqid 1, ESP SPIs: 4f000001_i 93000001_o
+    sts-base{1}:   192.168.1.101/32[tcp] === 192.168.1.102/32[tcp]
+
+```
+
+Send traffic and check for SADB counters in IMC
+
+```bash
+
+Host 1
+
+host1# ssh admin12@192.168.1.102
+
+[root@Aurora sbin]# ssh admin12@192.168.1.102
+admin12@192.168.1.102's password:
+Activate the web console with: systemctl enable --now cockpit.socket
+
+Last login: Tue Oct 29 05:54:02 2024 from 192.168.1.101
+[admin12@Hestia ~]$
+
+
+IMC
+
+imc : cli_client -qsS
+
+
+[root@ipu-imc ~]# cli_client -qsS
+No IP address specified, defaulting to localhost
+ipsec rx dec packets: 16 bytes: 3221
+ipsec rx replay errors: 0
+ipsec rx auth failures: 0
+ipsec rx misc errors: 0
+ipsec rx bad pkts: 0
+ipsec tx enc packets: 18 bytes: 2825
+ipsec tx misc errors: 0
+ipsec tx bad pkts: 0
+cisp rx dec packets: 0 bytes: 0
+cisp rx auth failures: 0
+cisp rx misc errors: 0
+cisp rx bad pkts: 0
+cisp tx enc packets: 0 bytes: 0
+cisp tx misc errors: 0
+cisp tx bad pkts: 0
+
+
+```
+
+
+
+### 12. Set up IPsec tunnel mode
+
+
+```bash
+On ACC
+
+acc# cd /opt/ipsec_accel_scripts/
+acc# ./ipsec_tunnel_config.sh
+```
+
+
+```bash
+On Host
+
+host# cd ipsec_accel/ipsec_accel_scripts/
+host# ./host_ipsec_config.sh
+host# source proxy.sh
+host# yes|cp -f ipsec.secrets {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/
+
+
+Host 1
+host1# yes|cp -f ipsec.conf_tunnel_1 {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/ipsec.conf
+
+
+Host 2
+host2# yes|cp -f ipsec.conf_tunnel_2 {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/ipsec.conf
+
+
+```
+
+In the same terminal as above execute ipsec application on both hosts.
+
+```bash
+
+host# cd {strongSwan_build}
+host# source env_setup_acc.sh
+
+host# cd {strongSwan_build}//ipsec_offload_plugin/output_strongswan/usr/sbin
+host# ./ipsec start
+
+```
+
+In the same terminal check for IPsec status
+
+```bash
+host# cd {strongSwan_build}//ipsec_offload_plugin/output_strongswan/usr/sbin
+host# ./ipsec status
+
+[root@Aurora sbin]# ./ipsec status
+Security Associations (1 up, 0 connecting):
+    sts-base[1]: ESTABLISHED 37 seconds ago, 192.168.1.101[192.168.1.101]...192.168.1.102[192.168.1.102]
+    sts-base{1}:  INSTALLED, TUNNEL, reqid 1, ESP SPIs: 6d000001_i 5a000001_o
+    sts-base{1}:   11.0.0.1/32[tcp] === 11.0.0.2/32[tcp]
+(venv) [root@Aurora sbin]#
+
+
+```
+
+Send traffic and check for SADB counters in IMC
+
+```bash
+
+Host
+
+(venv) [root@Aurora sbin]# ssh admin12@11.0.0.2
+admin12@11.0.0.2's password:
+Activate the web console with: systemctl enable --now cockpit.socket
+
+Last login: Tue Oct 29 06:22:23 2024 from 11.0.0.1
+[admin12@Hestia ~]$ 
+
+
+IMC
+
+[root@ipu-imc ~]# cli_client -qsS
+No IP address specified, defaulting to localhost
+ipsec rx dec packets: 80 bytes: 12759
+ipsec rx replay errors: 0
+ipsec rx auth failures: 0
+ipsec rx misc errors: 0
+ipsec rx bad pkts: 0
+ipsec tx enc packets: 125 bytes: 12867
+ipsec tx misc errors: 2
+ipsec tx bad pkts: 0
+cisp rx dec packets: 0 bytes: 0
+cisp rx auth failures: 0
+cisp rx misc errors: 0
+cisp rx bad pkts: 0
+cisp tx enc packets: 0 bytes: 0
+cisp tx misc errors: 0
+cisp tx bad pkts: 0
+
+server finished responding =======================
+
+```
+
+
+Stop IPsec application
+
+```bash
+host# ./ipsec stop
+```
+### Optional:  Clean up the configs
+
+Run the tool with option **teardown**
+
+```bash
+> python ipsec_accel.py teardown
+```
+
+ACC Terminal  : Delete the OVS Bridge Config on the ACC
+
+```bash
+#!/bin/sh
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=$P4CP_INSTALL
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+ovs-vsctl show
+ovs-vsctl del-br br-int-0
+ovs-vsctl del-br br-tun-0
+
+ip link del TEP0
+ovs-vsctl del-br br0
+
+```
+
+ACC Terminal : Delete the p4rt-ctl runtime rules
+
+```bash
+acc# cd /opt/ipsec_accel_scripts
+
+acc# ./acc_p4rt_delete.sh
+
+acc# ./4_acc_p4rt_dump.sh
+```
diff --git a/ipsec_accel/common/utils.py b/ipsec_accel/common/utils.py
new file mode 100644
index 0000000..82ba811
--- /dev/null
+++ b/ipsec_accel/common/utils.py
@@ -0,0 +1,315 @@
+#!/usr/bin/python
+#
+# Copyright 2022-2024 Intel Corporation
+# SPDX-License-Identifier: Apache-2.0
+#
+# Common python APIs and utilities for Intel速 Infrastructure Processing Unit (Intel速 IPU)
+
+import subprocess, os, time, re
+import yaml
+
+def fetch_configurations(config_file=''):
+    with open(config_file, "r") as file:
+        config_data = yaml.safe_load(file)
+    return config_data
+
+#Fetch test configuration
+test_config = fetch_configurations(f'{os.path.dirname(os.path.abspath(__file__))}/../config.yaml')
+
+def run_cmd(cmd, output=False, check_returncode=True):
+    """
+    Execute a command in a subprocess.
+    :param cmd: The command to be executed as a string.
+    :param output: If True, capture and return the command's stdout.
+    :param check_returncode: If True, check the command's return code and raise an error if not 0.
+    :return: The stdout of the command if output is True, otherwise None.
+    """
+    print(f'Executing: {cmd}')
+    # Use a context manager to ensure the subprocess is cleaned up after execution
+    with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE if output else None, stderr=subprocess.PIPE, encoding="utf-8") as s:
+        outs, errs = s.communicate() if output else (None, None)
+        # Check the return code if required
+        if check_returncode and s.returncode != 0:
+            raise subprocess.CalledProcessError(s.returncode, cmd, output=outs, stderr=errs)
+        return outs.strip() if output else None
+
+def ssh_command(server_name, command, output=True, check_returncode=True):
+    """
+    Execute a command on a remote server via SSH.
+    :param server_name: The name of the server ('host', 'imc', or 'acc').
+    :param command: The command to be executed on the remote server.
+    :return: A dictionary with the return code and the command's output.
+    """
+    imc_ip = test_config['imc']['ssh']['ip']
+    acc_ip = test_config['acc']['ssh']['ip']
+    # SSH command templates
+    imc_access = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
+    acc_access = f'{imc_access} ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
+
+    # Determine the appropriate SSH command based on the server name
+    if server_name == 'host':
+        full_cmd = command
+    elif server_name == 'imc':
+        full_cmd = f'{imc_access} "{command}"'
+    elif server_name == 'acc':
+        full_cmd = f'{acc_access} "{command}"'
+    else:
+        raise ValueError(f"Unknown server name: {server_name}")
+
+    # Execute the command and capture the output
+    output = run_cmd(full_cmd, output = output, check_returncode = check_returncode)
+
+    # Return the result as a dictionary
+    return {'rc': 0, 'output': output}
+
+
+def copy_scripts(host_path='ovs_offload_lnw_scripts', imc_path = '/mnt/imc/p4_test', acc_path = '/opt/p4/p4sde/p4_test'):
+    """
+    Copies configuration scripts from the host to the IMC and then to the ACC.
+
+    :param host_path: Path to the configuration scripts on the host machine
+    :param imc_path: Destination path on the IMC
+    :param acc_path: Destination path on the ACC
+    """
+    imc_ip = test_config['imc']['ssh']['ip']
+    acc_ip = test_config['acc']['ssh']['ip']
+
+    command = f'mkdir -p {imc_path}'
+    try:
+        result = ssh_command('imc', command)
+    except Exception as e:
+        print(f"Failed with exception:\n{e}")
+
+    command = f'mkdir -p {acc_path}'
+    try:
+        result = ssh_command('acc', command)
+    except Exception as e:
+        print(f"Failed with exception:\n{e}")
+
+    # Copy the configuration scripts from host to IMC
+    command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {host_path}  root@{imc_ip}:{imc_path}/'
+    try:
+        result = ssh_command('host', command)
+    except Exception as e:
+        print(f"Failed with exception:\n{e}")
+
+    command = f'chmod +x {imc_path}/{host_path}/*'
+    try:
+        result = ssh_command('imc', command)
+    except Exception as e:
+        print(f"Failed with exception:\n{e}")
+
+    # Copy the configuration scripts from IMC to ACC
+    command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {imc_path}/{host_path} root@{acc_ip}:{acc_path}/'
+    try:
+        result = ssh_command('imc', command)
+    except Exception as e:
+        print(f"Failed with exception:\n{e}")
+
+    command = f'chmod +x {acc_path}/{host_path}/*'
+    try:
+        result = ssh_command('acc', command)
+    except Exception as e:
+        print(f"Failed with exception:\n{e}")
+
+
+def get_interface_info(server_name, interface_name):
+    """
+    Retrieve information about a network interface on a remote server.
+
+    :param server_name: The name of the server where the interface is located.
+    :param interface_name: The name of the network interface to query.
+    :return: A dictionary containing various pieces of information about the interface.
+    """
+    # Initialize an empty dictionary to store interface information
+    interface_info = {}
+
+    # Define a mapping of server names to host IDs
+    host_id = {
+        'host': '0x0',
+        'acc': '0x4',
+        'imc': '0x5'
+    }
+
+    # Command to get basic interface information using ifconfig
+    cmd = f"ifconfig {interface_name}"
+    try:
+        result = ssh_command(server_name, cmd)
+    except Exception as e:
+        logging.error(f"Failed to run ifconfig on '{interface_name}': {e}")
+        return interface_info
+
+    output = result['output']
+
+    # Regex patterns to extract IP, MAC, and other fields
+    ip_pattern = re.compile(r'inet (\d+\.\d+\.\d+\.\d+)')
+    mac_pattern = re.compile(r'ether ([0-9a-fA-F:]{17})')
+    mtu_pattern = re.compile(r'mtu (\d+)')
+
+    # Search for patterns in the output and populate the dictionary
+    interface_info['ip'] = ip_pattern.search(output).group(1) if ip_pattern.search(output) else None
+    interface_info['mac'] = mac_pattern.search(output).group(1) if mac_pattern.search(output) else None
+    interface_info['mtu'] = mtu_pattern.search(output).group(1) if mtu_pattern.search(output) else None
+
+    # Command to get detailed interface information using ethtool
+    cmd = f"ethtool -i {interface_name}"
+    try:
+        result = ssh_command(server_name, cmd)
+    except Exception as e:
+        logging.warning(f"Failed to run ethtool on '{interface_name}': {e}")
+        return interface_info
+
+    output = result['output']
+
+    # Parse ethtool output and add to the dictionary
+    for line in output.split('\n'):
+        field = line.split(': ')
+        if len(field) == 2:
+            interface_info[field[0].strip()] = field[1].strip()
+
+    # Check if the driver is not 'idpf' and return the info collected so far
+    if interface_info.get('driver') != 'idpf':
+        return interface_info
+
+    # Command to get additional interface information for 'idpf' interface from IMC
+    cmd = f"cli_client -q -c | grep 'host_id: {host_id[server_name]}' | grep '{interface_info['mac']}'"
+    try:
+        result = ssh_command('imc', cmd)
+    except Exception as e:
+        logging.warning(f"Failed to run cli_client on '{interface_name}': {e}")
+        return interface_info
+
+    output = result['output']
+
+    # Regex pattern to extract additional fields for 'idpf' driver
+    pattern = re.compile(r'fn_id:\s+(\w+)\s+host_id:\s+(\w+)\s+is_vf:\s+(\w+)\s+vsi_id:\s+(\w+)\s+vport_id\s+(\w+)\s+is_created:\s+(\w+)\s+is_enabled:\s+(\w+)\s+mac\s+addr:\s+([0-9a-fA-F:]{17})')
+    match = pattern.search(output)
+
+    # Populate the dictionary with additional information if available
+    if match:
+        interface_info.update({
+            'fn_id': match.group(1),
+            'host_id': match.group(2),
+            'is_vf': match.group(3),
+            'vsi_id': match.group(4),
+            'vport_id': match.group(5),
+            'is_created': match.group(6),
+            'is_enabled': match.group(7),
+            'mac_addr': match.group(8)
+        })
+
+        # Calculate additional fields based on 'vsi_id'
+        if interface_info['vsi_id']:
+            interface_info['vsi_num'] = str(int(interface_info['vsi_id'], 16))
+            port_offset = str(int(interface_info['vsi_id'], 16) + 16)
+            interface_info['port'] = port_offset
+
+    return interface_info
+
+
+def ping_test(dst_ip, count=4, vm = None):
+    if vm:
+        cmd = f"ip netns exec {vm} ping {dst_ip} -c {count}"
+    else:
+        cmd = f"ping {dst_ip} -c {count}"
+    try:
+        result = run_cmd(cmd, output=True)
+        pkt_loss = 100
+        if result:
+            match = re.search('(\d*)% packet loss', result)
+            if match:
+                pkt_loss = int(match.group(1))
+            if f"{count} received, 0% packet loss" in result:
+                print(f"PASS: Ping successful to destination {dst_ip}\n")
+                return True
+            else:
+                raise RuntimeError(f"FAIL: Ping Failed to destination {dst_ip} with" f" {pkt_loss}% loss\n")
+    except Exception as E:
+        print(f"Ping run failed with error:'{E}'\n")
+        return False
+
+
+
+def split_mac(mac_address):
+    # Split the MAC address by colons
+    octets = mac_address.split(":") 
+
+    # Join the first three octets and the last three octets
+    first_octet = "".join(octets[:2])
+    second_octet = "".join(octets[2:4])
+    third_octet = "".join(octets[4:])
+    
+    print("first octet {} second octet {} third octet {}".format(first_octet, second_octet, third_octet))
+    return first_octet, second_octet, third_octet
+
+def split_mac_2(mac_address):
+    # Split the MAC address by colons
+    octets = mac_address.split(":")
+
+    # Join the first three octets and the last three octets
+    first_split = "".join(octets[:2])
+    second_split = "".join(octets[2:])
+
+    return first_split, second_split
+
+def ip_dec_to_hex(ip_address):
+    octets = ip_address.split('.')
+    hex_octets = [f"{int(octet):02X}" for octet in octets]
+    return "".join(hex_octets)
+
+class tmux_term:
+    def __init__(self, tmux_name="", tmux_override=False):
+        # Initialize a new tmux terminal session
+        if not tmux_name:
+            raise ValueError("Error: No tmux name specified!")
+        self.tmux_name = tmux_name
+
+        # Check if the specified tmux session already exists
+        command = 'tmux ls'
+        try:
+            result = ssh_command('host', command, check_returncode=False)
+        except Exception as e:
+            raise Exception(f"Failed to list tmux sessions with exception:\n{e}")
+
+        # Parse the output to find an existing session
+        lines = result['output']
+        found = any(self.tmux_name in line for line in lines.split('\n'))
+
+        # If the session is found and override is allowed, kill the existing session
+        if found and tmux_override:
+            command = f'tmux kill-session -t {self.tmux_name}'
+            ssh_command('host', command)
+
+        # If the session was not found or was killed, create a new one
+        if not found or tmux_override:
+            command = f'tmux new-session -d -s {self.tmux_name}'
+            ssh_command('host', command)
+
+    def tmux_send_keys(self, cmd, delay=1, output=True):
+        # Send a command to the tmux session and optionally capture the output
+        time.sleep(0.5)  # Short delay before sending the command
+
+        if output:
+            # Set up piping to capture the output of the command
+            output_file = os.path.join(os.getcwd(), 'tmux_output.txt')
+            command = f'tmux pipe-pane -t {self.tmux_name} "cat > {output_file}"'
+            ssh_command('host', command)
+
+        # Send the actual command to the tmux session
+        command = f'tmux send-keys -t {self.tmux_name} "{cmd}" C-m'
+        ssh_command('host', command)
+
+        if output:
+            # Wait for the specified delay to allow the command to execute and output to be captured
+            if delay > 0:
+                time.sleep(delay)
+
+            # Stop piping the output
+            command = f'tmux pipe-pane -t {self.tmux_name}'
+            ssh_command('host', command)
+
+            # Read the captured output from the file
+            with open(output_file, "r") as f:
+                result = f.read()
+
+        return result
diff --git a/ipsec_accel/config_host1.yaml b/ipsec_accel/config_host1.yaml
new file mode 100644
index 0000000..8da4301
--- /dev/null
+++ b/ipsec_accel/config_host1.yaml
@@ -0,0 +1,54 @@
+host:
+  ssh:
+    ip: 10.232.27.15
+    username: admin12
+    # Update the login password for the IPU Host
+    password: "bfn123"
+
+imc:
+  ssh:
+    ip: 100.0.0.100
+    username: root
+    password: ""
+
+acc:
+# SSH to ACC from the IMC
+  ssh:
+    ip: 192.168.0.2
+    username: root
+    password: ""
+
+test_params:
+    #path fields specify the location where the configuration scripts will be copied to on the Host,IMC and ACC
+    host_path: 'ipsec_accel_scripts'
+    imc_path: '/mnt/imc/p4_test'
+    acc_path:  '/opt/'
+    # Update the correct IDPF Interface on the Host
+    idpf_interface: 'ens5f0'
+    # IPs for communication channel between host and ACC
+    comm_ip_host: '10.10.0.1'
+    comm_ip_acc: '10.10.0.2'
+    # Update the list of Host IDPF Interfaces on the Host to Map to ACC Port representors
+    # Interfaces ['0','1'] below represents the IPU Physical Port 0 and Port 1 and the remaining as the Host IDPF Vfs
+    vf_interfaces: ['0','ens5f0v0','ens5f0v1']
+    # These are the ACC Port representors that will be used to map to the interfaces in the above list vf_interfaces. The last PR will be for IPsec application.
+    acc_pr_interfaces:  ['enp0s1f0d4','enp0s1f0d5','enp0s1f0d6']
+    # The ip_list contains the IP addresses that will be used for the Host IDPF VF interfaces that are mapped to the VM config (using: ip netns). The last IP is for IPsec application
+    ip_list: ['192.168.1.101','11.0.0.1']
+    # Host VF MAC and remote LP MAC
+    local_vxlan_tunnel_mac: ['00:1a:00:00:03:14']
+    # Remote vxlan IP
+    remote_vxlan_ip: ['192.168.1.102']
+    # MAC of remote VF v0 interface
+    remote_vxlan_mac: ['00:1a:00:00:22:01'] 
+    # User Input for OVS VXLAN Config.
+    # Local and remote vtep(virtual tunnel end-point) IPs are used in OVS vxlan config with ACC PRs mapped to host IDPF VF
+    local_vtep: ['10.1.1.1']
+    remote_vtep: ['10.1.1.2']
+    # Tunnel Termination Bridge IP for local and remote peer.
+    local_br_tun_ip: ['1.1.1.1']
+    remote_br_tun_ip: ['1.1.1.2']
+    #Directory where strongswan is built on the host
+    strongSwan_build: '/home/admin12/ipsec/ipsec_combined_sep16/ipsec-recipe/'
+    #Host 1 or Host 2
+    ipsec_host: '1'
diff --git a/ipsec_accel/config_host2.yaml b/ipsec_accel/config_host2.yaml
new file mode 100644
index 0000000..acfe55f
--- /dev/null
+++ b/ipsec_accel/config_host2.yaml
@@ -0,0 +1,54 @@
+host:
+  ssh:
+    ip: 10.232.27.15
+    username: admin12
+    # Update the login password for the IPU Host
+    password: "bfn123"
+
+imc:
+  ssh:
+    ip: 100.0.0.100
+    username: root
+    password: ""
+
+acc:
+# SSH to ACC from the IMC
+  ssh:
+    ip: 192.168.0.2
+    username: root
+    password: ""
+
+test_params:
+    #path fields specify the location where the configuration scripts will be copied to on the Host,IMC and ACC
+    host_path: 'ipsec_accel_scripts'
+    imc_path: '/mnt/imc/p4_test'
+    acc_path:  '/opt/'
+    # Update the correct IDPF Interface on the Host
+    idpf_interface: 'ens4f0'
+    # IPs for communication channel between host and ACC
+    comm_ip_host: '10.10.0.1'
+    comm_ip_acc: '10.10.0.2'
+    # Update the list of Host IDPF Interfaces on the Host to Map to ACC Port representors
+    # Interfaces ['0','1'] below represents the IPU Physical Port 0 and Port 1 and the remaining as the Host IDPF Vfs
+    vf_interfaces: ['0','ens4f0v0','ens4f0v1']
+    # These are the ACC Port representors that will be used to map to the interfaces in the above list vf_interfaces. The last PR will be for IPsec application.
+    acc_pr_interfaces:  ['enp0s1f0d4','enp0s1f0d5','enp0s1f0d6']
+    # The ip_list contains the IP addresses that will be used for the Host IDPF VF interfaces that are mapped to the VM config (using: ip netns). The last IP is for IPsec application
+    ip_list: ['192.168.1.102','11.0.0.2']
+    # Host VF MAC. For example, Here it will be the MAC of ens4f0v0. 
+    local_vxlan_tunnel_mac: ['00:1a:00:00:22:01']
+    # Remote vxlan IP
+    remote_vxlan_ip: ['192.168.1.101']
+    # MAC of remote VF v0 interface
+    remote_vxlan_mac: ['00:1a:00:00:03:14'] 
+    # User Input for OVS VXLAN Config.
+    # Local and remote vtep(virtual tunnel end-point) IPs are used in OVS vxlan config with ACC PRs mapped to host IDPF VF
+    local_vtep: ['10.1.1.2']
+    remote_vtep: ['10.1.1.1']
+    # Tunnel Termination Bridge IP for local and remote peer.
+    local_br_tun_ip: ['1.1.1.2']
+    remote_br_tun_ip: ['1.1.1.1']
+    #Directory where strongswan is built on the host
+    strongSwan_build: '/home/admin12/ipsec/ipsec_combined_sep16/ipsec-recipe/'
+    #Host 1 or Host 2
+    ipsec_host: '2'
diff --git a/ipsec_accel/ipsec_accel.py b/ipsec_accel/ipsec_accel.py
new file mode 100755
index 0000000..8d196c0
--- /dev/null
+++ b/ipsec_accel/ipsec_accel.py
@@ -0,0 +1,1092 @@
+#!/usr/bin/python
+#
+# Copyright 2022-2024 Intel Corporation
+# SPDX-License-Identifier: Apache-2.0
+#
+# Python tool to setup Linux Networking with OVS Offload on Intel速 Infrastructure Processing Unit (Intel速 IPU)
+
+import sys,argparse
+from common.utils import *
+
+def build_p4rt_config(vf_list=[], acc_pr_list=[],vm_ip_list=[], host_idpf_intf='', path='', comm_ip_host='', comm_ip_acc='', ipsec_host=''):
+
+    print("---------- Generating Configs to run infrap4d, p4rt, OVS and IPsec ----------")
+
+    if len(vf_list) != len(acc_pr_list):
+        print("ERROR: number of vfs and ACC PRs should be the same")
+        return None
+
+    host_command_list = []
+    cmd = f"mkdir -p {path}"
+    host_command_list.append(cmd)
+
+    file = f'{path}/1_host_idpf.sh'
+    host_idpf = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+#Load the driver
+echo "Load the IDPF Driver on the Host"
+modprobe idpf
+sleep 4
+
+echo ""
+echo "Check the Interfaces are up"
+ip -br a
+
+echo ""
+echo "Check the Interfaces are up"
+ip -br a
+#Setup number of sriov devices on the IDPF interface
+echo "Create SRIOV VFs on IDPF interface '''+host_idpf_intf+'''"
+echo 8 > /sys/class/net/'''+host_idpf_intf+'''/device/sriov_numvfs
+
+echo ""
+echo "Wait for the interfaces to come up"
+sleep 5
+ip -br a
+
+EOF
+'''
+
+    host_command_list.append(host_idpf)
+    host_command_list.append(f"chmod +x ./{file}")
+    #host_command_list.append(f"./{file}")
+
+
+    file = f'{path}/setup_host_comm_channel.sh'
+    host_comm_channel = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo ""
+echo "Assign IP to IDPF_COMMS_VPORT_2 for host acc comm channel"
+
+nmcli device set '''+host_idpf_intf+'''d2 managed no
+ip addr add '''+comm_ip_host+'''/24 dev '''+host_idpf_intf+'''d2
+ip link set up dev '''+host_idpf_intf+'''d2
+
+EOF
+'''
+    host_command_list.append(host_comm_channel)
+    host_command_list.append(f"chmod +x ./{file}")
+
+
+
+    for command in host_command_list:
+        try:
+            result = ssh_command('host', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+    time.sleep(5)
+
+    mac_list = []
+    vf_to_acc = ''
+    phy_to_acc = ''
+    vf_to_vm = ''
+    ovs_vxlan = ''
+    local_vtep = test_config['test_params']['local_vtep']
+    remote_vtep = test_config['test_params']['remote_vtep']
+    local_br_tun = test_config['test_params']['local_br_tun_ip']
+    remote_br_tun = test_config['test_params']['remote_br_tun_ip']
+    comm_ip_acc: test_config['test_params']['comm_ip_acc']
+
+    vm_id = 0
+    command_list = []
+    cmd = f"mkdir -p {path}"
+    command_list.append(cmd)
+    vf_list_len = len(vf_list)
+    for i in range(vf_list_len):
+        print("vf list len {} i is {} vf_list is {}".format(vf_list_len, i, vf_list[i])) 
+        if str(vf_list[i]) == '0' or str(vf_list[i]) == '1':
+        #Physical port   VSI_ID  PORT             ACC port representer  VSI_ID    PORT
+        #Phy port 0      (0x0)    0     <---->    enp0s1f0d10         (0x11) 17   33
+            print(acc_pr_list[i])
+            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            phy_to_acc += f"""echo ""
+echo "IPU Physical Port {vf_list[i]} maps to "
+echo "ACC IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.rx_source_port "vmeta.common.port_id={vf_list[i]},zero_padding=0,action=linux_networking_control.set_source_port({vf_list[i]})"
+p4rt-ctl add-entry br0 linux_networking_control.rx_phy_port_to_pr_map "vmeta.common.port_id={vf_list[i]},zero_padding=0,action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.source_port_to_pr_map "user_meta.cmeta.source_port={vf_list[i]},zero_padding=0,action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.tx_acc_vsi "vmeta.common.vsi={acc_pr['vsi_num']},zero_padding=0,action=linux_networking_control.l2_fwd_and_bypass_bridge({vf_list[i]})"
+sleep 2
+
+"""
+
+            ovs_vxlan += f"""echo ""
+echo "IPU Port {vf_list[i]} mapped to ACC Port {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']}:{acc_pr['port']})"
+echo "ACC Port {acc_pr_list[i]} is added to OVS bridge br-tun-{vf_list[i]}"
+ovs-vsctl del-br br-tun-{vf_list[i]}
+ovs-vsctl add-br br-tun-{vf_list[i]}
+ovs-vsctl add-port br-tun-{vf_list[i]} {acc_pr_list[i]}
+"""
+        else:
+            vf = get_interface_info(server_name='host', interface_name=vf_list[i])
+            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            vf_to_acc += f"""echo ""
+echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']})  PORT ({vf['port']}) maps to"
+echo "ACC  IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.tx_source_port "vmeta.common.vsi={vf['vsi_num']}/2047,priority=1,action=linux_networking_control.set_source_port({vf['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.source_port_to_pr_map "user_meta.cmeta.source_port={vf['port']},zero_padding=0,action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.tx_acc_vsi "vmeta.common.vsi={acc_pr['vsi_num']},zero_padding=0,action=linux_networking_control.l2_fwd_and_bypass_bridge({vf['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.vsi_to_vsi_loopback "vmeta.common.vsi={acc_pr['vsi_num']},target_vsi={vf['vsi_num']},action=linux_networking_control.fwd_to_vsi({vf['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.vsi_to_vsi_loopback "vmeta.common.vsi={vf['vsi_num']},target_vsi={acc_pr['vsi_num']},action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+sleep 2
+
+"""
+            print("i {}".format(i))
+            if i <= vf_list_len-2:
+                print("vm id {}".format(vm_id))
+                ovs_vxlan += f"""echo ""
+echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']}:{vf['port']}) maps to"
+echo "ACC Port {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']}:{acc_pr['port']})"
+echo "ACC Port {acc_pr_list[i]} is added to OVS bridge br{vm_id}"
+ip link del TEP{vm_id}
+ovs-vsctl del-br br-int-{vm_id}
+ip link add dev TEP{vm_id} type dummy
+ovs-vsctl add-br br-int-{vm_id}
+ovs-vsctl add-port br-int-{vm_id} {acc_pr_list[i]}
+ovs-vsctl add-port br-int-{vm_id} {acc_pr_list[vf_list_len-1]}
+ifconfig TEP{vm_id} {local_vtep[vm_id]}/24 up
+ovs-vsctl add-port br-int-{vm_id} vxlan{vm_id} -- set interface vxlan{vm_id} type=vxlan options:local_ip={local_vtep[vm_id]} options:remote_ip={remote_vtep[vm_id]} options:key=1{vm_id} options:dst_port=4789
+ifconfig br-int-{vm_id} up
+"""
+
+
+            vf_to_vm += f'''
+echo ""
+ip addr add {vm_ip_list[vm_id]}/24 dev {vf_list[i]}
+ifconfig {vf_list[i]} up
+sleep 2
+
+'''
+
+            vm_id += 1
+
+        mac_list.append(str(acc_pr['mac']))
+
+
+    misc = """p4rt-ctl add-entry br0 linux_networking_control.ipv4_lpm_root_lut "user_meta.cmeta.bit16_zeros=4/65535,priority=2048,action=linux_networking_control.ipv4_lpm_root_lut_action(0)"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=0/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=1/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=2/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=3/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=4/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=5/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=6/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=7/7,priority=1,action=linux_networking_control.bypass"
+"""
+
+    acc_path = test_config['test_params']['acc_path']
+    acc_p4_path = f'{acc_path}/fxp-net_linux-networking'
+    file = f'{path}/es2k_skip_p4.conf'
+    p4_config = 'cat <<EOF > ./'+file+'''
+{
+    "chip_list": [
+        {
+            "id": "asic-0",
+            "chip_family": "mev",
+            "instance": 0,
+            "pcie_bdf": "0000:00:01.6",
+            "iommu_grp_num": 7,
+            "ctrl_map" : ["NETDEV","''' + '","'.join(mac_list) + '''" ,1]
+        }
+    ],
+    "instance": 0,
+    "cfgqs-idx": "0-15",
+    "p4_devices": [
+        {
+            "device-id": 0,
+            "fixed_functions" : [
+                {
+                    "name": "crypto",
+                    "tdi": "/opt/p4/p4sde/share/mev_reference_sample_files/fixed_function/crypto_mgr/ipsec_sad_offload.json",
+                    "ctx": "/opt/p4/p4sde/share/mev_reference_sample_files/fixed_function/crypto_mgr/ipsec_sad_offload_ctx.json"
+                }
+            ],
+            "eal-args": "--lcores=1-2 -a 00:01.6,vport=[0-1] -- -i --rxq=1 --txq=1 --hairpinq=1 --hairpin-mode=0x0",
+            "p4_programs": [
+                {
+                    "program-name": "fxp-net_linux-networking",
+                    "tdi-config": "'''+acc_p4_path+'''/tdi.json",
+                    "p4_pipelines": [
+                        {
+                            "p4_pipeline_name": "main",
+                            "context": "'''+acc_p4_path+'''/context.json",
+                            "config": "'''+acc_p4_path+'''/ipu.bin",
+                            "pipe_scope": [
+                                0,
+                                1,
+                                2,
+                                3
+                            ],
+                            "path": "'''+acc_p4_path+'''/"
+                        }
+                    ]
+                }
+            ],
+            "agent0": "lib/libpltfm_mgr.so"
+        }
+    ]
+}
+EOF
+'''
+    command_list.append(p4_config)
+
+    command_list.append(host_idpf)
+    command_list.append(host_comm_channel)
+
+    file = f'{path}/setup_acc_comm_channel.sh'
+    host_acc_comm_channel = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+#Assign IP in ACC for Host - ACC comm channel
+nmcli device set enp0s1f0d3 managed no
+ip addr add '''+comm_ip_acc+'''/24 dev enp0s1f0d3
+ip link set up dev enp0s1f0d3
+
+#Untar P4 tarball
+#tar -xzvf /opt/p4.tar.gz -C /opt/
+EOF
+'''
+    command_list.append(host_acc_comm_channel)
+
+
+    file = f'{path}/sync_host_acc_date.sh'
+    sync_host_acc_date = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+# Sync Date from host to acc
+timezonestr=\\$(timedatectl show| grep Timezone)
+timezone=\\$(echo "\\$timezonestr" | cut -d'=' -f2)
+hostdate=\\$(date)
+
+echo \\$timezonestr
+echo \\$timezone
+echo \\$hostdate
+ssh -o LogLevel=quiet  -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@'''+comm_ip_acc+''' "timedatectl set-timezone \"\\$timezone\""
+ssh -o LogLevel=quiet  -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@'''+comm_ip_acc+''' "date -s \'\\${hostdate}\'"
+
+EOF
+'''
+    command_list.append(sync_host_acc_date)
+
+
+
+
+    file = f'{path}/generate_certs.sh'
+    generate_certs = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+#Generate Certs
+echo ""
+echo "Generate the TLS Certs for Infrap4d"
+cd /usr/share/stratum/
+COMMON_NAME='''+comm_ip_acc+''' ./generate-certs.sh
+sleep 10
+
+EOF
+'''
+    command_list.append(generate_certs)
+
+
+
+    file = f'{path}/copy_certs.sh'
+    copy_certs = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+#Copy certs 
+echo ""
+echo "Copy the certs from ACC to host"
+mkdir -p /usr/share/stratum/
+cd /usr/share/stratum/
+scp -r -o LogLevel=quiet  -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
+    root@'''+comm_ip_acc+''':/usr/share/stratum/certs /usr/share/stratum
+EOF
+'''
+    command_list.append(copy_certs)
+
+
+
+    file = f'{path}/2_acc_infrap4d.sh'
+    acc_infrap4d = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+#ACC Environment for Infrap4d:
+echo ""
+echo "Setup the environment in ACC to run Infrap4d"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export no_proxy=localhost,127.0.0.1,192.168.0.0/16
+export NO_PROXY=localhost,127.0.0.1,192.168.0.0/16
+unset http_proxy
+unset https_proxy
+
+export OUTPUT_DIR='''+acc_p4_path+'''
+
+
+
+echo ""
+echo "Copy Infrap4d Config file es2k_skip_p4.conf to /usr/share/stratum/es2k/es2k_skip_p4.conf"
+touch \$OUTPUT_DIR/ipu.bin
+yes | cp -f \$OUTPUT_DIR/es2k_skip_p4.conf /usr/share/stratum/es2k/es2k_skip_p4.conf
+
+
+echo ""
+echo "Load the vfio-pci driver to bind the vfio-pci 00:01.6"
+sudo modprobe vfio-pci
+sudo /opt/p4/p4sde/bin/dpdk-devbind.py -b vfio-pci 00:01.6
+
+echo ""
+echo "Set hugepages"
+sudo /opt/p4/p4sde/bin/dpdk-hugepages.py -p 2M -r 2G
+
+echo ""
+echo "stop fiewall"
+systemctl stop firewalld
+
+
+echo ""
+echo "Verify the infrap4d config"
+cat /usr/share/stratum/es2k/es2k_skip_p4.conf
+
+
+
+echo ""
+echo "Start Infrap4d"
+#Start Infrap4d
+/opt/p4/p4-cp-nws/sbin/infrap4d --local_stratum_url="'''+comm_ip_acc+''':9339" --external_stratum_urls="'''+comm_ip_acc+''':9339,'''+comm_ip_acc+''':9559"
+EOF
+'''
+
+    command_list.append(acc_infrap4d)
+
+    file = f'{path}/3_acc_p4rt.sh'
+    acc_p4rt = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup P4 Runtime Pipeline"
+echo "P4 Artifacts are in Folder : OUTPUT_DIR='''+acc_p4_path+'''"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+
+tdi_pipeline_builder --p4c_conf_file=/usr/share/stratum/es2k/es2k_skip_p4.conf --tdi_pipeline_config_binary_file=\$OUTPUT_DIR/fxp-net_linux-networking.pb.bin
+
+alias p4rt-ctl='p4rt-ctl -g  '''+comm_ip_acc+''':9559 '
+
+sleep 2
+echo ""
+echo "Use p4rt-ctl set-pipe to setup the runtime pipeline"
+p4rt-ctl set-pipe br0 \$OUTPUT_DIR/fxp-net_linux-networking.pb.bin \$OUTPUT_DIR/p4Info.txt -g '''+comm_ip_acc+''':9559
+#to do check for comm ip
+sleep 2
+echo ""
+echo "Get IDPF Interface MAC and VSI info from IMC command : cli_client -q -c"
+echo "VSI (hexadecimal:decimal) PORT (VSI+16)"
+echo "Use p4rt-ctl to configure the VFs -- ACC PR"
+'''+vf_to_acc+'''
+sleep 2
+echo ""
+echo "Use p4rt-ctl to configure the Physical Ports -- ACC PR"
+'''+phy_to_acc+'''
+sleep 2
+echo ""
+echo "Configure supporting p4 runtime tables for LPM and LAG bypass"
+'''+misc+'''
+EOF
+'''
+    command_list.append(acc_p4rt)
+
+    file = f'{path}/acc_p4rt_delete.sh'
+    acc_p4rt_delete = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Delete the P4 Runtime Rules"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+alias p4rt-ctl='p4rt-ctl -g  '''+comm_ip_acc+''':9559 '
+
+
+echo "Use p4rt-ctl to remove the rules for the VFs -- ACC PR"
+'''+vf_to_acc+'''
+sleep 2
+echo ""
+echo "Use p4rt-ctl to remove the rules for Physical Ports -- ACC PR"
+'''+phy_to_acc+'''
+sleep 2
+echo ""
+echo "Remove supporting p4 runtime tables for LPM and LAG bypass"
+'''+misc+'''
+EOF
+'''
+    command_list.append(acc_p4rt_delete)
+
+    delete_command = f'''
+sed -i 's/add-entry/del-entry/g' {file}
+sed -i 's/,action.*"/"/g' {file}
+'''
+    command_list.append(delete_command)
+
+    file = f'{path}/4_acc_p4rt_dump.sh'
+    acc_p4rt_dump = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup P4 Runtime Pipeline"
+echo "P4 Artifacts are in Folder : OUTPUT_DIR='''+acc_p4_path+'''"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+alias p4rt-ctl='p4rt-ctl -g  '''+comm_ip_acc+''':9559 '
+
+echo ""
+echo "p4rt-ctl dump-entries br0 linux_networking_control.rx_source_port "
+p4rt-ctl dump-entries br0 
+
+EOF
+'''
+
+    command_list.append(acc_p4rt_dump)
+    file = f'{path}/5_acc_setup_ovs.sh'
+    acc_setup_ovs = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+killall ovsdb-server
+killall ovs-vswitchd
+
+echo ""
+echo "Setup the Environment to run OVS"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+rm -rf \$RUN_OVS/etc/openvswitch
+rm -rf \$RUN_OVS/var/run/openvswitch
+mkdir -p \$RUN_OVS/etc/openvswitch/
+mkdir -p \$RUN_OVS/var/run/openvswitch
+
+ovsdb-tool create \$RUN_OVS/etc/openvswitch/conf.db \$RUN_OVS/share/openvswitch/vswitch.ovsschema
+
+echo ""
+echo "Start the ovsdb-server"
+ovsdb-server --remote=punix:\$RUN_OVS/var/run/openvswitch/db.sock --remote=db:Open_vSwitch,Open_vSwitch,manager_options --pidfile --detach
+
+ovs-vsctl --no-wait init
+
+echo ""
+echo "Start the ovs-vswitchd"
+mkdir -p /tmp/logs
+ovs-vswitchd --pidfile --detach --mlockall --log-file=/tmp/logs/ovs-vswitchd.log  --grpc-addr="'''+comm_ip_acc+'''"
+
+ovs-vsctl set Open_vSwitch . other_config:n-revalidator-threads=1
+ovs-vsctl set Open_vSwitch . other_config:n-handler-threads=1
+echo ""
+echo "Verify OVS: ovsdb-server and ovs-vswitchd are running"
+ovs-vsctl  show
+
+ps -aux | grep ovs
+EOF
+'''
+    command_list.append(acc_setup_ovs)
+    file = f'{path}/6_acc_ovs_bridge.sh'
+    acc_ovs_bridge = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup the Environment to run OVS"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+echo ""
+echo "Setup an OVS Bridge br-intrnl"
+ovs-vsctl del-br br-intrnl
+ovs-vsctl add-br br-intrnl
+ovs-vsctl add-port br-intrnl enp0s1f0d4
+ovs-vsctl add-port br-intrnl enp0s1f0d6
+ovs-vsctl add-port br-intrnl vxlan1 -- set interface vxlan1 type=vxlan \
+    options:local_ip=10.1.1.1 options:remote_ip=10.1.1.2 options:key=10 options:dst_port=4789
+ifconfig br-intrnl up
+
+# setup br-tunl
+ovs-vsctl del-br br-tunl
+ovs-vsctl add-br br-tunl
+ovs-vsctl add-port br-tunl enp0s1f0d5
+ifconfig br-tunl 1.1.1.1/24 up
+
+ip link add dev TEP10 type dummy
+ifconfig TEP10 10.1.1.1/24 up
+ip route change 10.1.1.0/24 via 1.1.1.2 dev br-tunl
+
+sleep 2
+ovs-vsctl show
+
+echo "Check the interface configuration"
+sleep 1
+ip -br a
+
+EOF
+'''
+    command_list.append(acc_ovs_bridge)
+
+
+    file = f'{path}/proxy.sh'
+    proxy_setup = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+export no_proxy=$no_proxy,'''+comm_ip_acc+'''/16
+export NO_PROXY=$no_proxy
+unset http_proxy
+unset https_proxy
+EOF
+'''
+    command_list.append(proxy_setup)
+
+
+    file = f'{path}/host_ipsec_config.sh'
+    host_ipsec_config = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+echo "Setup the Host IPsec config"
+
+echo "Copying the p4info and binaries to host"
+scp -o LogLevel=quiet  -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@'''+comm_ip_acc+''':'''+acc_p4_path+'''/p4Info.txt /var/tmp/linux_networking.p4info.txt
+scp -o LogLevel=quiet  -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@'''+comm_ip_acc+''':'''+acc_p4_path+'''/fxp-net_linux-networking.pb.bin /var/tmp/ipsec_fixed_func.pb.bin
+
+
+echo "Stop firewall"
+systemctl stop firewalld
+
+
+sed -i 's/gnmi_server=.*/gnmi_server='''+comm_ip_acc+''':9339/g' '''+strongSwan_build+'''/ipsec_offload_plugin/ipsec_offload.conf
+sed -i 's/p4rt_server=.*/p4rt_server='''+comm_ip_acc+''':9559/g' '''+strongSwan_build+'''/ipsec_offload_plugin/ipsec_offload.conf
+yes | cp -f '''+strongSwan_build+'''/ipsec_offload_plugin/ipsec_offload.conf /usr/share/stratum
+
+
+EOF
+'''
+    command_list.append(host_ipsec_config)
+
+
+    file = f'{path}/ipsec.conf_transport_1'
+    create_ipsec_conf_transport_1 = 'cat <<EOF > ./'+file+'''
+conn sts-base
+    fragmentation=yes
+    keyingtries=%forever
+    ike=aes256-sha1-modp1024,3des-sha1-modp1024!
+    esp=aes256gcm128
+    leftauth=psk
+    rightauth=psk
+    keyexchange=ikev2
+    #replay_window=32
+    #rekey=yes
+    rekey=no
+    lifebytes=1000000000000000000
+    marginbytes=500000000000000000
+    type=transport
+    leftprotoport=tcp
+    rightprotoport=tcp
+    auto=start
+    left=192.168.1.101
+    right=192.168.1.102
+    leftid=192.168.1.101
+    rightid=192.168.1.102
+EOF
+'''
+    command_list.append(create_ipsec_conf_transport_1)
+
+
+    file = f'{path}/ipsec.conf_tunnel_1'
+    create_ipsec_conf_tunnel_1 = 'cat <<EOF > ./'+file+'''
+conn sts-base
+        fragmentation=yes
+        keyingtries=%forever
+        ike=aes256-sha1-modp1024,3des-sha1-modp1024!
+        esp=aes256gcm128
+        leftauth=psk
+        rightauth=psk
+        keyexchange=ikev2
+        #replay_window=32
+        #lifetime=1
+        #margintime=30m
+        #rekey=yes
+        lifebytes=100000000000
+        marginbytes=6000000000
+        rekey=no
+        type=tunnel
+        leftprotoport=tcp
+        rightprotoport=tcp
+        left=192.168.1.101
+        right=192.168.1.102
+        leftid=192.168.1.101
+        rightid=192.168.1.102
+        leftsubnet=11.0.0.1
+        rightsubnet=11.0.0.2
+        auto=start
+EOF
+'''
+    command_list.append(create_ipsec_conf_tunnel_1)
+
+
+    file = f'{path}/ipsec.conf_transport_2'
+    create_ipsec_conf_transport_2 = 'cat <<EOF > ./'+file+'''
+conn sts-base
+    fragmentation=yes
+    keyingtries=%forever
+    ike=aes256-sha1-modp1024,3des-sha1-modp1024!
+    esp=aes256gcm128
+    leftauth=psk
+    rightauth=psk
+    keyexchange=ikev2
+    #replay_window=32
+    #rekey=yes
+    rekey=no
+    lifebytes=1000000000000000000
+    marginbytes=500000000000000000
+    type=transport
+    leftprotoport=tcp
+    rightprotoport=tcp
+    auto=add
+    left=192.168.1.102
+    right=192.168.1.101
+    leftid=192.168.1.102
+    rightid=192.168.1.101
+EOF
+'''
+    command_list.append(create_ipsec_conf_transport_2)
+
+
+    file = f'{path}/ipsec.conf_tunnel_2'
+    create_ipsec_conf_tunnel_2 = 'cat <<EOF > ./'+file+'''
+conn sts-base
+        fragmentation=yes
+        keyingtries=%forever
+        ike=aes256-sha1-modp1024,3des-sha1-modp1024!
+        esp=aes256gcm128
+        leftauth=psk
+        rightauth=psk
+        keyexchange=ikev2
+        #replay_window=32
+        #lifetime=1
+        #margintime=30m
+        #rekey=yes
+        lifebytes=100000000000
+        marginbytes=6000000000
+        rekey=no
+        type=tunnel
+        leftprotoport=tcp
+        rightprotoport=tcp
+        left=192.168.1.102
+        right=192.168.1.101
+        leftid=192.168.1.102
+        rightid=192.168.1.101
+        leftsubnet=11.0.0.2
+        rightsubnet=11.0.0.1
+        auto=add
+EOF
+'''
+    command_list.append(create_ipsec_conf_tunnel_2)
+
+
+
+    local_vxlan_tunnel_mac_len = len(local_vxlan_tunnel_mac)
+    ipsec_tunnel_local_mac = ''
+
+    for i in range(local_vxlan_tunnel_mac_len):
+        first_octet, second_octet, third_octet = split_mac(local_vxlan_tunnel_mac[i])
+        ipsec_tunnel_local_mac += f"""echo ""
+# HOST_VF_INTF
+# ens801f0v0 : 00:1c:00:00:03:14 <-- 192.168.1.101 MAC address
+p4rt-ctl add-entry br0 linux_networking_control.rif_mod_table_start \
+    "rif_mod_map_id0=0x0005,action=linux_networking_control.set_src_mac_start(arg=0x{first_octet})"
+p4rt-ctl add-entry br0 linux_networking_control.rif_mod_table_mid \
+    "rif_mod_map_id1=0x0005,action=linux_networking_control.set_src_mac_mid(arg=0x{second_octet})"
+p4rt-ctl add-entry br0 linux_networking_control.rif_mod_table_last \
+    "rif_mod_map_id2=0x0005,action=linux_networking_control.set_src_mac_last(arg=0x{third_octet})"
+
+"""
+
+
+    remote_vxlan_mac_len = len(remote_vxlan_mac)
+    ipsec_tunnel_remote_vxlan_mac = ''
+    for i in range(remote_vxlan_mac_len):
+        first_split, second_split = split_mac_2(remote_vxlan_mac[i])
+
+        ipsec_tunnel_remote_vxlan_mac += f"""echo ""
+# CVL_HOST - nexthop - use remote host's MAC
+# vxlan10  : ee:35:eb:f9:2f:2b <-- tunnel MAC 192.168.1.102 on remote host
+p4rt-ctl add-entry br0 linux_networking_control.nexthop_table \
+    "user_meta.cmeta.nexthop_id=4,bit16_zeros=0,action=linux_networking_control.set_nexthop_info_dmac(router_interface_id=0x5,egress_port=0,dmac_high=0x{first_split},dmac_low=0x{second_split})"
+"""
+
+
+    remote_vxlan_ip_len = len(remote_vxlan_ip)
+    ipsec_tunnel_remote_vxlan_ip = ''
+    for i in range(remote_vxlan_ip_len):
+        hex_ip = ip_dec_to_hex(remote_vxlan_ip[i])
+
+        ipsec_tunnel_remote_vxlan_ip += f"""echo ""
+# Add to ipv4_table <-- entry for IPsec tunnel routing lookup
+# 0xc0a80166 = 192.168.1.102 (remote vxlan tunnel IP)
+p4rt-ctl add-entry br0 linux_networking_control.ipv4_table \
+    "ipv4_table_lpm_root=0,ipv4_dst_match=0x{hex_ip}/24,action=linux_networking_control.ipv4_set_nexthop_id(nexthop_id=0x4)"
+
+"""
+
+
+    file = f'{path}/ipsec_tunnel_config.sh'
+    ipsec_tunnel_config = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+export PATH=/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin:$PATH
+export SDE_INSTALL=/opt/p4/p4sde
+export LD_LIBRARY_PATH=/opt/p4/p4-cp-nws/lib:/opt/p4/p4-cp-nws/lib64:$SDE_INSTALL/lib64:$SDE_INSTALL/lib:/usr/lib64:/usr/lib:/usr/local/lib64:/usr/local/lib
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+
+alias p4rt-ctl='p4rt-ctl -g  '''+comm_ip_acc+''':9559 '
+echo "Setup the Host VMs and VFs"
+
+
+'''+ipsec_tunnel_local_mac+'''
+
+'''+ipsec_tunnel_remote_vxlan_mac+'''
+
+'''+ipsec_tunnel_remote_vxlan_ip+'''
+
+
+EOF
+'''
+    command_list.append(ipsec_tunnel_config)
+
+
+    file = f'{path}/ipsec.secrets'
+    ipsec_secrets = 'cat <<EOF > ./'+file+'''
+# ipsec.secrets - strongSwan IPsec secrets file
+   : PSK "example"
+EOF
+'''
+    command_list.append(ipsec_secrets)
+
+    file = f'{path}/acc_ovs_vxlan.sh'
+    acc_ovs_vxlan = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup the Environment to run OVS"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+
+'''+ovs_vxlan+'''
+ifconfig br-tun-0 '''+local_br_tun[0]+'''/24 up
+ip route change 10.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+
+sleep 2
+ovs-vsctl show
+
+echo "Check the interface configuration"
+sleep 1
+ip -br a
+
+EOF
+'''
+    command_list.append(acc_ovs_vxlan)
+
+
+    file = f'{path}/7_host_vm.sh'
+    host_vm = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+echo "Configure the Host VF Interfaces"
+
+'''+vf_to_vm+'''
+
+EOF
+'''
+    command_list.append(host_vm)
+    command_list.append(f"chmod +x {path}/*")
+
+    for command in command_list:
+        try:
+            result = ssh_command('host', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+
+    return None
+
+
+def build_args():
+    # Create the top-level parser
+    parser = argparse.ArgumentParser(description='Run Linux networking with IPsec Offload')
+    subparsers = parser.add_subparsers(dest='command', help='options')
+    # Create the parser for the "create_script" command
+    parser_create_script = subparsers.add_parser('create_script', help='Generate configuration scripts in localhost')
+    # Create the parser for the "copy_script" command
+    parser_copy_script = subparsers.add_parser('copy_script', help='Copy configuration scripts to IMC and ACC')
+    # Create the parser for the "setup" command
+    parser_setup = subparsers.add_parser('setup', help='Setup the complete OVS offload Recipe, prerequisite: run copy_script option once for scripts to be available in ACC')
+    # Create the parser for the "ipsec_transport" command
+    parser_setup = subparsers.add_parser('ipsec_transport', help='Setup the IPsec configs for transport mode, prerequisite: run copy_script option once for scripts to be available in Host')
+    # Create the parser for the "ipsec_tunnel" command
+    parser_setup = subparsers.add_parser('ipsec_tunnel', help='Setup the IPsec configs for tunnel mode, prerequisite: run copy_script option once for scripts to be available in Host & ACC')
+    # Create the parser for the "teardown" command
+    parser_teardown = subparsers.add_parser('teardown', help='Teardown the IPsec offload Recipe, prerequisite: run copy_script option once for scripts to be available in ACC')
+    return parser
+
+
+if __name__ == "__main__":
+    host_path = test_config['test_params']['host_path']
+    imc_path = test_config['test_params']['imc_path']
+    acc_path = test_config['test_params']['acc_path']
+    idpf_interface = test_config['test_params']['idpf_interface']
+    comm_ip_host = test_config['test_params']['comm_ip_host']
+    comm_ip_acc = test_config['test_params']['comm_ip_acc']    
+    vf_interfaces = test_config['test_params']['vf_interfaces']
+    acc_pr_interfaces = test_config['test_params']['acc_pr_interfaces']
+    ip_list=test_config['test_params']['ip_list']
+    imc_ip = test_config['imc']['ssh']['ip']
+    acc_ip = test_config['acc']['ssh']['ip']
+    acc_p4_path = f'{acc_path}/fxp-net_linux-networking'
+    host_password = test_config['host']['ssh']['password']
+    imc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
+    acc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
+    strongSwan_build = test_config['test_params']['strongSwan_build']
+    ipsec_host = test_config['test_params']['ipsec_host']
+    local_vxlan_tunnel_mac =  test_config['test_params']['local_vxlan_tunnel_mac']
+    remote_vxlan_ip = test_config['test_params']['remote_vxlan_ip']
+    remote_vxlan_mac = test_config['test_params']['remote_vxlan_mac']
+
+
+    parser = build_args()
+    # Parse the arguments
+    args = parser.parse_args()
+
+    host_ipsec = tmux_term(tmux_name="test_host_ipsec",tmux_override=True)
+    # Execute the appropriate function based on the subcommand
+    if args.command == 'create_script':
+
+        print("\n----------------Create IPsec Offload scripts----------------")
+        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list, host_idpf_intf=idpf_interface, path=host_path, \
+                            comm_ip_host=comm_ip_host, comm_ip_acc=comm_ip_acc, ipsec_host=ipsec_host)
+
+    elif args.command == 'copy_script':
+        print("\n----------------Create IPsec Offload scripts----------------")
+        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list, host_idpf_intf=idpf_interface, path=host_path, \
+                            comm_ip_host=comm_ip_host, comm_ip_acc=comm_ip_acc, ipsec_host=ipsec_host)
+        print("\n----------------Copy IPsec Offload scripts to the ACC----------------")
+        copy_scripts(host_path = host_path, imc_path = imc_path , acc_path = acc_path)
+
+    elif args.command == 'setup':
+
+        if len(host_password) == 0:
+            print("Enter correct IPU Host SSH root password in config.yaml and retry")
+            sys.exit()
+
+        print("\n----------------Setup Linux Networking for IPsec Offload----------------")
+
+
+        # Setup a TMUX session, for host comm channel 
+        print("\n----------------Setup TMUX Session and Login to the Host----------------")
+        host_comm = tmux_term(tmux_name="test_host_comm",tmux_override=True)
+        cwd = os.getcwd()
+        print("cwd  {}".format(cwd))
+        result = host_comm.tmux_send_keys('sudo -s', delay=2, output=True)
+        result = host_comm.tmux_send_keys(f'{host_password}', delay=2, output=True)
+        result = host_comm.tmux_send_keys(f'cd {cwd}/{host_path}', delay=2, output=True)
+
+        print("\n----------------Configure host comm channel for Host - ACC Communication----------------")
+        result = host_comm.tmux_send_keys('ls -lrt', delay=2, output=True)
+        print(f'{result}')
+        result = host_comm.tmux_send_keys('./setup_host_comm_channel.sh', delay=10, output=True)
+        print(result)
+
+
+        # Setup a TMUX session, Login to ACC and configure ACC comm channel for Host - ACC Communication 
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        acc_comm = tmux_term(tmux_name="test_acc_comm",tmux_override=True)
+        result = acc_comm.tmux_send_keys(imc_login, delay=2, output=True)
+        result = acc_comm.tmux_send_keys(acc_login, delay=2, output=True)
+        result = acc_comm.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+        result = acc_comm.tmux_send_keys('ls -lrt', delay=2, output=True)
+
+
+        print("\n----------------Configure ACC for Host - ACC communication----------------")
+        result = acc_comm.tmux_send_keys('./setup_acc_comm_channel.sh', delay=15, output=True)
+        print(result)
+
+
+        # Sync date between Host and ACC
+        print("\n----------------Sync date between host and ACC----------------")
+        print("cwd  {}".format(cwd))
+        result = host_comm.tmux_send_keys('./sync_host_acc_date.sh', delay=60, output=True)
+        print(result)
+
+
+       # Genereate certs
+        print("\n----------------Generate certs ----------------")
+        result = acc_comm.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+        result = acc_comm.tmux_send_keys('ls -lrt', delay=2, output=True)
+        result = acc_comm.tmux_send_keys('./generate_certs.sh', delay=60, output=True)
+        print(result)
+
+
+        # Copy certs to host from ACC
+        print("\n----------------Copy certs from ACC to Host----------------")
+        result = host_comm.tmux_send_keys('./copy_certs.sh', delay=15, output=True)
+        print(result)
+
+        # Setup a TMUX session, Login to ACC and start infrap4d
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        infrap4d = tmux_term(tmux_name="test_infrap4d",tmux_override=True)
+        result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
+        result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
+
+
+        print("\n----------------Copy Infrap4d Configuration file----------------")
+        result = infrap4d.tmux_send_keys(f'yes | cp -f {acc_path}/{host_path}/es2k_skip_p4.conf {acc_path}/fxp-net_linux-networking/', delay=2, output=True)
+        print(result)
+        result = infrap4d.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+        result = infrap4d.tmux_send_keys('ls -lrt', delay=2, output=True)
+
+        print("\n----------------Start Infrap4d, wait for initialization to complete----------------")
+        time.sleep(15)
+        result = infrap4d.tmux_send_keys('./2_acc_infrap4d.sh', delay=180, output=True)
+        print(result)
+
+        # Setup a TMUX session, Login to ACC, configure p4rt rules and ovs bridges
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        p4rt = tmux_term(tmux_name="test_p4rt",tmux_override=True)
+        result = p4rt.tmux_send_keys(imc_login, delay=2)
+        result = p4rt.tmux_send_keys(acc_login, delay=2)
+        result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+
+        print("\n----------------Use p4rt-ctl to Add the rules----------------")
+        result = p4rt.tmux_send_keys('./3_acc_p4rt.sh', delay=60, output=True)
+        print(result)
+        print("\n----------------Use p4rt-ctl to Dump the rules----------------")
+        result = p4rt.tmux_send_keys('./4_acc_p4rt_dump.sh', delay=20, output=True)
+        print(result)
+
+        print("\n----------------Setup OVS Environment on the ACC----------------")
+        result = p4rt.tmux_send_keys('./5_acc_setup_ovs.sh', delay=10, output=True)
+        print(result)
+        print("\n----------------Configure OVS Bridges----------------")
+        result = p4rt.tmux_send_keys('./acc_ovs_vxlan.sh', delay=10, output=True)
+        print(result)
+
+        # Setup a TMUX session for the IPU host, configure the VMs, idpf interfaces, Link partner interfaces and run ping checks
+        print("\n----------------Setup TMUX Session and Login to the Host----------------")
+        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
+        result = host.tmux_send_keys('sudo -s', delay=2, output=True)
+        result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
+
+        print("\n----------------Configure the VMs on the Host and ADD the IDPF SR-IOV VFs----------------")
+        result = host.tmux_send_keys('ls -lrt', delay=2, output=True)
+        print(f'{result}')
+        result = host.tmux_send_keys('./7_host_vm.sh', delay=10, output=True)
+        print(result)
+
+
+    elif args.command == 'ipsec_transport':
+        print("\n----------------Configure IPsec environment on the host----------------")
+        result = host_ipsec.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
+        result = host_ipsec.tmux_send_keys('./host_ipsec_config.sh', delay=15, output=True)
+        print(result)
+        result = host_ipsec.tmux_send_keys('source proxy.sh', delay=10, output=True)
+        result = host_ipsec.tmux_send_keys(f'yes|cp -f ipsec.secrets {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/', delay=2, output=True)
+        if ipsec_host == '1':
+            result = host_ipsec.tmux_send_keys(f'yes|cp -f ipsec.conf_transport_1 {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/ipsec.conf', delay=2, output=True)
+
+        elif ipsec_host == '2':
+            result = host_ipsec.tmux_send_keys(f'yes|cp -f ipsec.conf_transport_2 {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/ipsec.conf', delay=2, output=True)
+
+        result = host_ipsec.tmux_send_keys(f'cd {strongSwan_build}', delay=2, output=True)
+        result = host_ipsec.tmux_send_keys('source env_setup_acc.sh', delay=15, output=True)
+        result = host_ipsec.tmux_send_keys(f'cd {strongSwan_build}//ipsec_offload_plugin/output_strongswan/usr/sbin', delay=2, output=True)
+
+    elif args.command == 'ipsec_tunnel':
+        print("\n----------------Configuration for tunnel mode----------------")
+        p4rt = tmux_term(tmux_name="test_p4rt",tmux_override=True)
+        result = p4rt.tmux_send_keys(imc_login, delay=2)
+        result = p4rt.tmux_send_keys(acc_login, delay=2)
+        result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+
+        result = p4rt.tmux_send_keys('./ipsec_tunnel_config.sh', delay=15, output=True)
+        print(f'{result}')
+
+
+        print("\n----------------Configure IPsec environment on the host----------------")
+        result = host_ipsec.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
+        result = host_ipsec.tmux_send_keys('./host_ipsec_config.sh', delay=15, output=True)
+        print(result)
+        result = host_ipsec.tmux_send_keys('source proxy.sh', delay=10, output=True)
+        result = host_ipsec.tmux_send_keys(f'yes|cp -f ipsec.secrets {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/', delay=2, output=True)
+
+        if ipsec_host == '1':
+            result = host_ipsec.tmux_send_keys(f'yes|cp -f ipsec.conf_tunnel_1 {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/ipsec.conf', delay=2, output=True)
+
+        elif ipsec_host == '2':
+            result = host_ipsec.tmux_send_keys(f'yes|cp -f ipsec.conf_tunnel_2 {strongSwan_build}/ipsec_offload_plugin/output_strongswan/etc/ipsec.conf', delay=2, output=True)
+
+        result = host_ipsec.tmux_send_keys(f'cd {strongSwan_build}', delay=2, output=True)
+        result = host_ipsec.tmux_send_keys('source env_setup_acc.sh', delay=15, output=True)
+
+        result = host_ipsec.tmux_send_keys(f'cd {strongSwan_build}//ipsec_offload_plugin/output_strongswan/usr/sbin', delay=2, output=True)
+
+    elif args.command == 'teardown':
+
+        if len(host_password) == 0:
+            print("Enter correct IPU Host root password in config.yaml and retry")
+            sys.exit()
+
+        print("\n----------------Teardown Linux Networking with IPsec Offload----------------")
+
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        p4rt = tmux_term(tmux_name="test_p4rt",tmux_override=True)
+        result = p4rt.tmux_send_keys(imc_login, delay=2)
+        result = p4rt.tmux_send_keys(acc_login, delay=2)
+        result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+
+        print("\n----------------Cleanup OVS Bridge Configuration----------------")
+        command = f'''export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=$P4CP_INSTALL
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+ovs-vsctl show
+ovs-vsctl del-br br-int-0
+ovs-vsctl del-br br-tun-0
+
+ip link del TEP0
+ovs-vsctl del-br br0
+ovs-vsctl show
+'''
+        result = p4rt.tmux_send_keys(command, delay=20, output=True)
+        print(result)
+
+        print("\n----------------Use p4rt-ctl to Delete the rules----------------")
+        result = p4rt.tmux_send_keys('./acc_p4rt_delete.sh', delay=60, output=True)
+        print(result)
+        print("\n----------------Use p4rt-ctl to Dump the rules after cleanup----------------")
+        result = p4rt.tmux_send_keys('./4_acc_p4rt_dump.sh', delay=30, output=True)
+        print(result)
+
+        print("\n----------------Stop Infrap4d on the ACC----------------")
+        infrap4d = tmux_term(tmux_name="test_infrap4d",tmux_override=True)
+        result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
+        result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
+        result = infrap4d.tmux_send_keys('ps -aux | grep infrap4d', delay=2, output=True)
+        print(result)
+
+    else:
+        parser.print_help()
+
diff --git a/ipsec_accel/requirements.txt b/ipsec_accel/requirements.txt
new file mode 100644
index 0000000..5500f00
--- /dev/null
+++ b/ipsec_accel/requirements.txt
@@ -0,0 +1 @@
+PyYAML

commit 7b7b4ea58d076043130db922e382982aed2d1960
Merge: dbfdaa8 6650420
Author: Derek G Foster <derek.foster@intel.com>
Date:   Fri Sep 13 07:58:07 2024 -0700

    Merge pull request #5 from ipdk-io/spdx-license-id-update
    
    Update SPDX License identifier with correct format

commit 6650420699b33efa1d9f1087cdaf7586928d300e
Author: Sabeel Ansari <sabeel.ansari@intel.com>
Date:   Thu Sep 12 12:30:31 2024 -0700

    Update SPDX License identifier with correct format
    
    Signed-off-by: Sabeel Ansari <sabeel.ansari@intel.com>

diff --git a/ovs_offload/common/utils.py b/ovs_offload/common/utils.py
index 0009ad1..326eab9 100644
--- a/ovs_offload/common/utils.py
+++ b/ovs_offload/common/utils.py
@@ -1,7 +1,7 @@
 #!/usr/bin/python
 #
 # Copyright 2022-2024 Intel Corporation
-# SPDX-License-Identifier: Apache 2.0
+# SPDX-License-Identifier: Apache-2.0
 #
 # Common python APIs and utilities for Intel速 Infrastructure Processing Unit (Intel速 IPU)
 
diff --git a/ovs_offload/ovs_offload_lnw.py b/ovs_offload/ovs_offload_lnw.py
index de4ce80..23b74bf 100755
--- a/ovs_offload/ovs_offload_lnw.py
+++ b/ovs_offload/ovs_offload_lnw.py
@@ -1,7 +1,7 @@
 #!/usr/bin/python
 #
 # Copyright 2022-2024 Intel Corporation
-# SPDX-License-Identifier: Apache 2.0
+# SPDX-License-Identifier: Apache-2.0
 #
 # Python tool to setup Linux Networking with OVS Offload on Intel速 Infrastructure Processing Unit (Intel速 IPU)
 
diff --git a/ovs_offload/ovs_offload_lnw_v2.py b/ovs_offload/ovs_offload_lnw_v2.py
index c046b82..93be7bf 100755
--- a/ovs_offload/ovs_offload_lnw_v2.py
+++ b/ovs_offload/ovs_offload_lnw_v2.py
@@ -1,7 +1,7 @@
 #!/usr/bin/python
 #
 # Copyright 2022-2024 Intel Corporation
-# SPDX-License-Identifier: Apache 2.0
+# SPDX-License-Identifier: Apache-2.0
 #
 # Python tool to setup Linux Networking with OVS Offload on Intel速 Infrastructure Processing Unit (Intel速 IPU)
 
diff --git a/ovs_offload/ovs_offload_lnw_v3.py b/ovs_offload/ovs_offload_lnw_v3.py
index 2b985ef..b93a939 100755
--- a/ovs_offload/ovs_offload_lnw_v3.py
+++ b/ovs_offload/ovs_offload_lnw_v3.py
@@ -1,7 +1,7 @@
 #!/usr/bin/python
 #
 # Copyright 2022-2024 Intel Corporation
-# SPDX-License-Identifier: Apache 2.0
+# SPDX-License-Identifier: Apache-2.0
 #
 # Python tool to setup Linux Networking with OVS Offload on Intel速 Infrastructure Processing Unit (Intel速 IPU)
 

commit dbfdaa81de62c44842cb7050bbadc3f0548241d7
Merge: 4fa5da7 e297b2c
Author: Derek G Foster <derek.foster@intel.com>
Date:   Wed Sep 11 12:07:27 2024 -0700

    Merge pull request #2 from naveenashok211/main
    
    [ovs offload] script name change ovs_offload_lnv.py to ovs_offload_lnw.py

commit e297b2c7f840d58c9ecf0955640d0ce8196be368
Author: Naveen Ashok <naveen1.ashok@intel.com>
Date:   Wed Sep 11 11:47:13 2024 -0700

    [ovs offload] Address review comments and cleanup README.md
    
    Signed-off-by: Naveen Ashok <naveen1.ashok@intel.com>

diff --git a/ovs_offload/README.md b/ovs_offload/README.md
index 9977f13..f27f5c7 100644
--- a/ovs_offload/README.md
+++ b/ovs_offload/README.md
@@ -9,13 +9,10 @@
 
 ## Test Environment Setup
 
-- Before running script check if ssh as a root user is enabled and root user password is setup for ssh.
+Before running the script, make sure `/etc/ssh/ssd_config` contains the line.
 
 ```bash
-Check file /etc/ssh/sshd_config and change PermitRootLogin yes
-
-[root@athena ~]# grep -rn PermitRootLogin /etc/ssh/sshd_config
-40:PermitRootLogin yes
+PermitRootLogin yes
 ```
 
 ### Prerequisites
@@ -39,9 +36,8 @@ total 6.2M
 
 ```
 
-- Load the P4 package ``fxp-net_linux-networking.pkg`` on the IMC. Refer Section ``IPU P4 Quickstart Guide`` in the Intel速 Infrastructure Processing Unit Software User Guide
-- Copy the P4 artifacts folder for the specific release version being tested to the IMC and then to the ACC location ``/opt/p4/p4sde/p4_test/fxp-net_linux-networking``.
-
+- Load the P4 package `fxp-net_linux-networking.pkg` on the IMC. Refer Section `IPU P4 Quickstart Guide` in the Intel速 Infrastructure Processing Unit Software User Guide
+- Copy the P4 artifacts folder for the specific release version being tested to the IMC and then to the ACC location `/opt/p4/p4sde/p4_test/fxp-net_linux-networking`.
 - Make sure the same version of IDPF driver is loaded on the Host, IMC and ACC, run commands below as a root user
 
 ```bash
@@ -53,7 +49,8 @@ echo 8 > /sys/class/net/ens5f0/device/sriov_numvfs
 ```
 
 - Replace `ens5f0` above with the correct Host IDPF Interface to create 8 SR-IOV VFs on the Host.
-- The tool uses tmux session when running the option setup and option teardown. Install TMUX on the IPU Host.
+- The tool uses tmux sessions when running the option setup and option teardown.
+- Install TMUX on the IPU Host.
 
 ```bash
 Ubuntu/Debian.
@@ -70,7 +67,7 @@ usage: tmux [-2CDlNuvV] [-c shell-command] [-f file] [-L socket-name]
 
 ### Test Configuration (config.yaml)
 
-- Update yaml file config.yaml for the specific test setup. Change the management IP, username, and password for imc and acc if they are different.
+- Update the file: config.yaml for the specific test setup. Change the management IP, username, and password for imc and acc if they are different.
 - Update the test_params section as required for the setup with the correct host, imc and acc script paths.
 - Update the idpf_interface, vf_interfaces, acc_pr_interfaces and ip_list as required to scale up or scale down on the number of interface configuration generated by the script. More information on the fields in the comments below.
 
@@ -128,14 +125,14 @@ test_params:
 
 ## Python Environment Setup
 
-- Use python venv:
+Use python venv:
 
 ```bash
 cd networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload
 python -m venv --copies venv
 ```
 
-- Activate the venv and install requirements:
+Activate the venv and install requirements:
 
 ```bash
 # source venv/bin/activate
@@ -149,7 +146,7 @@ python -m venv --copies venv
 PyYAML
 ```
 
-- Run python script **ovs_offload_lnw.py** as a root user.
+Run python script **ovs_offload_lnw.py** as a root user.
 
 ```bash
 sudo -i
@@ -174,16 +171,16 @@ source venv/bin/activate
                             options
         create_script       Generate configuration scripts in localhost
         copy_script         Copy configuration scripts to IMC and ACC
-        setup               Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for
+        setup               Setup the complete OVS offload Recipe, prerequisite: run copy_script option once for
                             scripts to be available in ACC
-        teardown            Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once
+        teardown            Teardown the complete OVS offload Recipe, prerequisite: run copy_script option once
                             for scripts to be available in ACC
 
     optional arguments:
       -h, --help            show this help message and exit
     ```
 
-2. create_script: This will create the configuration scripts in the script directory (can be changes in **host_path** in **config.yaml**) at **ovs_offload/ovs_offload_lnw_scripts**
+2. create_script: This will create the configuration scripts in the script directory (the path can be changed in **host_path** in **config.yaml**) at **ovs_offload/ovs_offload_lnw_scripts**
 
     ```bash
     > python ovs_offload_lnw.py create_script
@@ -206,7 +203,7 @@ source venv/bin/activate
     -rwxr-xr-x. 1 admin12 admin12 2.8K Aug 28 13:37 7_host_vm.sh
     ```
 
-3. copy_script: This will create the configuration scripts in the script directory (can be changed in **host_path** in **config.yaml**) at **ovs_offload/ovs_offload_lnw_scripts** and also copy it to the ACC to the acc_path field provided in the **config file:config.yaml**
+3. copy_script: This will create the configuration scripts in the script directory (the path can be changed in **host_path** in **config.yaml**) at **ovs_offload/ovs_offload_lnw_scripts** and also copy it to the ACC to the acc_path field provided in the **config file:config.yaml**
 
     ```bash
     > python ovs_offload_lnw.py copy_script
@@ -232,13 +229,13 @@ source venv/bin/activate
     test3_host: 1 windows (created Thu Aug 29 12:32:55 2024)
     ```
 
-    - Attach to a tmux session
+    Attach to a tmux session
 
     ```bash
     tmux a -t test2_p4rt
     ```
 
-    - Detach from inside a tmux session.
+    Detach from inside a tmux session.
 
     ```bash
     ctrl+b d
@@ -271,9 +268,9 @@ source venv/bin/activate
                             options
         create_script       Generate configuration scripts in localhost
         copy_script         Copy configuration scripts to IMC and ACC
-        setup               Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for
+        setup               Setup the complete OVS offload Recipe, prerequisite: run copy_script option once for
                             scripts to be available in ACC
-        teardown            Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once
+        teardown            Teardown the complete OVS offload Recipe, prerequisite: run copy_script option once
                             for scripts to be available in ACC
 
     optional arguments:
@@ -295,18 +292,18 @@ source venv/bin/activate
                             options
         create_script       Generate configuration scripts in localhost
         copy_script         Copy configuration scripts to IMC and ACC
-        setup               Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for
+        setup               Setup the complete OVS offload Recipe, prerequisite: run copy_script option once for
                             scripts to be available in ACC
-        teardown            Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once
+        teardown            Teardown the complete OVS offload Recipe, prerequisite: run copy_script option once
                             for scripts to be available in ACC
 
     optional arguments:
       -h, --help            show this help message and exit
     ```
 
-## Use the Scripts on ACC to Setup OVS Offload
+## Use the Scripts on the ACC to Setup OVS Offload
 
-- Follow the instructions below to run the Recipe on the ACC with the help of configuration scripts or.
+- Follow the instructions below to run the recipe on the ACC with the help of configuration scripts or
 - Run the tool with setup option.
 
 ```bash
@@ -315,7 +312,8 @@ source venv/bin/activate
 
 ### 1. IPU P4 Artifacts on ACC
 
-- The scripts expect the P4 artifacts are available in the folder below in the ACC, make sure to copy the correct artifacts for the release. Example given below for P4: fxp-net_linux-networking.p4 for release 1.7.0, for Release 1.6.0 use P4: fxp-net_linux-networking_v3.p4 artifacts and for Release 1.4.0 use P4: fxp-net_linux-networking_v2.p4
+- The scripts expect the P4 artifacts are available in the folder below in the ACC, make sure to copy the correct artifacts for the release.
+- Example given below for P4: fxp-net_linux-networking.p4 for release 1.7.0, for Release 1.6.0 use P4: fxp-net_linux-networking_v3.p4 artifacts and for Release 1.4.0 use P4: fxp-net_linux-networking_v2.p4
 
 ```bash
 [root@ipu-acc ~]# ls /opt/p4/p4sde/p4_test/fxp-net_linux-networking
@@ -323,7 +321,7 @@ source venv/bin/activate
 
 ### 2. Infrap4d Configuration file
 
-- Copy the infrap4d config in **/opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts/es2k_skip_p4.conf** to artifact folder **/opt/p4/p4sde/p4_test/fxp-net_linux-networking** in the ACC
+Copy the infrap4d config in **/opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts/es2k_skip_p4.conf** to artifact folder **/opt/p4/p4sde/p4_test/fxp-net_linux-networking** in the ACC
 
 ```bash
 [root@ipu-acc ~]# cp /opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts/es2k_skip_p4.conf /opt/p4/p4sde/p4_test/fxp-net_linux-networking/
@@ -340,7 +338,7 @@ source venv/bin/activate
 [root@ipu-acc ovs_offload_lnw_scripts]# ./2_acc_infrap4d.sh
 ```
 
-- Wait for infrap4d to initialize and start listening on the server.
+Wait for infrap4d to initialize and start listening on the server.
 
 ```bash
 Initialized lld_cpchnl control path
@@ -366,7 +364,7 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 
 ### 3. Configure P4 pipeline and add the ACC PR rules
 
-- ACC Terminal 2 : Configure pipeline and set up runtime rules.
+ACC Terminal 2 : Configure pipeline and set up runtime rules.
 
 ```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
@@ -375,7 +373,7 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 [root@ipu-acc ovs_offload_lnw_scripts]# ./3_acc_p4rt.sh
 ```
 
-- ACC Terminal 2 : Dump the p4rt-ctl runtime rules.
+ACC Terminal 2 : Dump the p4rt-ctl runtime rules.
 
 ```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
@@ -386,7 +384,7 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 
 ### 4. Set up ACC environment for OVS
 
-- ACC Terminal 2 : Set up the OVS Environment.
+ACC Terminal 2 : Set up the OVS Environment.
 
 ```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
@@ -397,7 +395,7 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 
 ### 5. Set up OVS Bridge Configuration
 
-- ACC Terminal 2 : Set up the OVS Bridge Config
+ACC Terminal 2 : Set up the OVS Bridge Config
 
 ```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
@@ -408,7 +406,7 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 
 ### 6. Set up VMs on the IPU Host and configure link partner interface
 
-- IPU HOST Terminal 1 : Configure the VMs on the IPU Host the script below uses **ip netns**
+IPU HOST Terminal 1 : Configure the VMs on the IPU Host the script below uses **ip netns**
 
 ```bash
 [root@host]# cd ovs_offload/scripts/ovs_offload_lnw_scripts
@@ -438,7 +436,7 @@ ip netns exec VM4 ping 20.0.0.30
 
 ### 7. Optional: Set up OVS Bridge for VXLAN
 
-- This configuration script will setup OVS VXLAN Bridges.
+This configuration script will setup OVS VXLAN Bridges.
 
 ```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
@@ -447,13 +445,13 @@ ip netns exec VM4 ping 20.0.0.30
 [root@ipu-acc ovs_offload_lnw_scripts]# ./acc_ovs_vxlan.sh
 ```
 
-- Stop firewalld on IPU Host and the ACC
+Stop firewalld on IPU Host and the ACC
 
 ```bash
 systemctl stop firewalld
 ```
 
-- Run simple script below to configure VXLAN on the Link Partner Connected to Port 0:
+Run simple script below to configure VXLAN on the Link Partner Connected to Port 0:
 
 ```bash
 #!/bin/sh
@@ -491,7 +489,7 @@ echo "Verify the Configure interfaces"
 
 ```
 
-- Run a Ping Test
+Run a Ping Test
 
 ```bash
 [root@host ovs_offload_lnw_scripts]# ip netns exec VM0 ip -br a
@@ -537,7 +535,8 @@ rtt min/avg/max/mdev = 0.040/0.048/0.058/0.007 ms
 
 - Ideally OVS Offload with VXLAN can be run with 2 IPU Peer Setups connected back to back.
 - Run python script **ovs_offload_lnw.py** as a root user on the 2 peer IPU Hosts to generate the configuration.
-- Update the config.yaml for OVS VXLAN for IPU 1 Setup.
+
+Update the config.yaml for OVS VXLAN for IPU 1 Setup.
 
 ```bash
 > cat config.yaml
@@ -555,7 +554,7 @@ test_params:
 
 ```
 
-- Update config.yaml for OVS VXLAN Config for IPU 2 Setup.
+Update config.yaml for OVS VXLAN Config for IPU 2 Setup.
 
 ```bash
 > cat config.yaml
@@ -578,7 +577,7 @@ test_params:
 
 ### Optional:  Clean up the configs
 
-- Run the tool with option **teardown**
+Run the tool with option **teardown**
 
 ```bash
 > python ovs_offload_lnw.py teardown
@@ -586,7 +585,7 @@ test_params:
 
 or
 
-- IPU HOST Terminal 1: Delete the VMs created on the IPU Host
+IPU HOST Terminal 1: Delete the VMs created on the IPU Host
 
 ```bash
 ip netns del VM0
@@ -599,7 +598,7 @@ ip netns del VM6
 ip netns del VM7
 ```
 
-- ACC Terminal 2 : Delete the OVS Bridge Config on the ACC
+ACC Terminal 2 : Delete the OVS Bridge Config on the ACC
 
 ```bash
 #!/bin/sh
@@ -635,7 +634,7 @@ ovs-vsctl show
 
 ```
 
-- ACC Terminal 2: Delete the p4rt-ctl runtime rules
+ACC Terminal 2: Delete the p4rt-ctl runtime rules
 
 ```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
@@ -646,7 +645,7 @@ ovs-vsctl show
 [root@ipu-acc ovs_offload_lnw_scripts]# ./4_acc_p4rt_dump.sh
 ```
 
-- ACC Terminal 1: Terminate the infrap4d
+ACC Terminal 1: Terminate the infrap4d
 
 ```bash
 [root@ipu-acc ~]# ctrl + c
diff --git a/ovs_offload/ovs_offload_lnw.py b/ovs_offload/ovs_offload_lnw.py
index 1dd9828..de4ce80 100755
--- a/ovs_offload/ovs_offload_lnw.py
+++ b/ovs_offload/ovs_offload_lnw.py
@@ -25,7 +25,6 @@ def build_p4rt_config(vf_list=[], acc_pr_list=[],vm_ip_list=[], host_idpf_intf='
 #!/bin/sh
 #Load the driver
 echo "Load the IDPF Driver on the Host"
-#rmmod idpf
 modprobe idpf
 sleep 4
 
@@ -455,21 +454,6 @@ ovs-vsctl del-br br7
 ip link del TEP8
 ovs-vsctl del-br br8
 
-#ovs-vsctl add-br br-int-1
-#ovs-vsctl add-port br-int-1 enp0s1f0d1
-#ovs-vsctl add-port br-int-1 enp0s1f0d2
-#ovs-vsctl add-port br-int-1 enp0s1f0d3
-#ovs-vsctl add-port br-int-1 enp0s1f0d4
-#ovs-vsctl add-port br-int-1 enp0s1f0d5
-#ovs-vsctl add-port br-int-1 enp0s1f0d6
-#ovs-vsctl add-port br-int-1 enp0s1f0d7
-#ovs-vsctl add-port br-int-1 enp0s1f0d8
-#ovs-vsctl add-port br-int-1 enp0s1f0d9
-#ovs-vsctl add-port br-int-1 enp0s1f0d10
-#ovs-vsctl add-port br-int-1 enp0s1f0d11
-#ovs-vsctl add-port br-int-1 enp0s1f0d12
-#ifconfig br-int-1 up
-
 ovs-vsctl add-br br-int-1
 ovs-vsctl add-port br-int-1 enp0s1f0d4
 ovs-vsctl add-port br-int-1 enp0s1f0d6
@@ -568,9 +552,9 @@ def build_args():
     # Create the parser for the "copy_script" command
     parser_copy_script = subparsers.add_parser('copy_script', help='Copy configuration scripts to IMC and ACC')
     # Create the parser for the "setup" command
-    parser_setup = subparsers.add_parser('setup', help='Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for scripts to be available in ACC')
+    parser_setup = subparsers.add_parser('setup', help='Setup the complete OVS offload Recipe, prerequisite: run copy_script option once for scripts to be available in ACC')
     # Create the parser for the "teardown" command
-    parser_teardown = subparsers.add_parser('teardown', help='Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once for scripts to be available in ACC')
+    parser_teardown = subparsers.add_parser('teardown', help='Teardown the complete OVS offload Recipe, prerequisite: run copy_script option once for scripts to be available in ACC')
     return parser
 
 
@@ -652,6 +636,7 @@ if __name__ == "__main__":
         result = p4rt.tmux_send_keys('./6_acc_ovs_bridge.sh', delay=10, output=True)
         print(result)
 
+        # Setup a TMUX session for the IPU host, configure the VMs, idpf interfaces, Link partner interfaces and run ping checks
         print("\n----------------Setup TMUX Session and Login to the Host----------------")
         host = tmux_term(tmux_name="test3_host",tmux_override=True)
         result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
diff --git a/ovs_offload/ovs_offload_lnw_v2.py b/ovs_offload/ovs_offload_lnw_v2.py
index bc954a9..c046b82 100755
--- a/ovs_offload/ovs_offload_lnw_v2.py
+++ b/ovs_offload/ovs_offload_lnw_v2.py
@@ -25,7 +25,6 @@ def build_p4rt_config(vf_list=[], acc_pr_list=[],vm_ip_list=[], host_idpf_intf='
 #!/bin/sh
 #Load the driver
 echo "Load the IDPF Driver on the Host"
-#rmmod idpf
 modprobe idpf
 sleep 4
 
@@ -455,21 +454,6 @@ ovs-vsctl del-br br7
 ip link del TEP8
 ovs-vsctl del-br br8
 
-#ovs-vsctl add-br br-int-1
-#ovs-vsctl add-port br-int-1 enp0s1f0d1
-#ovs-vsctl add-port br-int-1 enp0s1f0d2
-#ovs-vsctl add-port br-int-1 enp0s1f0d3
-#ovs-vsctl add-port br-int-1 enp0s1f0d4
-#ovs-vsctl add-port br-int-1 enp0s1f0d5
-#ovs-vsctl add-port br-int-1 enp0s1f0d6
-#ovs-vsctl add-port br-int-1 enp0s1f0d7
-#ovs-vsctl add-port br-int-1 enp0s1f0d8
-#ovs-vsctl add-port br-int-1 enp0s1f0d9
-#ovs-vsctl add-port br-int-1 enp0s1f0d10
-#ovs-vsctl add-port br-int-1 enp0s1f0d11
-#ovs-vsctl add-port br-int-1 enp0s1f0d12
-#ifconfig br-int-1 up
-
 ovs-vsctl add-br br-int-1
 ovs-vsctl add-port br-int-1 enp0s1f0d4
 ovs-vsctl add-port br-int-1 enp0s1f0d6
@@ -568,9 +552,9 @@ def build_args():
     # Create the parser for the "copy_script" command
     parser_copy_script = subparsers.add_parser('copy_script', help='Copy configuration scripts to IMC and ACC')
     # Create the parser for the "setup" command
-    parser_setup = subparsers.add_parser('setup', help='Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for scripts to be available in ACC')
+    parser_setup = subparsers.add_parser('setup', help='Setup the complete OVS offload Recipe, prerequisite: run copy_script option once for scripts to be available in ACC')
     # Create the parser for the "teardown" command
-    parser_teardown = subparsers.add_parser('teardown', help='Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once for scripts to be available in ACC')
+    parser_teardown = subparsers.add_parser('teardown', help='Teardown the complete OVS offload Recipe, prerequisite: run copy_script option once for scripts to be available in ACC')
     return parser
 
 
@@ -652,6 +636,7 @@ if __name__ == "__main__":
         result = p4rt.tmux_send_keys('./6_acc_ovs_bridge.sh', delay=10, output=True)
         print(result)
 
+        # Setup a TMUX session for the IPU host, configure the VMs, idpf interfaces, Link partner interfaces and run ping checks
         print("\n----------------Setup TMUX Session and Login to the Host----------------")
         host = tmux_term(tmux_name="test3_host",tmux_override=True)
         result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
diff --git a/ovs_offload/ovs_offload_lnw_v3.py b/ovs_offload/ovs_offload_lnw_v3.py
index eb10ac5..2b985ef 100755
--- a/ovs_offload/ovs_offload_lnw_v3.py
+++ b/ovs_offload/ovs_offload_lnw_v3.py
@@ -25,7 +25,6 @@ def build_p4rt_config(vf_list=[], acc_pr_list=[],vm_ip_list=[], host_idpf_intf='
 #!/bin/sh
 #Load the driver
 echo "Load the IDPF Driver on the Host"
-#rmmod idpf
 modprobe idpf
 sleep 4
 
@@ -455,21 +454,6 @@ ovs-vsctl del-br br7
 ip link del TEP8
 ovs-vsctl del-br br8
 
-#ovs-vsctl add-br br-int-1
-#ovs-vsctl add-port br-int-1 enp0s1f0d1
-#ovs-vsctl add-port br-int-1 enp0s1f0d2
-#ovs-vsctl add-port br-int-1 enp0s1f0d3
-#ovs-vsctl add-port br-int-1 enp0s1f0d4
-#ovs-vsctl add-port br-int-1 enp0s1f0d5
-#ovs-vsctl add-port br-int-1 enp0s1f0d6
-#ovs-vsctl add-port br-int-1 enp0s1f0d7
-#ovs-vsctl add-port br-int-1 enp0s1f0d8
-#ovs-vsctl add-port br-int-1 enp0s1f0d9
-#ovs-vsctl add-port br-int-1 enp0s1f0d10
-#ovs-vsctl add-port br-int-1 enp0s1f0d11
-#ovs-vsctl add-port br-int-1 enp0s1f0d12
-#ifconfig br-int-1 up
-
 ovs-vsctl add-br br-int-1
 ovs-vsctl add-port br-int-1 enp0s1f0d4
 ovs-vsctl add-port br-int-1 enp0s1f0d6
@@ -568,9 +552,9 @@ def build_args():
     # Create the parser for the "copy_script" command
     parser_copy_script = subparsers.add_parser('copy_script', help='Copy configuration scripts to IMC and ACC')
     # Create the parser for the "setup" command
-    parser_setup = subparsers.add_parser('setup', help='Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for scripts to be available in ACC')
+    parser_setup = subparsers.add_parser('setup', help='Setup the complete OVS offload Recipe, prerequisite: run copy_script option once for scripts to be available in ACC')
     # Create the parser for the "teardown" command
-    parser_teardown = subparsers.add_parser('teardown', help='Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once for scripts to be available in ACC')
+    parser_teardown = subparsers.add_parser('teardown', help='Teardown the complete OVS offload Recipe, prerequisite: run copy_script option once for scripts to be available in ACC')
     return parser
 
 
@@ -652,6 +636,7 @@ if __name__ == "__main__":
         result = p4rt.tmux_send_keys('./6_acc_ovs_bridge.sh', delay=10, output=True)
         print(result)
 
+        # Setup a TMUX session for the IPU host, configure the VMs, idpf interfaces, Link partner interfaces and run ping checks
         print("\n----------------Setup TMUX Session and Login to the Host----------------")
         host = tmux_term(tmux_name="test3_host",tmux_override=True)
         result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)

commit ad5ea466bc0ac9e8af6808285412e3c8217d2cff
Author: Naveen Ashok <naveen1.ashok@intel.com>
Date:   Wed Sep 11 10:54:01 2024 -0700

    Apply suggestions from code review
    
    Co-authored-by: Derek G Foster <derek.foster@intel.com>
    Signed-off-by: Naveen Ashok <naveen1.ashok@intel.com>

diff --git a/ovs_offload/README.md b/ovs_offload/README.md
index bb97a41..9977f13 100644
--- a/ovs_offload/README.md
+++ b/ovs_offload/README.md
@@ -5,7 +5,7 @@
 - The ovs_offload_lnw.py script can be used on an host server connected with Intel速 Infrastructure Processing Unit via PCIe.
 - It creates the configuration to run the Linux Networking Recipe with OVS Offload on the ACC.
 - It can be used to start infrap4d on the ACC and use the script generated p4rt-ctl rules to configure ACC Port representors for the Host IDPF interfaces and IPU Physical Ports.
-- It can setup OVS bridges on the ACC using the port representors and configure VMs on the IDPF interfaces on the Host.
+- It can set up OVS bridges on the ACC using the port representors and configure VMs on the IDPF interfaces on the Host.
 
 ## Test Environment Setup
 
@@ -18,10 +18,10 @@ Check file /etc/ssh/sshd_config and change PermitRootLogin yes
 40:PermitRootLogin yes
 ```
 
-### Pre-requisites
+### Prerequisites
 
-- The host package ``intel-ipu-host-components-<version>.<build number>.tar.gz`` contains the example IPU P4 source code, the compiled P4 package and artifacts that can be used to setup the workload on the IMC and ACC.
-- The compiled artifacts for P4 ``fxp-net_linux-networking`` can be found in below location after extracting the tar package.
+- The host package `intel-ipu-host-components-<version>.<build number>.tar.gz` contains the example IPU P4 source code, the compiled P4 package, and artifacts that can be used to set up the workload on the IMC and ACC.
+- The compiled artifacts for P4 `fxp-net_linux-networking` can be found in the location below after you extract the tar package.
 
 ```bash
 cd intel-ipu-host-components/P4Tools/P4Programs/artifacts/fxp-net_linux-networking
@@ -68,9 +68,9 @@ usage: tmux [-2CDlNuvV] [-c shell-command] [-f file] [-L socket-name]
             [-S socket-path] [-T features] [command [flags]]
 ```
 
-### Test Configuration config.yaml
+### Test Configuration (config.yaml)
 
-- Update yaml file config.yaml for the specific test setup, change the management IP, username and password for imc and acc if it is different.
+- Update yaml file config.yaml for the specific test setup. Change the management IP, username, and password for imc and acc if they are different.
 - Update the test_params section as required for the setup with the correct host, imc and acc script paths.
 - Update the idpf_interface, vf_interfaces, acc_pr_interfaces and ip_list as required to scale up or scale down on the number of interface configuration generated by the script. More information on the fields in the comments below.
 
@@ -206,7 +206,7 @@ source venv/bin/activate
     -rwxr-xr-x. 1 admin12 admin12 2.8K Aug 28 13:37 7_host_vm.sh
     ```
 
-3. copy_script: This will create the configuration scripts in the script directory (can be changes in **host_path** in **config.yaml**) at **ovs_offload/ovs_offload_lnw_scripts** and also copy it to the ACC to the acc_path field provided in the **config file:config.yaml**
+3. copy_script: This will create the configuration scripts in the script directory (can be changed in **host_path** in **config.yaml**) at **ovs_offload/ovs_offload_lnw_scripts** and also copy it to the ACC to the acc_path field provided in the **config file:config.yaml**
 
     ```bash
     > python ovs_offload_lnw.py copy_script
@@ -250,8 +250,8 @@ source venv/bin/activate
     > python ovs_offload_lnw.py teardown
     ```
 
-    - This will teardown the complete OVS offload recipe.
-    - Pre-Requisite: run copy_script option once for scripts to be available in ACC
+    - This will tear down the complete OVS offload recipe.
+    - Prerequisite: run copy_script option once for scripts to be available in ACC
     - Configure TMUX session - test3_host delete the VMs on Host and remove the link partner configuration.
     - Configure TMUX session - test2_p4rt delete the p4rt-ctl rules and delete the OVS bridges
     - Configure TMUX session - test1_infrap4d, login to ACC and stop infrap4d,
@@ -331,8 +331,8 @@ source venv/bin/activate
 
 ### 3. Start Infrap4d
 
-- Use the ovs_offload_lnw_scripts in the ACC to setup infrap4d, p4rt and OVS bridge:
-- ACC Terminal 1 : Setup environment and start Infrap4d
+- Use the ovs_offload_lnw_scripts in the ACC to set up infrap4d, p4rt and OVS bridge:
+- ACC Terminal 1 : Set up environment and start Infrap4d
 
 ```bash
 [root@ipu-acc ~]# cd /opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
@@ -364,9 +364,9 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 
 ```
 
-### 3. Setup p4rt-ctl pipe and add the ACC PR rules
+### 3. Configure P4 pipeline and add the ACC PR rules
 
-- ACC Terminal 2 : Setup p4rt-ctl pipeline and setup the runtime rules.
+- ACC Terminal 2 : Configure pipeline and set up runtime rules.
 
 ```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
@@ -384,9 +384,9 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 [root@ipu-acc ovs_offload_lnw_scripts]# ./4_acc_p4rt_dump.sh
 ```
 
-### 4. Setup ACC environment for OVS
+### 4. Set up ACC environment for OVS
 
-- ACC Terminal 2 : Setup the OVS Environment.
+- ACC Terminal 2 : Set up the OVS Environment.
 
 ```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
@@ -395,9 +395,9 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 [root@ipu-acc ovs_offload_lnw_scripts]# ./5_acc_setup_ovs.sh
 ```
 
-### 5. Setup OVS Bridge Configuration
+### 5. Set up OVS Bridge Configuration
 
-- ACC Terminal 2 : Setup the OVS Bridge Config
+- ACC Terminal 2 : Set up the OVS Bridge Config
 
 ```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
@@ -406,7 +406,7 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 [root@ipu-acc ovs_offload_lnw_scripts]# ./6_acc_ovs_bridge.sh
 ```
 
-### 6. Setup VMs on the IPU Host and configure link partner interface
+### 6. Set up VMs on the IPU Host and configure link partner interface
 
 - IPU HOST Terminal 1 : Configure the VMs on the IPU Host the script below uses **ip netns**
 
@@ -436,7 +436,7 @@ ip netns exec VM4 ping 20.0.0.30
 
 ```
 
-### 7. Optional: Setup OVS Bridge for VXLAN
+### 7. Optional: Set up OVS Bridge for VXLAN
 
 - This configuration script will setup OVS VXLAN Bridges.
 
@@ -533,7 +533,7 @@ rtt min/avg/max/mdev = 0.040/0.048/0.058/0.007 ms
 
 ```
 
-### OVS Offload VXLAN on 2 IPU Peers Connected back to back
+### OVS Offload VXLAN on Two IPU Peers Connected back-to-back
 
 - Ideally OVS Offload with VXLAN can be run with 2 IPU Peer Setups connected back to back.
 - Run python script **ovs_offload_lnw.py** as a root user on the 2 peer IPU Hosts to generate the configuration.

commit 43716390f861b97686c3b22cd12660c4e61a6d30
Author: Naveen Ashok <naveen1.ashok@intel.com>
Date:   Tue Sep 10 13:23:09 2024 -0700

    [ovs offload] Update README with markdown lint fixes 4
    
    Signed-off-by: Naveen Ashok <naveen1.ashok@intel.com>

diff --git a/ovs_offload/README.md b/ovs_offload/README.md
index 0c72dab..bb97a41 100644
--- a/ovs_offload/README.md
+++ b/ovs_offload/README.md
@@ -236,8 +236,8 @@ source venv/bin/activate
 
     ```bash
     tmux a -t test2_p4rt
-
     ```
+
     - Detach from inside a tmux session.
 
     ```bash

commit 4cf5e831b573d563226d10df055f49fc2b0d414f
Author: Naveen Ashok <naveen1.ashok@intel.com>
Date:   Tue Sep 10 13:21:20 2024 -0700

    [ovs offload] Update README with markdown lint fixes 3
    
    Signed-off-by: Naveen Ashok <naveen1.ashok@intel.com>

diff --git a/ovs_offload/README.md b/ovs_offload/README.md
index cb02127..0c72dab 100644
--- a/ovs_offload/README.md
+++ b/ovs_offload/README.md
@@ -236,6 +236,7 @@ source venv/bin/activate
 
     ```bash
     tmux a -t test2_p4rt
+
     ```
     - Detach from inside a tmux session.
 

commit 2f628adbc0296b659a5f3610800ca73005d1c758
Author: Naveen Ashok <naveen1.ashok@intel.com>
Date:   Tue Sep 10 13:19:09 2024 -0700

    [ovs offload] Update README with markdown lint fixes 2
    
    Signed-off-by: Naveen Ashok <naveen1.ashok@intel.com>

diff --git a/ovs_offload/README.md b/ovs_offload/README.md
index 3042597..cb02127 100644
--- a/ovs_offload/README.md
+++ b/ovs_offload/README.md
@@ -51,6 +51,7 @@ lsmod | grep idpf
 modinfo idpf
 echo 8 > /sys/class/net/ens5f0/device/sriov_numvfs
 ```
+
 - Replace `ens5f0` above with the correct Host IDPF Interface to create 8 SR-IOV VFs on the Host.
 - The tool uses tmux session when running the option setup and option teardown. Install TMUX on the IPU Host.
 
@@ -162,145 +163,145 @@ source venv/bin/activate
 
 1. This is a python script : **ovs_offload/ovs_offload_lnw.py** that can be used with **P4: fxp-net_linux-networking.p4** for release 1.7.0 and later
 
-```bash
-> python ovs_offload_lnw.py
-usage: ovs_offload_lnw.py [-h] {create_script,copy_script,setup,teardown} ...
+    ```bash
+    > python ovs_offload_lnw.py
+    usage: ovs_offload_lnw.py [-h] {create_script,copy_script,setup,teardown} ...
 
-Run Linux networking with OVS Offload
+    Run Linux networking with OVS Offload
 
-positional arguments:
-  {create_script,copy_script,setup,teardown}
-                        options
-    create_script       Generate configuration scripts in localhost
-    copy_script         Copy configuration scripts to IMC and ACC
-    setup               Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for
-                        scripts to be available in ACC
-    teardown            Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once
-                        for scripts to be available in ACC
+    positional arguments:
+      {create_script,copy_script,setup,teardown}
+                            options
+        create_script       Generate configuration scripts in localhost
+        copy_script         Copy configuration scripts to IMC and ACC
+        setup               Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for
+                            scripts to be available in ACC
+        teardown            Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once
+                            for scripts to be available in ACC
 
-optional arguments:
-  -h, --help            show this help message and exit
-```
+    optional arguments:
+      -h, --help            show this help message and exit
+    ```
 
 2. create_script: This will create the configuration scripts in the script directory (can be changes in **host_path** in **config.yaml**) at **ovs_offload/ovs_offload_lnw_scripts**
 
-```bash
-> python ovs_offload_lnw.py create_script
-```
-
-The scripts will be created as shown below.
-
-```bash
-> ls networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload/ovs_offload_lnw_scripts/
-total 60K
--rwxr-xr-x. 1 admin12 admin12 1.6K Aug 28 13:37 es2k_skip_p4.conf
--rwxr-xr-x. 1 admin12 admin12  375 Aug 28 13:37 1_host_idpf.sh
--rwxr-xr-x. 1 admin12 admin12 1.3K Aug 28 13:37 2_acc_infrap4d.sh
--rwxr-xr-x. 1 admin12 admin12  12K Aug 28 13:37 3_acc_p4rt.sh
--rwxr-xr-x. 1 admin12 admin12 8.4K Aug 28 13:37 acc_p4rt_delete.sh
--rwxr-xr-x. 1 admin12 admin12 2.0K Aug 28 13:37 4_acc_p4rt_dump.sh
--rwxr-xr-x. 1 admin12 admin12 1.3K Aug 28 13:37 5_acc_setup_ovs.sh
--rwxr-xr-x. 1 admin12 admin12 2.1K Aug 28 13:37 6_acc_ovs_bridge.sh
--rwxr-xr-x. 1 admin12 admin12 6.1K Aug 28 13:37 acc_ovs_vxlan.sh
--rwxr-xr-x. 1 admin12 admin12 2.8K Aug 28 13:37 7_host_vm.sh
-```
+    ```bash
+    > python ovs_offload_lnw.py create_script
+    ```
+
+    The scripts will be created as shown below.
+
+    ```bash
+    > ls networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload/ovs_offload_lnw_scripts/
+    total 60K
+    -rwxr-xr-x. 1 admin12 admin12 1.6K Aug 28 13:37 es2k_skip_p4.conf
+    -rwxr-xr-x. 1 admin12 admin12  375 Aug 28 13:37 1_host_idpf.sh
+    -rwxr-xr-x. 1 admin12 admin12 1.3K Aug 28 13:37 2_acc_infrap4d.sh
+    -rwxr-xr-x. 1 admin12 admin12  12K Aug 28 13:37 3_acc_p4rt.sh
+    -rwxr-xr-x. 1 admin12 admin12 8.4K Aug 28 13:37 acc_p4rt_delete.sh
+    -rwxr-xr-x. 1 admin12 admin12 2.0K Aug 28 13:37 4_acc_p4rt_dump.sh
+    -rwxr-xr-x. 1 admin12 admin12 1.3K Aug 28 13:37 5_acc_setup_ovs.sh
+    -rwxr-xr-x. 1 admin12 admin12 2.1K Aug 28 13:37 6_acc_ovs_bridge.sh
+    -rwxr-xr-x. 1 admin12 admin12 6.1K Aug 28 13:37 acc_ovs_vxlan.sh
+    -rwxr-xr-x. 1 admin12 admin12 2.8K Aug 28 13:37 7_host_vm.sh
+    ```
 
 3. copy_script: This will create the configuration scripts in the script directory (can be changes in **host_path** in **config.yaml**) at **ovs_offload/ovs_offload_lnw_scripts** and also copy it to the ACC to the acc_path field provided in the **config file:config.yaml**
 
-```bash
-> python ovs_offload_lnw.py copy_script
-```
+    ```bash
+    > python ovs_offload_lnw.py copy_script
+    ```
 
 4. setup:
 
-```bash
-> python ovs_offload_lnw.py setup
-```
+    ```bash
+    > python ovs_offload_lnw.py setup
+    ```
 
-- This will setup the complete OVS offload recipe.
-- Configure TMUX session - test1_infrap4d, login to ACC and launch infrap4d,
-- Configure TMUX session - test2_p4rt configure the p4rt-ctl rules, configure OVS bridges
-- Configure TMUX session - test3_host configure the VMs on Host IDPF interface and link partner.
-- Run a ping test to check the forwarding.
-- After running the setup option we can login to each of the tmux sessions.
+    - This will setup the complete OVS offload recipe.
+    - Configure TMUX session - test1_infrap4d, login to ACC and launch infrap4d,
+    - Configure TMUX session - test2_p4rt configure the p4rt-ctl rules, configure OVS bridges
+    - Configure TMUX session - test3_host configure the VMs on Host IDPF interface and link partner.
+    - Run a ping test to check the forwarding.
+    - After running the setup option we can login to each of the tmux sessions.
 
-```bash
-# tmux ls
-test1_infrap4d: 1 windows (created Thu Aug 29 12:35:25 2024)
-test2_p4rt: 1 windows (created Thu Aug 29 12:33:26 2024)
-test3_host: 1 windows (created Thu Aug 29 12:32:55 2024)
-```
-- Attach to a tmux session
+    ```bash
+    > tmux ls
+    test1_infrap4d: 1 windows (created Thu Aug 29 12:35:25 2024)
+    test2_p4rt: 1 windows (created Thu Aug 29 12:33:26 2024)
+    test3_host: 1 windows (created Thu Aug 29 12:32:55 2024)
+    ```
 
-```bash
-tmux a -t test2_p4rt
-```
-- Detach from inside a tmux session.
+    - Attach to a tmux session
 
-```bash
-ctrl+b d
-```
+    ```bash
+    tmux a -t test2_p4rt
+    ```
+    - Detach from inside a tmux session.
 
-4. teardown:
+    ```bash
+    ctrl+b d
+    ```
 
-```bash
-> python ovs_offload_lnw.py teardown
-```
+5. teardown:
 
-- This will teardown the complete OVS offload recipe.
-- Pre-Requisite: run copy_script option once for scripts to be available in ACC
-- Configure TMUX session - test3_host delete the VMs on Host and remove the link partner configuration.
-- Configure TMUX session - test2_p4rt delete the p4rt-ctl rules and delete the OVS bridges
-- Configure TMUX session - test1_infrap4d, login to ACC and stop infrap4d,
+    ```bash
+    > python ovs_offload_lnw.py teardown
+    ```
 
+    - This will teardown the complete OVS offload recipe.
+    - Pre-Requisite: run copy_script option once for scripts to be available in ACC
+    - Configure TMUX session - test3_host delete the VMs on Host and remove the link partner configuration.
+    - Configure TMUX session - test2_p4rt delete the p4rt-ctl rules and delete the OVS bridges
+    - Configure TMUX session - test1_infrap4d, login to ACC and stop infrap4d,
 
 ### ovs_offload_lnw_v3.py : (P4:fxp-net_linux-networking_v3.p4, IPU SDK Release 1.6.0, 1.6.1)
 
 1. This is a python script : **ovs_offload/ovs_offload_lnw_v3.py** that can be used with **P4: fxp-net_linux-networking_v3.p4** for release 1.6.0,1.6.1
 
-```bash
-> python ovs_offload_lnw_v3.py
-usage: ovs_offload_lnw_v3.py [-h] {create_script,copy_script,setup,teardown} ...
+    ```bash
+    > python ovs_offload_lnw_v3.py
+    usage: ovs_offload_lnw_v3.py [-h] {create_script,copy_script,setup,teardown} ...
 
-Run Linux networking V3 with OVS Offload
+    Run Linux networking V3 with OVS Offload
 
-positional arguments:
-  {create_script,copy_script,setup,teardown}
-                        options
-    create_script       Generate configuration scripts in localhost
-    copy_script         Copy configuration scripts to IMC and ACC
-    setup               Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for
-                        scripts to be available in ACC
-    teardown            Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once
-                        for scripts to be available in ACC
+    positional arguments:
+      {create_script,copy_script,setup,teardown}
+                            options
+        create_script       Generate configuration scripts in localhost
+        copy_script         Copy configuration scripts to IMC and ACC
+        setup               Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for
+                            scripts to be available in ACC
+        teardown            Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once
+                            for scripts to be available in ACC
 
-optional arguments:
-  -h, --help            show this help message and exit
-```
+    optional arguments:
+      -h, --help            show this help message and exit
+    ```
 
 ### ovs_offload_lnw_v2.py: (P4:fxp-net_linux-networking_v2.p4, IPU SDK Release 1.4.0)
 
 1. This is a python script : **ovs_offload/scripts/ovs_offload_lnw_v2.py** that can be used with **P4: fxp-net_linux-networking_v2.p4** for release 1.4.0
 
-```bash
-> python ovs_offload_lnw_v2.py
-usage: ovs_offload_lnw_v2.py [-h] {create_script,copy_script,setup,teardown} ...
+    ```bash
+    > python ovs_offload_lnw_v2.py
+    usage: ovs_offload_lnw_v2.py [-h] {create_script,copy_script,setup,teardown} ...
 
-Run Linux networking V2 with OVS Offload
+    Run Linux networking V2 with OVS Offload
 
-positional arguments:
-  {create_script,copy_script,setup,teardown}
-                        options
-    create_script       Generate configuration scripts in localhost
-    copy_script         Copy configuration scripts to IMC and ACC
-    setup               Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for
-                        scripts to be available in ACC
-    teardown            Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once
-                        for scripts to be available in ACC
+    positional arguments:
+      {create_script,copy_script,setup,teardown}
+                            options
+        create_script       Generate configuration scripts in localhost
+        copy_script         Copy configuration scripts to IMC and ACC
+        setup               Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for
+                            scripts to be available in ACC
+        teardown            Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once
+                            for scripts to be available in ACC
 
-optional arguments:
-  -h, --help            show this help message and exit
-```
+    optional arguments:
+      -h, --help            show this help message and exit
+    ```
 
 ## Use the Scripts on ACC to Setup OVS Offload
 
@@ -531,7 +532,6 @@ rtt min/avg/max/mdev = 0.040/0.048/0.058/0.007 ms
 
 ```
 
-
 ### OVS Offload VXLAN on 2 IPU Peers Connected back to back
 
 - Ideally OVS Offload with VXLAN can be run with 2 IPU Peer Setups connected back to back.
@@ -650,6 +650,7 @@ ovs-vsctl show
 ```bash
 [root@ipu-acc ~]# ctrl + c
 ```
+
 or
 
 ```bash

commit f7f2bfbe404e9a731db4f4144462dff26a13ec3b
Author: Naveen Ashok <naveen1.ashok@intel.com>
Date:   Tue Sep 10 13:01:44 2024 -0700

    [ovs offload] Update README with markdown lint fixes
    
    Signed-off-by: Naveen Ashok <naveen1.ashok@intel.com>

diff --git a/ovs_offload/README.md b/ovs_offload/README.md
index d9c7799..3042597 100644
--- a/ovs_offload/README.md
+++ b/ovs_offload/README.md
@@ -1,28 +1,29 @@
-# OVS Offload Scripts:
+# OVS Offload Scripts
 
-## Introduction:
+## Introduction
 
 - The ovs_offload_lnw.py script can be used on an host server connected with Intel速 Infrastructure Processing Unit via PCIe.
 - It creates the configuration to run the Linux Networking Recipe with OVS Offload on the ACC.
 - It can be used to start infrap4d on the ACC and use the script generated p4rt-ctl rules to configure ACC Port representors for the Host IDPF interfaces and IPU Physical Ports.
 - It can setup OVS bridges on the ACC using the port representors and configure VMs on the IDPF interfaces on the Host.
 
-## Test Environment Setup:
+## Test Environment Setup
 
 - Before running script check if ssh as a root user is enabled and root user password is setup for ssh.
-```
+
+```bash
 Check file /etc/ssh/sshd_config and change PermitRootLogin yes
 
 [root@athena ~]# grep -rn PermitRootLogin /etc/ssh/sshd_config
 40:PermitRootLogin yes
 ```
 
-### Pre-requisites:
+### Pre-requisites
 
 - The host package ``intel-ipu-host-components-<version>.<build number>.tar.gz`` contains the example IPU P4 source code, the compiled P4 package and artifacts that can be used to setup the workload on the IMC and ACC.
 - The compiled artifacts for P4 ``fxp-net_linux-networking`` can be found in below location after extracting the tar package.
 
-```
+```bash
 cd intel-ipu-host-components/P4Tools/P4Programs/artifacts/fxp-net_linux-networking
 
 > ls
@@ -43,7 +44,7 @@ total 6.2M
 
 - Make sure the same version of IDPF driver is loaded on the Host, IMC and ACC, run commands below as a root user
 
-```
+```bash
 sudo -i
 modprobe idpf
 lsmod | grep idpf
@@ -51,9 +52,9 @@ modinfo idpf
 echo 8 > /sys/class/net/ens5f0/device/sriov_numvfs
 ```
 - Replace `ens5f0` above with the correct Host IDPF Interface to create 8 SR-IOV VFs on the Host.
-
 - The tool uses tmux session when running the option setup and option teardown. Install TMUX on the IPU Host.
-```
+
+```bash
 Ubuntu/Debian.
 sudo apt-get update && sudo apt-get -y install tmux
 
@@ -66,17 +67,17 @@ usage: tmux [-2CDlNuvV] [-c shell-command] [-f file] [-L socket-name]
             [-S socket-path] [-T features] [command [flags]]
 ```
 
-### Test Config:
+### Test Configuration config.yaml
 
 - Update yaml file config.yaml for the specific test setup, change the management IP, username and password for imc and acc if it is different.
 - Update the test_params section as required for the setup with the correct host, imc and acc script paths.
 - Update the idpf_interface, vf_interfaces, acc_pr_interfaces and ip_list as required to scale up or scale down on the number of interface configuration generated by the script. More information on the fields in the comments below.
 
-```
+```bash
 > cd networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload
 ```
 
-```
+```bash
 > cat config.yaml
 host:
   ssh:
@@ -124,16 +125,18 @@ test_params:
     remote_br_tun_ip: ['1.1.1.2','2.1.1.2']
 ```
 
-## Python Environment Setup:
+## Python Environment Setup
 
 - Use python venv:
-```
+
+```bash
 cd networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload
 python -m venv --copies venv
 ```
 
 - Activate the venv and install requirements:
-```
+
+```bash
 # source venv/bin/activate
 (venv)# pip install -r requirements.txt
 (venv)# deactivate
@@ -141,23 +144,25 @@ python -m venv --copies venv
 
 ### requirements.txt
 
-```
+```text
 PyYAML
 ```
 
 - Run python script **ovs_offload_lnw.py** as a root user.
-```
+
+```bash
 sudo -i
 cd networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload
 source venv/bin/activate
 ```
 
-## Test Script:
+## Test Script
 
 ### ovs_offload_lnw.py : (P4:fxp-net_linux-networking.p4, IPU SDK Release >= 1.7.0)
 
 1. This is a python script : **ovs_offload/ovs_offload_lnw.py** that can be used with **P4: fxp-net_linux-networking.p4** for release 1.7.0 and later
-```
+
+```bash
 > python ovs_offload_lnw.py
 usage: ovs_offload_lnw.py [-h] {create_script,copy_script,setup,teardown} ...
 
@@ -178,12 +183,14 @@ optional arguments:
 ```
 
 2. create_script: This will create the configuration scripts in the script directory (can be changes in **host_path** in **config.yaml**) at **ovs_offload/ovs_offload_lnw_scripts**
-```
+
+```bash
 > python ovs_offload_lnw.py create_script
 ```
 
 The scripts will be created as shown below.
-```
+
+```bash
 > ls networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload/ovs_offload_lnw_scripts/
 total 60K
 -rwxr-xr-x. 1 admin12 admin12 1.6K Aug 28 13:37 es2k_skip_p4.conf
@@ -199,41 +206,47 @@ total 60K
 ```
 
 3. copy_script: This will create the configuration scripts in the script directory (can be changes in **host_path** in **config.yaml**) at **ovs_offload/ovs_offload_lnw_scripts** and also copy it to the ACC to the acc_path field provided in the **config file:config.yaml**
-```
+
+```bash
 > python ovs_offload_lnw.py copy_script
 ```
 
 4. setup:
 
-```
+```bash
 > python ovs_offload_lnw.py setup
 ```
+
 - This will setup the complete OVS offload recipe.
 - Configure TMUX session - test1_infrap4d, login to ACC and launch infrap4d,
 - Configure TMUX session - test2_p4rt configure the p4rt-ctl rules, configure OVS bridges
 - Configure TMUX session - test3_host configure the VMs on Host IDPF interface and link partner.
 - Run a ping test to check the forwarding.
 - After running the setup option we can login to each of the tmux sessions.
-```
+
+```bash
 # tmux ls
 test1_infrap4d: 1 windows (created Thu Aug 29 12:35:25 2024)
 test2_p4rt: 1 windows (created Thu Aug 29 12:33:26 2024)
 test3_host: 1 windows (created Thu Aug 29 12:32:55 2024)
 ```
 - Attach to a tmux session
-```
+
+```bash
 tmux a -t test2_p4rt
 ```
 - Detach from inside a tmux session.
-```
+
+```bash
 ctrl+b d
 ```
 
 4. teardown:
 
-```
+```bash
 > python ovs_offload_lnw.py teardown
 ```
+
 - This will teardown the complete OVS offload recipe.
 - Pre-Requisite: run copy_script option once for scripts to be available in ACC
 - Configure TMUX session - test3_host delete the VMs on Host and remove the link partner configuration.
@@ -244,7 +257,8 @@ ctrl+b d
 ### ovs_offload_lnw_v3.py : (P4:fxp-net_linux-networking_v3.p4, IPU SDK Release 1.6.0, 1.6.1)
 
 1. This is a python script : **ovs_offload/ovs_offload_lnw_v3.py** that can be used with **P4: fxp-net_linux-networking_v3.p4** for release 1.6.0,1.6.1
-```
+
+```bash
 > python ovs_offload_lnw_v3.py
 usage: ovs_offload_lnw_v3.py [-h] {create_script,copy_script,setup,teardown} ...
 
@@ -267,7 +281,8 @@ optional arguments:
 ### ovs_offload_lnw_v2.py: (P4:fxp-net_linux-networking_v2.p4, IPU SDK Release 1.4.0)
 
 1. This is a python script : **ovs_offload/scripts/ovs_offload_lnw_v2.py** that can be used with **P4: fxp-net_linux-networking_v2.p4** for release 1.4.0
-```
+
+```bash
 > python ovs_offload_lnw_v2.py
 usage: ovs_offload_lnw_v2.py [-h] {create_script,copy_script,setup,teardown} ...
 
@@ -287,11 +302,12 @@ optional arguments:
   -h, --help            show this help message and exit
 ```
 
-## Use the Scripts on ACC to Setup OVS Offload :
+## Use the Scripts on ACC to Setup OVS Offload
 
 - Follow the instructions below to run the Recipe on the ACC with the help of configuration scripts or.
 - Run the tool with setup option.
-```
+
+```bash
 > python ovs_offload_lnw.py setup
 ```
 
@@ -299,30 +315,32 @@ optional arguments:
 
 - The scripts expect the P4 artifacts are available in the folder below in the ACC, make sure to copy the correct artifacts for the release. Example given below for P4: fxp-net_linux-networking.p4 for release 1.7.0, for Release 1.6.0 use P4: fxp-net_linux-networking_v3.p4 artifacts and for Release 1.4.0 use P4: fxp-net_linux-networking_v2.p4
 
-```
+```bash
 [root@ipu-acc ~]# ls /opt/p4/p4sde/p4_test/fxp-net_linux-networking
 ```
 
 ### 2. Infrap4d Configuration file
 
 - Copy the infrap4d config in **/opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts/es2k_skip_p4.conf** to artifact folder **/opt/p4/p4sde/p4_test/fxp-net_linux-networking** in the ACC
-```
+
+```bash
 [root@ipu-acc ~]# cp /opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts/es2k_skip_p4.conf /opt/p4/p4sde/p4_test/fxp-net_linux-networking/
 ```
 
 ### 3. Start Infrap4d
 
 - Use the ovs_offload_lnw_scripts in the ACC to setup infrap4d, p4rt and OVS bridge:
-
 - ACC Terminal 1 : Setup environment and start Infrap4d
-```
+
+```bash
 [root@ipu-acc ~]# cd /opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
 [root@ipu-acc ovs_offload_lnw_scripts]# ./2_acc_infrap4d.sh
 ```
 
 - Wait for infrap4d to initialize and start listening on the server.
-```
+
+```bash
 Initialized lld_cpchnl control path
 Fetching VF info
 ................
@@ -347,7 +365,8 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 ### 3. Setup p4rt-ctl pipe and add the ACC PR rules
 
 - ACC Terminal 2 : Setup p4rt-ctl pipeline and setup the runtime rules.
-```
+
+```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
 /opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
@@ -355,7 +374,8 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 ```
 
 - ACC Terminal 2 : Dump the p4rt-ctl runtime rules.
-```
+
+```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
 /opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
@@ -365,7 +385,8 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 ### 4. Setup ACC environment for OVS
 
 - ACC Terminal 2 : Setup the OVS Environment.
-```
+
+```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
 /opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
@@ -375,23 +396,26 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 ### 5. Setup OVS Bridge Configuration
 
 - ACC Terminal 2 : Setup the OVS Bridge Config
-```
+
+```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
 /opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
 [root@ipu-acc ovs_offload_lnw_scripts]# ./6_acc_ovs_bridge.sh
 ```
 
-### 6. Setup VMs on the IPU Host and configure link partner interface:
+### 6. Setup VMs on the IPU Host and configure link partner interface
 
 - IPU HOST Terminal 1 : Configure the VMs on the IPU Host the script below uses **ip netns**
-```
+
+```bash
 [root@host]# cd ovs_offload/scripts/ovs_offload_lnw_scripts
 [root@host]# ./7_host_vm.sh
 ```
 
 - Configure IP to the Link Partner Interface and Test Ping to the Host IDPF VF interfaces in the VMs.
-```
+
+```bash
 # Link Partner connected to IPU Port 0
 sudo ip a a dev ens7f1 10.0.0.30/24
 
@@ -413,7 +437,8 @@ ip netns exec VM4 ping 20.0.0.30
 ### 7. Optional: Setup OVS Bridge for VXLAN
 
 - This configuration script will setup OVS VXLAN Bridges.
-```
+
+```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
 /opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
@@ -421,12 +446,14 @@ ip netns exec VM4 ping 20.0.0.30
 ```
 
 - Stop firewalld on IPU Host and the ACC
-```
+
+```bash
 systemctl stop firewalld
 ```
 
 - Run simple script below to configure VXLAN on the Link Partner Connected to Port 0:
-```
+
+```bash
 #!/bin/sh
 
 echo "Set up Tunnel End Point and the Vxlan config on the Link Partner on remote host"
@@ -464,7 +491,7 @@ echo "Verify the Configure interfaces"
 
 - Run a Ping Test
 
-```
+```bash
 [root@host ovs_offload_lnw_scripts]# ip netns exec VM0 ip -br a
 lo               DOWN
 ens5f0v0         UP             10.0.0.10/24 fe80::21a:ff:fe00:314/64
@@ -505,12 +532,13 @@ rtt min/avg/max/mdev = 0.040/0.048/0.058/0.007 ms
 ```
 
 
-### OVS Offload VXLAN on 2 IPU Peers Connected back to back:
+### OVS Offload VXLAN on 2 IPU Peers Connected back to back
 
 - Ideally OVS Offload with VXLAN can be run with 2 IPU Peer Setups connected back to back.
 - Run python script **ovs_offload_lnw.py** as a root user on the 2 peer IPU Hosts to generate the configuration.
 - Update the config.yaml for OVS VXLAN for IPU 1 Setup.
-```
+
+```bash
 > cat config.yaml
 test_params:
 ....
@@ -525,8 +553,10 @@ test_params:
     remote_br_tun_ip: ['1.1.1.2','2.1.1.2']
 
 ```
+
 - Update config.yaml for OVS VXLAN Config for IPU 2 Setup.
-```
+
+```bash
 > cat config.yaml
 test_params:
 ....
@@ -548,14 +578,16 @@ test_params:
 ### Optional:  Clean up the configs
 
 - Run the tool with option **teardown**
-```
+
+```bash
 > python ovs_offload_lnw.py teardown
 ```
 
 or
 
 - IPU HOST Terminal 1: Delete the VMs created on the IPU Host
-```
+
+```bash
 ip netns del VM0
 ip netns del VM1
 ip netns del VM2
@@ -567,7 +599,8 @@ ip netns del VM7
 ```
 
 - ACC Terminal 2 : Delete the OVS Bridge Config on the ACC
-```
+
+```bash
 #!/bin/sh
 export SDE_INSTALL=/opt/p4/p4sde
 export P4CP_INSTALL=/opt/p4/p4-cp-nws
@@ -602,7 +635,8 @@ ovs-vsctl show
 ```
 
 - ACC Terminal 2: Delete the p4rt-ctl runtime rules
-```
+
+```bash
 [root@ipu-acc ovs_offload_lnw_scripts]# pwd
 /opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
@@ -612,11 +646,13 @@ ovs-vsctl show
 ```
 
 - ACC Terminal 1: Terminate the infrap4d
-```
+
+```bash
 [root@ipu-acc ~]# ctrl + c
 ```
 or
-```
+
+```bash
 [root@ipu-acc ~]# ps -aux | grep infrap4d
 root       11120  0.0  0.0   4392  3156 pts/0    S+   00:45   0:00 /bin/sh ./2_acc_infrap4d.sh
 root       11188  0.4  0.5 70305376 81572 pts/0  SLl+ 00:45   1:00 /opt/p4/p4-cp-nws/sbin/infrap4d --nodetach

commit ac96f296eefc60c6cbcef98164bc62d1bad215b6
Author: Naveen Ashok <naveen1.ashok@intel.com>
Date:   Thu Sep 5 13:08:28 2024 -0700

    [ovs offload] Minor updates to README
    
    Signed-off-by: Naveen Ashok <naveen1.ashok@intel.com>

diff --git a/ovs_offload/README.md b/ovs_offload/README.md
index 49dab7c..d9c7799 100644
--- a/ovs_offload/README.md
+++ b/ovs_offload/README.md
@@ -4,7 +4,7 @@
 
 - The ovs_offload_lnw.py script can be used on an host server connected with Intel速 Infrastructure Processing Unit via PCIe.
 - It creates the configuration to run the Linux Networking Recipe with OVS Offload on the ACC.
-- It can be used to start infrap4d on the ACC and use the script generated p4rt-ctl rules to configure ACC Port representors for the Host IDPF interfaces and IPU Physical Ports. 
+- It can be used to start infrap4d on the ACC and use the script generated p4rt-ctl rules to configure ACC Port representors for the Host IDPF interfaces and IPU Physical Ports.
 - It can setup OVS bridges on the ACC using the port representors and configure VMs on the IDPF interfaces on the Host.
 
 ## Test Environment Setup:
@@ -156,7 +156,7 @@ source venv/bin/activate
 
 ### ovs_offload_lnw.py : (P4:fxp-net_linux-networking.p4, IPU SDK Release >= 1.7.0)
 
-1. This is a python script : **ovs_offload/ovs_offload_lnw.py** that can be used with **P4: fxp-net_linux-networking.p4** for release 1.7.0
+1. This is a python script : **ovs_offload/ovs_offload_lnw.py** that can be used with **P4: fxp-net_linux-networking.p4** for release 1.7.0 and later
 ```
 > python ovs_offload_lnw.py
 usage: ovs_offload_lnw.py [-h] {create_script,copy_script,setup,teardown} ...

commit 2a92ef1d6c10ca17a30ece322552f2a043f15cd3
Author: Naveen Ashok <naveen1.ashok@intel.com>
Date:   Thu Sep 5 11:57:33 2024 -0700

    [ovs offload] script name change ovs_offload_lnv.py to ovs_offload_lnw.py
    
    Signed-off-by: Naveen Ashok <naveen1.ashok@intel.com>

diff --git a/ovs_offload/README.md b/ovs_offload/README.md
index 29d0102..49dab7c 100644
--- a/ovs_offload/README.md
+++ b/ovs_offload/README.md
@@ -2,9 +2,10 @@
 
 ## Introduction:
 
-The tool ovs_offload_lnv.py can be used to generate the workload configuration scripts to run the Linux Networking Recipe with OVS Offload.
-The configuration scripts can be used to start infrap4d on the ACC, use the script generated p4rt-ctl rules to configure ACC Port representors,
-configure OVS and create OVS bridges and configure VMs on the IDPF interfaces on the Host.
+- The ovs_offload_lnw.py script can be used on an host server connected with Intel速 Infrastructure Processing Unit via PCIe.
+- It creates the configuration to run the Linux Networking Recipe with OVS Offload on the ACC.
+- It can be used to start infrap4d on the ACC and use the script generated p4rt-ctl rules to configure ACC Port representors for the Host IDPF interfaces and IPU Physical Ports. 
+- It can setup OVS bridges on the ACC using the port representors and configure VMs on the IDPF interfaces on the Host.
 
 ## Test Environment Setup:
 
@@ -102,7 +103,7 @@ acc:
 
 test_params:
     #path fields specify the location where the configuration scripts will be copied to on the Host,IMC and ACC
-    host_path: 'lnv_ovs_scripts'
+    host_path: 'ovs_offload_lnw_scripts'
     imc_path: '/mnt/imc/p4_test'
     acc_path:  '/opt/p4/p4sde/p4_test'
     # Update the correct IDPF Interface on the Host
@@ -144,7 +145,7 @@ python -m venv --copies venv
 PyYAML
 ```
 
-- Run python script **ovs_offload_lnv.py** as a root user.
+- Run python script **ovs_offload_lnw.py** as a root user.
 ```
 sudo -i
 cd networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload
@@ -153,12 +154,12 @@ source venv/bin/activate
 
 ## Test Script:
 
-### ovs_offload_lnv.py : (P4:fxp-net_linux-networking.p4, IPU SDK Release >= 1.7.0)
+### ovs_offload_lnw.py : (P4:fxp-net_linux-networking.p4, IPU SDK Release >= 1.7.0)
 
-1. This is a python script : **ovs_offload/ovs_offload_lnv.py** that can be used with **P4: fxp-net_linux-networking.p4** for release 1.7.0
+1. This is a python script : **ovs_offload/ovs_offload_lnw.py** that can be used with **P4: fxp-net_linux-networking.p4** for release 1.7.0
 ```
-> python ovs_offload_lnv.py
-usage: ovs_offload_lnv.py [-h] {create_script,copy_script,setup,teardown} ...
+> python ovs_offload_lnw.py
+usage: ovs_offload_lnw.py [-h] {create_script,copy_script,setup,teardown} ...
 
 Run Linux networking with OVS Offload
 
@@ -176,14 +177,14 @@ optional arguments:
   -h, --help            show this help message and exit
 ```
 
-2. create_script: This will create the configuration scripts in the script directory (can be changes in **host_path** in **config.yaml**) at **ovs_offload/lnv_ovs_scripts**
+2. create_script: This will create the configuration scripts in the script directory (can be changes in **host_path** in **config.yaml**) at **ovs_offload/ovs_offload_lnw_scripts**
 ```
-> python ovs_offload_lnv.py create_script
+> python ovs_offload_lnw.py create_script
 ```
 
 The scripts will be created as shown below.
 ```
-> ls networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload/lnv_ovs_scripts/
+> ls networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload/ovs_offload_lnw_scripts/
 total 60K
 -rwxr-xr-x. 1 admin12 admin12 1.6K Aug 28 13:37 es2k_skip_p4.conf
 -rwxr-xr-x. 1 admin12 admin12  375 Aug 28 13:37 1_host_idpf.sh
@@ -197,15 +198,15 @@ total 60K
 -rwxr-xr-x. 1 admin12 admin12 2.8K Aug 28 13:37 7_host_vm.sh
 ```
 
-3. copy_script: This will create the configuration scripts in the script directory (can be changes in **host_path** in **config.yaml**) at **ovs_offload/lnv_ovs_scripts** and also copy it to the ACC to the acc_path field provided in the **config file:config.yaml**
+3. copy_script: This will create the configuration scripts in the script directory (can be changes in **host_path** in **config.yaml**) at **ovs_offload/ovs_offload_lnw_scripts** and also copy it to the ACC to the acc_path field provided in the **config file:config.yaml**
 ```
-> python ovs_offload_lnv.py copy_script
+> python ovs_offload_lnw.py copy_script
 ```
 
 4. setup:
 
 ```
-> python ovs_offload_lnv.py setup
+> python ovs_offload_lnw.py setup
 ```
 - This will setup the complete OVS offload recipe.
 - Configure TMUX session - test1_infrap4d, login to ACC and launch infrap4d,
@@ -231,7 +232,7 @@ ctrl+b d
 4. teardown:
 
 ```
-> python ovs_offload_lnv.py teardown
+> python ovs_offload_lnw.py teardown
 ```
 - This will teardown the complete OVS offload recipe.
 - Pre-Requisite: run copy_script option once for scripts to be available in ACC
@@ -240,14 +241,14 @@ ctrl+b d
 - Configure TMUX session - test1_infrap4d, login to ACC and stop infrap4d,
 
 
-### ovs_offload_lnv3.py : (P4:fxp-net_linux-networking_v3.p4, IPU SDK Release 1.6.0, 1.6.1)
+### ovs_offload_lnw_v3.py : (P4:fxp-net_linux-networking_v3.p4, IPU SDK Release 1.6.0, 1.6.1)
 
-1. This is a python script : **ovs_offload/ovs_offload_lnv3.py** that can be used with **P4: fxp-net_linux-networking_v3.p4** for release 1.6.0,1.6.1
+1. This is a python script : **ovs_offload/ovs_offload_lnw_v3.py** that can be used with **P4: fxp-net_linux-networking_v3.p4** for release 1.6.0,1.6.1
 ```
-> python ovs_offload_lnv3.py
-usage: ovs_offload_lnv3.py [-h] {create_script,copy_script,setup,teardown} ...
+> python ovs_offload_lnw_v3.py
+usage: ovs_offload_lnw_v3.py [-h] {create_script,copy_script,setup,teardown} ...
 
-Run Linux networking with OVS Offload
+Run Linux networking V3 with OVS Offload
 
 positional arguments:
   {create_script,copy_script,setup,teardown}
@@ -263,14 +264,14 @@ optional arguments:
   -h, --help            show this help message and exit
 ```
 
-### ovs_offload_lnv2.py: (P4:fxp-net_linux-networking_v2.p4, IPU SDK Release 1.4.0)
+### ovs_offload_lnw_v2.py: (P4:fxp-net_linux-networking_v2.p4, IPU SDK Release 1.4.0)
 
-1. This is a python script : **ovs_offload/scripts/ovs_offload_lnv2.py** that can be used with **P4: fxp-net_linux-networking_v2.p4** for release 1.4.0
+1. This is a python script : **ovs_offload/scripts/ovs_offload_lnw_v2.py** that can be used with **P4: fxp-net_linux-networking_v2.p4** for release 1.4.0
 ```
-> python ovs_offload_lnv2.py
-usage: ovs_offload_lnv2.py [-h] {create_script,copy_script,setup,teardown} ...
+> python ovs_offload_lnw_v2.py
+usage: ovs_offload_lnw_v2.py [-h] {create_script,copy_script,setup,teardown} ...
 
-Run Linux networking with OVS Offload
+Run Linux networking V2 with OVS Offload
 
 positional arguments:
   {create_script,copy_script,setup,teardown}
@@ -291,7 +292,7 @@ optional arguments:
 - Follow the instructions below to run the Recipe on the ACC with the help of configuration scripts or.
 - Run the tool with setup option.
 ```
-> python ovs_offload_lnv.py setup
+> python ovs_offload_lnw.py setup
 ```
 
 ### 1. IPU P4 Artifacts on ACC
@@ -304,20 +305,20 @@ optional arguments:
 
 ### 2. Infrap4d Configuration file
 
-- Copy the infrap4d config in **/opt/p4/p4sde/p4_test/lnv_ovs_scripts/es2k_skip_p4.conf** to artifact folder **/opt/p4/p4sde/p4_test/fxp-net_linux-networking** in the ACC
+- Copy the infrap4d config in **/opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts/es2k_skip_p4.conf** to artifact folder **/opt/p4/p4sde/p4_test/fxp-net_linux-networking** in the ACC
 ```
-[root@ipu-acc ~]# cp /opt/p4/p4sde/p4_test/lnv_ovs_scripts/es2k_skip_p4.conf /opt/p4/p4sde/p4_test/fxp-net_linux-networking/
+[root@ipu-acc ~]# cp /opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts/es2k_skip_p4.conf /opt/p4/p4sde/p4_test/fxp-net_linux-networking/
 ```
 
 ### 3. Start Infrap4d
 
-- Use the lnv_ovs_scripts in the ACC to setup infrap4d, p4rt and OVS bridge:
+- Use the ovs_offload_lnw_scripts in the ACC to setup infrap4d, p4rt and OVS bridge:
 
 - ACC Terminal 1 : Setup environment and start Infrap4d
 ```
-[root@ipu-acc ~]# cd /opt/p4/p4sde/p4_test/lnv_ovs_scripts
+[root@ipu-acc ~]# cd /opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
-[root@ipu-acc lnv_ovs_scripts]# ./2_acc_infrap4d.sh
+[root@ipu-acc ovs_offload_lnw_scripts]# ./2_acc_infrap4d.sh
 ```
 
 - Wait for infrap4d to initialize and start listening on the server.
@@ -347,45 +348,45 @@ E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external
 
 - ACC Terminal 2 : Setup p4rt-ctl pipeline and setup the runtime rules.
 ```
-[root@ipu-acc lnv_ovs_scripts]# pwd
-/opt/p4/p4sde/p4_test/lnv_ovs_scripts
+[root@ipu-acc ovs_offload_lnw_scripts]# pwd
+/opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
-[root@ipu-acc lnv_ovs_scripts]# ./3_acc_p4rt.sh
+[root@ipu-acc ovs_offload_lnw_scripts]# ./3_acc_p4rt.sh
 ```
 
 - ACC Terminal 2 : Dump the p4rt-ctl runtime rules.
 ```
-[root@ipu-acc lnv_ovs_scripts]# pwd
-/opt/p4/p4sde/p4_test/lnv_ovs_scripts
+[root@ipu-acc ovs_offload_lnw_scripts]# pwd
+/opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
-[root@ipu-acc lnv_ovs_scripts]# ./4_acc_p4rt_dump.sh
+[root@ipu-acc ovs_offload_lnw_scripts]# ./4_acc_p4rt_dump.sh
 ```
 
 ### 4. Setup ACC environment for OVS
 
 - ACC Terminal 2 : Setup the OVS Environment.
 ```
-[root@ipu-acc lnv_ovs_scripts]# pwd
-/opt/p4/p4sde/p4_test/lnv_ovs_scripts
+[root@ipu-acc ovs_offload_lnw_scripts]# pwd
+/opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
-[root@ipu-acc lnv_ovs_scripts]# ./5_acc_setup_ovs.sh
+[root@ipu-acc ovs_offload_lnw_scripts]# ./5_acc_setup_ovs.sh
 ```
 
 ### 5. Setup OVS Bridge Configuration
 
 - ACC Terminal 2 : Setup the OVS Bridge Config
 ```
-[root@ipu-acc lnv_ovs_scripts]# pwd
-/opt/p4/p4sde/p4_test/lnv_ovs_scripts
+[root@ipu-acc ovs_offload_lnw_scripts]# pwd
+/opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
-[root@ipu-acc lnv_ovs_scripts]# ./6_acc_ovs_bridge.sh
+[root@ipu-acc ovs_offload_lnw_scripts]# ./6_acc_ovs_bridge.sh
 ```
 
 ### 6. Setup VMs on the IPU Host and configure link partner interface:
 
 - IPU HOST Terminal 1 : Configure the VMs on the IPU Host the script below uses **ip netns**
 ```
-[root@host]# cd ovs_offload/scripts/lnv_ovs_scripts
+[root@host]# cd ovs_offload/scripts/ovs_offload_lnw_scripts
 [root@host]# ./7_host_vm.sh
 ```
 
@@ -413,10 +414,10 @@ ip netns exec VM4 ping 20.0.0.30
 
 - This configuration script will setup OVS VXLAN Bridges.
 ```
-[root@ipu-acc lnv_ovs_scripts]# pwd
-/opt/p4/p4sde/p4_test/lnv_ovs_scripts
+[root@ipu-acc ovs_offload_lnw_scripts]# pwd
+/opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
-[root@ipu-acc lnv_ovs_scripts]# ./acc_ovs_vxlan.sh
+[root@ipu-acc ovs_offload_lnw_scripts]# ./acc_ovs_vxlan.sh
 ```
 
 - Stop firewalld on IPU Host and the ACC
@@ -464,11 +465,11 @@ echo "Verify the Configure interfaces"
 - Run a Ping Test
 
 ```
-[root@host lnv_ovs_scripts]# ip netns exec VM0 ip -br a
+[root@host ovs_offload_lnw_scripts]# ip netns exec VM0 ip -br a
 lo               DOWN
 ens5f0v0         UP             10.0.0.10/24 fe80::21a:ff:fe00:314/64
 
-[root@host lnv_ovs_scripts]# ip -br a
+[root@host ovs_offload_lnw_scripts]# ip -br a
 lo               UNKNOWN        127.0.0.1/8 ::1/128
 eno8303          UP             10.232.27.29/23 fe80::c6cb:e1ff:fea7:3c82/64
 eno8403          UP             100.0.0.1/24
@@ -481,7 +482,7 @@ ens5f0d3         UP
 TEP10            UNKNOWN        10.1.1.2/24 fe80::fcf2:f4ff:fe2a:18f4/64
 vxlan10          UNKNOWN        10.0.0.30/24 fe80::7c76:4ff:fe03:8591/64
 
-[root@host lnv_ovs_scripts]# ip netns exec VM0 ping 10.0.0.30
+[root@host ovs_offload_lnw_scripts]# ip netns exec VM0 ping 10.0.0.30
 PING 10.0.0.30 (10.0.0.30) 56(84) bytes of data.
 64 bytes from 10.0.0.30: icmp_seq=1 ttl=64 time=0.072 ms
 64 bytes from 10.0.0.30: icmp_seq=2 ttl=64 time=0.047 ms
@@ -491,7 +492,7 @@ PING 10.0.0.30 (10.0.0.30) 56(84) bytes of data.
 3 packets transmitted, 3 received, 0% packet loss, time 2028ms
 rtt min/avg/max/mdev = 0.041/0.053/0.072/0.013 ms
 
-[root@host lnv_ovs_scripts]# ping 10.0.0.10
+[root@host ovs_offload_lnw_scripts]# ping 10.0.0.10
 PING 10.0.0.10 (10.0.0.10) 56(84) bytes of data.
 64 bytes from 10.0.0.10: icmp_seq=1 ttl=64 time=0.058 ms
 64 bytes from 10.0.0.10: icmp_seq=2 ttl=64 time=0.046 ms
@@ -507,7 +508,7 @@ rtt min/avg/max/mdev = 0.040/0.048/0.058/0.007 ms
 ### OVS Offload VXLAN on 2 IPU Peers Connected back to back:
 
 - Ideally OVS Offload with VXLAN can be run with 2 IPU Peer Setups connected back to back.
-- Run python script **ovs_offload_lnv.py** as a root user on the 2 peer IPU Hosts to generate the configuration.
+- Run python script **ovs_offload_lnw.py** as a root user on the 2 peer IPU Hosts to generate the configuration.
 - Update the config.yaml for OVS VXLAN for IPU 1 Setup.
 ```
 > cat config.yaml
@@ -548,7 +549,7 @@ test_params:
 
 - Run the tool with option **teardown**
 ```
-> python ovs_offload_lnv.py teardown
+> python ovs_offload_lnw.py teardown
 ```
 
 or
@@ -602,12 +603,12 @@ ovs-vsctl show
 
 - ACC Terminal 2: Delete the p4rt-ctl runtime rules
 ```
-[root@ipu-acc lnv_ovs_scripts]# pwd
-/opt/p4/p4sde/p4_test/lnv_ovs_scripts
+[root@ipu-acc ovs_offload_lnw_scripts]# pwd
+/opt/p4/p4sde/p4_test/ovs_offload_lnw_scripts
 
-[root@ipu-acc lnv_ovs_scripts]# ./acc_p4rt_delete.sh
+[root@ipu-acc ovs_offload_lnw_scripts]# ./acc_p4rt_delete.sh
 
-[root@ipu-acc lnv_ovs_scripts]# ./4_acc_p4rt_dump.sh
+[root@ipu-acc ovs_offload_lnw_scripts]# ./4_acc_p4rt_dump.sh
 ```
 
 - ACC Terminal 1: Terminate the infrap4d
diff --git a/ovs_offload/common/utils.py b/ovs_offload/common/utils.py
index a8c9b2c..0009ad1 100644
--- a/ovs_offload/common/utils.py
+++ b/ovs_offload/common/utils.py
@@ -63,7 +63,7 @@ def ssh_command(server_name, command, output=True, check_returncode=True):
     return {'rc': 0, 'output': output}
 
 
-def copy_scripts(host_path='lnv_ovs_scripts', imc_path = '/mnt/imc/p4_test', acc_path = '/opt/p4/p4sde/p4_test'):
+def copy_scripts(host_path='ovs_offload_lnw_scripts', imc_path = '/mnt/imc/p4_test', acc_path = '/opt/p4/p4sde/p4_test'):
     """
     Copies configuration scripts from the host to the IMC and then to the ACC.
 
@@ -87,7 +87,6 @@ def copy_scripts(host_path='lnv_ovs_scripts', imc_path = '/mnt/imc/p4_test', acc
         print(f"Failed with exception:\n{e}")
 
     # Copy the configuration scripts from host to IMC
-    #command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {host_path}  root@100.0.0.100:{imc_path}/'
     command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {host_path}  root@{imc_ip}:{imc_path}/'
     try:
         result = ssh_command('host', command)
@@ -101,7 +100,6 @@ def copy_scripts(host_path='lnv_ovs_scripts', imc_path = '/mnt/imc/p4_test', acc
         print(f"Failed with exception:\n{e}")
 
     # Copy the configuration scripts from IMC to ACC
-    #command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {imc_path}/{host_path} root@192.168.0.2:{acc_path}/'
     command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {imc_path}/{host_path} root@{acc_ip}:{acc_path}/'
     try:
         result = ssh_command('imc', command)
@@ -215,9 +213,7 @@ def ping_test(dst_ip, count=4, vm = None):
     else:
         cmd = f"ping {dst_ip} -c {count}"
     try:
-        #result = ssh_command('host', cmd)
         result = run_cmd(cmd, output=True)
-        #print(f"cmd:{cmd}")
         pkt_loss = 100
         if result:
             match = re.search('(\d*)% packet loss', result)
diff --git a/ovs_offload/config.yaml b/ovs_offload/config.yaml
index 6acfc23..b6ca5ea 100644
--- a/ovs_offload/config.yaml
+++ b/ovs_offload/config.yaml
@@ -23,7 +23,7 @@ acc:
 
 test_params:
     #path fields specify the location where the configuration scripts will be copied to on the Host,IMC and ACC
-    host_path: 'lnv_ovs_scripts'
+    host_path: 'ovs_offload_lnw_scripts'
     imc_path: '/mnt/imc/p4_test'
     acc_path:  '/opt/p4/p4sde/p4_test'
     # Update the correct IDPF Interface on the Host
diff --git a/ovs_offload/ovs_offload_lnv.py b/ovs_offload/ovs_offload_lnw.py
similarity index 99%
rename from ovs_offload/ovs_offload_lnv.py
rename to ovs_offload/ovs_offload_lnw.py
index a2be5a0..1dd9828 100755
--- a/ovs_offload/ovs_offload_lnv.py
+++ b/ovs_offload/ovs_offload_lnw.py
@@ -94,8 +94,6 @@ ovs-vsctl add-port br-tun-{vf_list[i]} {acc_pr_list[i]}
         else:
             vf = get_interface_info(server_name='host', interface_name=vf_list[i])
             acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
-            #print(vf)
-            #print(acc_pr)
             vf_to_acc += f"""echo ""
 echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']})  PORT ({vf['port']}) maps to"
 echo "ACC  IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
diff --git a/ovs_offload/ovs_offload_lnv2.py b/ovs_offload/ovs_offload_lnw_v2.py
similarity index 99%
rename from ovs_offload/ovs_offload_lnv2.py
rename to ovs_offload/ovs_offload_lnw_v2.py
index 56da35b..bc954a9 100755
--- a/ovs_offload/ovs_offload_lnv2.py
+++ b/ovs_offload/ovs_offload_lnw_v2.py
@@ -94,8 +94,6 @@ ovs-vsctl add-port br-tun-{vf_list[i]} {acc_pr_list[i]}
         else:
             vf = get_interface_info(server_name='host', interface_name=vf_list[i])
             acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
-            #print(vf)
-            #print(acc_pr)
             vf_to_acc += f"""echo ""
 echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']})  PORT ({vf['port']}) maps to"
 echo "ACC  IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
@@ -563,7 +561,7 @@ EOF
 
 def build_args():
     # Create the top-level parser
-    parser = argparse.ArgumentParser(description='Run Linux networking with OVS Offload')
+    parser = argparse.ArgumentParser(description='Run Linux networking V2 with OVS Offload')
     subparsers = parser.add_subparsers(dest='command', help='options')
     # Create the parser for the "create_script" command
     parser_create_script = subparsers.add_parser('create_script', help='Generate configuration scripts in localhost')
diff --git a/ovs_offload/ovs_offload_lnv3.py b/ovs_offload/ovs_offload_lnw_v3.py
similarity index 99%
rename from ovs_offload/ovs_offload_lnv3.py
rename to ovs_offload/ovs_offload_lnw_v3.py
index bdf455e..eb10ac5 100755
--- a/ovs_offload/ovs_offload_lnv3.py
+++ b/ovs_offload/ovs_offload_lnw_v3.py
@@ -94,8 +94,6 @@ ovs-vsctl add-port br-tun-{vf_list[i]} {acc_pr_list[i]}
         else:
             vf = get_interface_info(server_name='host', interface_name=vf_list[i])
             acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
-            #print(vf)
-            #print(acc_pr)
             vf_to_acc += f"""echo ""
 echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']})  PORT ({vf['port']}) maps to"
 echo "ACC  IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
@@ -563,7 +561,7 @@ EOF
 
 def build_args():
     # Create the top-level parser
-    parser = argparse.ArgumentParser(description='Run Linux networking with OVS Offload')
+    parser = argparse.ArgumentParser(description='Run Linux networking V3 with OVS Offload')
     subparsers = parser.add_subparsers(dest='command', help='options')
     # Create the parser for the "create_script" command
     parser_create_script = subparsers.add_parser('create_script', help='Generate configuration scripts in localhost')

commit 4fa5da7d32a25a2b67b8e06beef515bb66af4699
Merge: 53e59d5 6afaac1
Author: Derek G Foster <derek.foster@intel.com>
Date:   Tue Sep 10 12:23:59 2024 -0700

    Merge pull request #4 from ipdk-io/bandit-fixes
    
    Address issues flagged by Bandit

commit 6afaac1f537cc93947f512d9b5d3da9f1902432d
Author: Derek Foster <derek.foster@intel.com>
Date:   Tue Sep 10 12:13:45 2024 -0700

    Address issues flagged by Bandit
    
    Signed-off-by: Derek Foster <derek.foster@intel.com>

diff --git a/ovs_offload/ovs_offload_lnv.py b/ovs_offload/ovs_offload_lnv.py
index 70e2856..a2be5a0 100755
--- a/ovs_offload/ovs_offload_lnv.py
+++ b/ovs_offload/ovs_offload_lnv.py
@@ -611,7 +611,7 @@ if __name__ == "__main__":
 
     elif args.command == 'setup':
 
-        if host_password == '':
+        if len(host_password) == 0:
             print("Enter correct IPU Host SSH root password in config.yaml and retry")
             sys.exit()
 
@@ -680,7 +680,7 @@ if __name__ == "__main__":
 
     elif args.command == 'teardown':
 
-        if host_password == '':
+        if len(host_password) == 0:
             print("Enter correct IPU Host root password in config.yaml and retry")
             sys.exit()
 
diff --git a/ovs_offload/ovs_offload_lnv2.py b/ovs_offload/ovs_offload_lnv2.py
index b0307b8..56da35b 100755
--- a/ovs_offload/ovs_offload_lnv2.py
+++ b/ovs_offload/ovs_offload_lnv2.py
@@ -611,7 +611,7 @@ if __name__ == "__main__":
 
     elif args.command == 'setup':
 
-        if host_password == '':
+        if len(host_password) == 0:
             print("Enter correct IPU Host SSH root password in config.yaml and retry")
             sys.exit()
 
@@ -680,7 +680,7 @@ if __name__ == "__main__":
 
     elif args.command == 'teardown':
 
-        if host_password == '':
+        if len(host_password) == 0:
             print("Enter correct IPU Host root password in config.yaml and retry")
             sys.exit()
 
diff --git a/ovs_offload/ovs_offload_lnv3.py b/ovs_offload/ovs_offload_lnv3.py
index 827f0e7..bdf455e 100755
--- a/ovs_offload/ovs_offload_lnv3.py
+++ b/ovs_offload/ovs_offload_lnv3.py
@@ -611,7 +611,7 @@ if __name__ == "__main__":
 
     elif args.command == 'setup':
 
-        if host_password == '':
+        if len(host_password) == 0:
             print("Enter correct IPU Host SSH root password in config.yaml and retry")
             sys.exit()
 
@@ -680,7 +680,7 @@ if __name__ == "__main__":
 
     elif args.command == 'teardown':
 
-        if host_password == '':
+        if len(host_password) == 0:
             print("Enter correct IPU Host root password in config.yaml and retry")
             sys.exit()
 

commit 53e59d515454bcf0bd63178cacc2321f8e56b3d0
Merge: 41bff1f 8cd339c
Author: Derek G Foster <derek.foster@intel.com>
Date:   Tue Sep 10 11:31:12 2024 -0700

    Merge pull request #3 from ipdk-io/add-checkers
    
    Set up code owners and standard checkers

commit 8cd339c6fe8516263366a9ffa3afdabd75341fc8
Author: Derek Foster <derek.foster@intel.com>
Date:   Tue Sep 10 11:01:29 2024 -0700

    Set up code owners and standard checkers
    
    Signed-off-by: Derek Foster <derek.foster@intel.com>

diff --git a/.github/CODEOWNERS b/.github/CODEOWNERS
new file mode 100644
index 0000000..f486d42
--- /dev/null
+++ b/.github/CODEOWNERS
@@ -0,0 +1 @@
+* @ffoulkes @5abeel
diff --git a/.github/dependabot.yml b/.github/dependabot.yml
new file mode 100644
index 0000000..09412ed
--- /dev/null
+++ b/.github/dependabot.yml
@@ -0,0 +1,15 @@
+# To get started with Dependabot version updates, you'll need to specify which
+# package ecosystems to update and where the package manifests are located.
+# Please see the documentation for all configuration options:
+# https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates
+---
+version: 2
+updates:
+  - package-ecosystem: "pip" # See documentation for possible values
+    directory: "/" # Location of package manifests
+    schedule:
+      interval: "daily"
+  - package-ecosystem: "github-actions"
+    directory: "/"
+    schedule:
+      interval: "weekly"
diff --git a/.github/workflows/checkers.yml b/.github/workflows/checkers.yml
new file mode 100644
index 0000000..ca91290
--- /dev/null
+++ b/.github/workflows/checkers.yml
@@ -0,0 +1,87 @@
+name: "Check modified files"
+
+on:
+  push:
+    branches:
+      - main
+  pull_request:
+    branches:
+      - main
+
+concurrency:
+  # If workflow is currently running, stop it and start a new one.
+  group: check-${{ github.ref }}
+  cancel-in-progress: true
+
+permissions: read-all
+
+jobs:
+  #---------------------------------------------------------------------
+  # 1-markdownlint
+  #---------------------------------------------------------------------
+  markdownlint:
+    runs-on: ubuntu-latest
+    timeout-minutes: 5
+
+    steps:
+      - name: Clone repository
+        uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+
+      - name: Get list of changed files
+        id: changed
+        uses: tj-actions/changed-files@v45
+        with:
+          files: |
+            **.md
+
+      - name: Lint markdown files
+        if: steps.changed.outputs.any_changed == 'true'
+        uses: nosborn/github-action-markdown-cli@v3.3.0
+        with:
+          files: ${{ steps.changed.outputs.all_changed_files }}
+          config_file: .markdownlint.json
+
+  #---------------------------------------------------------------------
+  # 2-bandit_check
+  #---------------------------------------------------------------------
+  bandit_check:
+    runs-on: ubuntu-latest
+    timeout-minutes: 5
+
+    steps:
+      - name: Clone repository
+        uses: actions/checkout@v4
+
+      - name: Check Python files
+        uses: tj-actions/bandit@v5.5
+        with:
+          targets: |
+            **/**.py
+          options: "-v"
+
+  #---------------------------------------------------------------------
+  # 3-shellcheck
+  #---------------------------------------------------------------------
+  shellcheck:
+    runs-on: ubuntu-latest
+    timeout-minutes: 5
+
+    steps:
+      - name: Clone repository
+        uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+
+      - name: Get list of changed files
+        id: changed
+        uses: tj-actions/changed-files@v45
+        with:
+          files: |
+            **.sh
+
+      - name: Check for bash errors
+        if: steps.changed.outputs.any_changed == 'true'
+        run: |
+          shellcheck ${{ steps.changed.outputs.all_changed_files }}
diff --git a/.markdownlint.json b/.markdownlint.json
new file mode 100644
index 0000000..2802a18
--- /dev/null
+++ b/.markdownlint.json
@@ -0,0 +1,3 @@
+{
+    "MD013": false  # allow line length > 80
+}

commit 41bff1f918eac276b5dda1112c47fb41033140ca
Merge: e625d6c f4f3158
Author: Dan Daly <dandaly@pobox.com>
Date:   Wed Sep 4 15:42:25 2024 -0700

    Merge pull request #1 from naveenashok211/main
    
    [ovs offload] Python tool to generate config scripts and setup ovs offload recipe on IPU

commit f4f3158e085d8443b4c5c1351cd5e97a7b3f2f21
Author: Naveen Ashok <naveen1.ashok@intel.com>
Date:   Wed Sep 4 14:21:14 2024 -0700

    [ovs offload] Update README.md with ipu p4 package info
    
    Signed-off-by: Naveen Ashok <naveen1.ashok@intel.com>

diff --git a/ovs_offload/README.md b/ovs_offload/README.md
index 326d2c5..29d0102 100644
--- a/ovs_offload/README.md
+++ b/ovs_offload/README.md
@@ -18,22 +18,26 @@ Check file /etc/ssh/sshd_config and change PermitRootLogin yes
 
 ### Pre-requisites:
 
-- IPU P4 pre-built artifacts can be obtained from the internal only tar package: ``hw-p4-programs.<version>.tgz``. Download this package from artifactory and extract it.
-- The compiled artifacts for P4 ``fxp-net_linux-networking`` can be found in below location after extracting the tar package ``tar -xvf hw-p4-programs.<version>.tgz``.
+- The host package ``intel-ipu-host-components-<version>.<build number>.tar.gz`` contains the example IPU P4 source code, the compiled P4 package and artifacts that can be used to setup the workload on the IMC and ACC.
+- The compiled artifacts for P4 ``fxp-net_linux-networking`` can be found in below location after extracting the tar package.
 
 ```
-> ls p4-programs/artifacts/fxp-net_linux-networking/
-total 4.7M
--rw-r--r--. 1 admin12 admin12 128K Jul 31 18:34 tdi.json
--rw-r--r--. 1 admin12 admin12  46K Jul 31 18:34 p4Info.txt
--rw-r--r--. 1 admin12 admin12 950K Jul 31 18:34 fxp-net_linux-networking.s
--rw-r--r--. 1 admin12 admin12 1.5M Jul 31 18:34 fxp-net_linux-networking.pkg
--rw-r--r--. 1 admin12 admin12 1.5M Jul 31 18:34 fxp-net_linux-networking_a791d47e422246f29ee48edaccc9da88.pkgo
--rw-r--r--. 1 admin12 admin12 638K Jul 31 18:34 context.json
+cd intel-ipu-host-components/P4Tools/P4Programs/artifacts/fxp-net_linux-networking
+
+> ls
+total 6.2M
+-rw-r--r--. 1 admin12 admin12 1.5M Aug 30 10:47 fxp-net_linux-networking_3de1c1f569bb44d69043c2fb3093d079.pkgo
+-rw-r--r--. 1 admin12 admin12  46K Sep  3 11:29 p4Info.txt
+-rw-r--r--. 1 admin12 admin12 1.4K Sep  3 11:29 entries.json
+-rw-r--r--. 1 admin12 admin12 128K Sep  3 11:29 tdi.json
+-rw-r--r--. 1 admin12 admin12 639K Sep  3 11:32 context.json
+-rw-r--r--. 1 admin12 admin12 949K Sep  3 11:32 fxp-net_linux-networking.s
+-rw-r--r--. 1 admin12 admin12 1.5M Sep  3 11:32 fxp-net_linux-networking_12d1caf7e380490b96f1df444b5050af.pkgo
+-rw-r--r--. 1 admin12 admin12 1.5M Sep  3 11:32 fxp-net_linux-networking.pkg
 
 ```
 
-- Load the P4 package ``fxp-net_linux-networking.pkg`` on the IMC. Refer document [IPU P4 Quickstart Guide](https://edc.intel.com/content/www/us/en/secure/design/confidential/products-and-solutions/networking-and-io/infrastructure-processing-unit-software-user-guide/ipu-p4-quick-start-guide/#load-the-p4-package)
+- Load the P4 package ``fxp-net_linux-networking.pkg`` on the IMC. Refer Section ``IPU P4 Quickstart Guide`` in the Intel速 Infrastructure Processing Unit Software User Guide
 - Copy the P4 artifacts folder for the specific release version being tested to the IMC and then to the ACC location ``/opt/p4/p4sde/p4_test/fxp-net_linux-networking``.
 
 - Make sure the same version of IDPF driver is loaded on the Host, IMC and ACC, run commands below as a root user

commit 11498dacca1b8e9019ae9b8cb101fc017249d3b8
Author: Naveen Ashok <naveen1.ashok@intel.com>
Date:   Wed Sep 4 14:03:45 2024 -0700

    [ovs offload] Python tool to generate config scripts and setup ovs offload recipe on IPU
    
    Signed-off-by: Naveen Ashok <naveen1.ashok@intel.com>

diff --git a/ovs_offload/README.md b/ovs_offload/README.md
new file mode 100644
index 0000000..326d2c5
--- /dev/null
+++ b/ovs_offload/README.md
@@ -0,0 +1,621 @@
+# OVS Offload Scripts:
+
+## Introduction:
+
+The tool ovs_offload_lnv.py can be used to generate the workload configuration scripts to run the Linux Networking Recipe with OVS Offload.
+The configuration scripts can be used to start infrap4d on the ACC, use the script generated p4rt-ctl rules to configure ACC Port representors,
+configure OVS and create OVS bridges and configure VMs on the IDPF interfaces on the Host.
+
+## Test Environment Setup:
+
+- Before running script check if ssh as a root user is enabled and root user password is setup for ssh.
+```
+Check file /etc/ssh/sshd_config and change PermitRootLogin yes
+
+[root@athena ~]# grep -rn PermitRootLogin /etc/ssh/sshd_config
+40:PermitRootLogin yes
+```
+
+### Pre-requisites:
+
+- IPU P4 pre-built artifacts can be obtained from the internal only tar package: ``hw-p4-programs.<version>.tgz``. Download this package from artifactory and extract it.
+- The compiled artifacts for P4 ``fxp-net_linux-networking`` can be found in below location after extracting the tar package ``tar -xvf hw-p4-programs.<version>.tgz``.
+
+```
+> ls p4-programs/artifacts/fxp-net_linux-networking/
+total 4.7M
+-rw-r--r--. 1 admin12 admin12 128K Jul 31 18:34 tdi.json
+-rw-r--r--. 1 admin12 admin12  46K Jul 31 18:34 p4Info.txt
+-rw-r--r--. 1 admin12 admin12 950K Jul 31 18:34 fxp-net_linux-networking.s
+-rw-r--r--. 1 admin12 admin12 1.5M Jul 31 18:34 fxp-net_linux-networking.pkg
+-rw-r--r--. 1 admin12 admin12 1.5M Jul 31 18:34 fxp-net_linux-networking_a791d47e422246f29ee48edaccc9da88.pkgo
+-rw-r--r--. 1 admin12 admin12 638K Jul 31 18:34 context.json
+
+```
+
+- Load the P4 package ``fxp-net_linux-networking.pkg`` on the IMC. Refer document [IPU P4 Quickstart Guide](https://edc.intel.com/content/www/us/en/secure/design/confidential/products-and-solutions/networking-and-io/infrastructure-processing-unit-software-user-guide/ipu-p4-quick-start-guide/#load-the-p4-package)
+- Copy the P4 artifacts folder for the specific release version being tested to the IMC and then to the ACC location ``/opt/p4/p4sde/p4_test/fxp-net_linux-networking``.
+
+- Make sure the same version of IDPF driver is loaded on the Host, IMC and ACC, run commands below as a root user
+
+```
+sudo -i
+modprobe idpf
+lsmod | grep idpf
+modinfo idpf
+echo 8 > /sys/class/net/ens5f0/device/sriov_numvfs
+```
+- Replace `ens5f0` above with the correct Host IDPF Interface to create 8 SR-IOV VFs on the Host.
+
+- The tool uses tmux session when running the option setup and option teardown. Install TMUX on the IPU Host.
+```
+Ubuntu/Debian.
+sudo apt-get update && sudo apt-get -y install tmux
+
+Redhat/CentOS and other RHEL Distros.
+sudo yum install update && sudo yum -y install tmux
+
+Check after installing.
+# tmux --help
+usage: tmux [-2CDlNuvV] [-c shell-command] [-f file] [-L socket-name]
+            [-S socket-path] [-T features] [command [flags]]
+```
+
+### Test Config:
+
+- Update yaml file config.yaml for the specific test setup, change the management IP, username and password for imc and acc if it is different.
+- Update the test_params section as required for the setup with the correct host, imc and acc script paths.
+- Update the idpf_interface, vf_interfaces, acc_pr_interfaces and ip_list as required to scale up or scale down on the number of interface configuration generated by the script. More information on the fields in the comments below.
+
+```
+> cd networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload
+```
+
+```
+> cat config.yaml
+host:
+  ssh:
+    ip: 127.0.0.1
+    username: root
+    # Update the login password for the IPU Host
+    password: ""
+  # Link Partner interfaces on IPU host - lp_interfaces[0]<->IPU Port0, lp_interfaces[1]<->IPU Port1
+  lp_interfaces: ['ens7f1','ens7f0']
+  lp_interface_ip: ['10.0.0.30','20.0.0.30']
+
+imc:
+  ssh:
+    ip: 100.0.0.100
+    username: root
+    password: ""
+
+acc:
+# SSH to ACC from the IMC
+  ssh:
+    ip: 192.168.0.2
+    username: root
+    password: ""
+
+test_params:
+    #path fields specify the location where the configuration scripts will be copied to on the Host,IMC and ACC
+    host_path: 'lnv_ovs_scripts'
+    imc_path: '/mnt/imc/p4_test'
+    acc_path:  '/opt/p4/p4sde/p4_test'
+    # Update the correct IDPF Interface on the Host
+    idpf_interface: 'ens5f0'
+    # Update the list of Host IDPF Interfaces on the Host to Map to ACC Port representors
+    # Interfaces ['0','1'] below represents the IPU Physical Port 0 and Port 1 and the remaining as the Host IDPF Vfs
+    vf_interfaces: ['0','1','ens5f0v0','ens5f0v1','ens5f0v2','ens5f0v3','ens5f0v4','ens5f0v5','ens5f0v6','ens5f0v7']
+    # These are the ACC Port representors that will be used to map to the interfaces in the above list vf_interfaces
+    acc_pr_interfaces:  ['enp0s1f0d4','enp0s1f0d5','enp0s1f0d6','enp0s1f0d7','enp0s1f0d8','enp0s1f0d9','enp0s1f0d10','enp0s1f0d11','enp0s1f0d12','enp0s1f0d13']
+    # The ip_list contains the IP addresses that will be used for the Host IDPF VF interfaces that are mapped to the VM config (using: ip netns).
+    ip_list: ['10.0.0.10','10.0.0.11','10.0.0.12','10.0.0.13','20.0.0.10','20.0.0.11','20.0.0.12','20.0.0.13']
+    # User Input for OVS VXLAN Config.
+    # Local and remote vtep(virtual tunnel end-point) IPs are used in OVS vxlan config with ACC PRs mapped to host IDPF VF
+    local_vtep: ['10.1.1.1','11.1.1.1','12.1.1.1','13.1.1.1','14.1.1.1','15.1.1.1','16.1.1.1','17.1.1.1','18.1.1.1','19.1.1.1','20.1.1.1']
+    remote_vtep: ['10.1.1.2','11.1.1.2','12.1.1.2','13.1.1.2','14.1.1.2','15.1.1.2','16.1.1.2','17.1.1.2','18.1.1.2','19.1.1.2','20.1.1.2']
+    # Tunnel Termination Bridge IP for local and remote peer.
+    local_br_tun_ip: ['1.1.1.1','2.1.1.1']
+    remote_br_tun_ip: ['1.1.1.2','2.1.1.2']
+```
+
+## Python Environment Setup:
+
+- Use python venv:
+```
+cd networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload
+python -m venv --copies venv
+```
+
+- Activate the venv and install requirements:
+```
+# source venv/bin/activate
+(venv)# pip install -r requirements.txt
+(venv)# deactivate
+```
+
+### requirements.txt
+
+```
+PyYAML
+```
+
+- Run python script **ovs_offload_lnv.py** as a root user.
+```
+sudo -i
+cd networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload
+source venv/bin/activate
+```
+
+## Test Script:
+
+### ovs_offload_lnv.py : (P4:fxp-net_linux-networking.p4, IPU SDK Release >= 1.7.0)
+
+1. This is a python script : **ovs_offload/ovs_offload_lnv.py** that can be used with **P4: fxp-net_linux-networking.p4** for release 1.7.0
+```
+> python ovs_offload_lnv.py
+usage: ovs_offload_lnv.py [-h] {create_script,copy_script,setup,teardown} ...
+
+Run Linux networking with OVS Offload
+
+positional arguments:
+  {create_script,copy_script,setup,teardown}
+                        options
+    create_script       Generate configuration scripts in localhost
+    copy_script         Copy configuration scripts to IMC and ACC
+    setup               Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for
+                        scripts to be available in ACC
+    teardown            Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once
+                        for scripts to be available in ACC
+
+optional arguments:
+  -h, --help            show this help message and exit
+```
+
+2. create_script: This will create the configuration scripts in the script directory (can be changes in **host_path** in **config.yaml**) at **ovs_offload/lnv_ovs_scripts**
+```
+> python ovs_offload_lnv.py create_script
+```
+
+The scripts will be created as shown below.
+```
+> ls networking.ipu.software.customer-enabling.validation/ipu_examples/workloads/p4/ovs_offload/lnv_ovs_scripts/
+total 60K
+-rwxr-xr-x. 1 admin12 admin12 1.6K Aug 28 13:37 es2k_skip_p4.conf
+-rwxr-xr-x. 1 admin12 admin12  375 Aug 28 13:37 1_host_idpf.sh
+-rwxr-xr-x. 1 admin12 admin12 1.3K Aug 28 13:37 2_acc_infrap4d.sh
+-rwxr-xr-x. 1 admin12 admin12  12K Aug 28 13:37 3_acc_p4rt.sh
+-rwxr-xr-x. 1 admin12 admin12 8.4K Aug 28 13:37 acc_p4rt_delete.sh
+-rwxr-xr-x. 1 admin12 admin12 2.0K Aug 28 13:37 4_acc_p4rt_dump.sh
+-rwxr-xr-x. 1 admin12 admin12 1.3K Aug 28 13:37 5_acc_setup_ovs.sh
+-rwxr-xr-x. 1 admin12 admin12 2.1K Aug 28 13:37 6_acc_ovs_bridge.sh
+-rwxr-xr-x. 1 admin12 admin12 6.1K Aug 28 13:37 acc_ovs_vxlan.sh
+-rwxr-xr-x. 1 admin12 admin12 2.8K Aug 28 13:37 7_host_vm.sh
+```
+
+3. copy_script: This will create the configuration scripts in the script directory (can be changes in **host_path** in **config.yaml**) at **ovs_offload/lnv_ovs_scripts** and also copy it to the ACC to the acc_path field provided in the **config file:config.yaml**
+```
+> python ovs_offload_lnv.py copy_script
+```
+
+4. setup:
+
+```
+> python ovs_offload_lnv.py setup
+```
+- This will setup the complete OVS offload recipe.
+- Configure TMUX session - test1_infrap4d, login to ACC and launch infrap4d,
+- Configure TMUX session - test2_p4rt configure the p4rt-ctl rules, configure OVS bridges
+- Configure TMUX session - test3_host configure the VMs on Host IDPF interface and link partner.
+- Run a ping test to check the forwarding.
+- After running the setup option we can login to each of the tmux sessions.
+```
+# tmux ls
+test1_infrap4d: 1 windows (created Thu Aug 29 12:35:25 2024)
+test2_p4rt: 1 windows (created Thu Aug 29 12:33:26 2024)
+test3_host: 1 windows (created Thu Aug 29 12:32:55 2024)
+```
+- Attach to a tmux session
+```
+tmux a -t test2_p4rt
+```
+- Detach from inside a tmux session.
+```
+ctrl+b d
+```
+
+4. teardown:
+
+```
+> python ovs_offload_lnv.py teardown
+```
+- This will teardown the complete OVS offload recipe.
+- Pre-Requisite: run copy_script option once for scripts to be available in ACC
+- Configure TMUX session - test3_host delete the VMs on Host and remove the link partner configuration.
+- Configure TMUX session - test2_p4rt delete the p4rt-ctl rules and delete the OVS bridges
+- Configure TMUX session - test1_infrap4d, login to ACC and stop infrap4d,
+
+
+### ovs_offload_lnv3.py : (P4:fxp-net_linux-networking_v3.p4, IPU SDK Release 1.6.0, 1.6.1)
+
+1. This is a python script : **ovs_offload/ovs_offload_lnv3.py** that can be used with **P4: fxp-net_linux-networking_v3.p4** for release 1.6.0,1.6.1
+```
+> python ovs_offload_lnv3.py
+usage: ovs_offload_lnv3.py [-h] {create_script,copy_script,setup,teardown} ...
+
+Run Linux networking with OVS Offload
+
+positional arguments:
+  {create_script,copy_script,setup,teardown}
+                        options
+    create_script       Generate configuration scripts in localhost
+    copy_script         Copy configuration scripts to IMC and ACC
+    setup               Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for
+                        scripts to be available in ACC
+    teardown            Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once
+                        for scripts to be available in ACC
+
+optional arguments:
+  -h, --help            show this help message and exit
+```
+
+### ovs_offload_lnv2.py: (P4:fxp-net_linux-networking_v2.p4, IPU SDK Release 1.4.0)
+
+1. This is a python script : **ovs_offload/scripts/ovs_offload_lnv2.py** that can be used with **P4: fxp-net_linux-networking_v2.p4** for release 1.4.0
+```
+> python ovs_offload_lnv2.py
+usage: ovs_offload_lnv2.py [-h] {create_script,copy_script,setup,teardown} ...
+
+Run Linux networking with OVS Offload
+
+positional arguments:
+  {create_script,copy_script,setup,teardown}
+                        options
+    create_script       Generate configuration scripts in localhost
+    copy_script         Copy configuration scripts to IMC and ACC
+    setup               Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for
+                        scripts to be available in ACC
+    teardown            Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once
+                        for scripts to be available in ACC
+
+optional arguments:
+  -h, --help            show this help message and exit
+```
+
+## Use the Scripts on ACC to Setup OVS Offload :
+
+- Follow the instructions below to run the Recipe on the ACC with the help of configuration scripts or.
+- Run the tool with setup option.
+```
+> python ovs_offload_lnv.py setup
+```
+
+### 1. IPU P4 Artifacts on ACC
+
+- The scripts expect the P4 artifacts are available in the folder below in the ACC, make sure to copy the correct artifacts for the release. Example given below for P4: fxp-net_linux-networking.p4 for release 1.7.0, for Release 1.6.0 use P4: fxp-net_linux-networking_v3.p4 artifacts and for Release 1.4.0 use P4: fxp-net_linux-networking_v2.p4
+
+```
+[root@ipu-acc ~]# ls /opt/p4/p4sde/p4_test/fxp-net_linux-networking
+```
+
+### 2. Infrap4d Configuration file
+
+- Copy the infrap4d config in **/opt/p4/p4sde/p4_test/lnv_ovs_scripts/es2k_skip_p4.conf** to artifact folder **/opt/p4/p4sde/p4_test/fxp-net_linux-networking** in the ACC
+```
+[root@ipu-acc ~]# cp /opt/p4/p4sde/p4_test/lnv_ovs_scripts/es2k_skip_p4.conf /opt/p4/p4sde/p4_test/fxp-net_linux-networking/
+```
+
+### 3. Start Infrap4d
+
+- Use the lnv_ovs_scripts in the ACC to setup infrap4d, p4rt and OVS bridge:
+
+- ACC Terminal 1 : Setup environment and start Infrap4d
+```
+[root@ipu-acc ~]# cd /opt/p4/p4sde/p4_test/lnv_ovs_scripts
+
+[root@ipu-acc lnv_ovs_scripts]# ./2_acc_infrap4d.sh
+```
+
+- Wait for infrap4d to initialize and start listening on the server.
+```
+Initialized lld_cpchnl control path
+Fetching VF info
+................
+
+ipu_p4d: dev_id 0 initialized
+cpfl_set_rx_function(): Using Split Scalar Rx (port 0).
+cpfl_set_tx_function(): Using Split Scalar Tx (port 0).
+Port 0 MAC: 00 22 00 01 03 20
+cpfl_set_rx_function(): Using Split Scalar Rx (port 1).
+cpfl_set_tx_function(): Using Split Scalar Tx (port 1).
+Port 1 MAC: 00 23 00 02 03 20
+
+ipu_p4d: initialized 1 devices
+Skip p4 lib init
+ipu_p4d: spawning cli server thread
+ipu_p4d: running in background; driver shell is disabled
+ipu_p4d: server started - listening on port 9999
+E20240414 00:03:48.469659 293611 es2k_hal.cc:276] [secure mode] Stratum external-facing services are listening to 0.0.0.0:9339, 0.0.0.0:9559, localhost:9559...
+
+```
+
+### 3. Setup p4rt-ctl pipe and add the ACC PR rules
+
+- ACC Terminal 2 : Setup p4rt-ctl pipeline and setup the runtime rules.
+```
+[root@ipu-acc lnv_ovs_scripts]# pwd
+/opt/p4/p4sde/p4_test/lnv_ovs_scripts
+
+[root@ipu-acc lnv_ovs_scripts]# ./3_acc_p4rt.sh
+```
+
+- ACC Terminal 2 : Dump the p4rt-ctl runtime rules.
+```
+[root@ipu-acc lnv_ovs_scripts]# pwd
+/opt/p4/p4sde/p4_test/lnv_ovs_scripts
+
+[root@ipu-acc lnv_ovs_scripts]# ./4_acc_p4rt_dump.sh
+```
+
+### 4. Setup ACC environment for OVS
+
+- ACC Terminal 2 : Setup the OVS Environment.
+```
+[root@ipu-acc lnv_ovs_scripts]# pwd
+/opt/p4/p4sde/p4_test/lnv_ovs_scripts
+
+[root@ipu-acc lnv_ovs_scripts]# ./5_acc_setup_ovs.sh
+```
+
+### 5. Setup OVS Bridge Configuration
+
+- ACC Terminal 2 : Setup the OVS Bridge Config
+```
+[root@ipu-acc lnv_ovs_scripts]# pwd
+/opt/p4/p4sde/p4_test/lnv_ovs_scripts
+
+[root@ipu-acc lnv_ovs_scripts]# ./6_acc_ovs_bridge.sh
+```
+
+### 6. Setup VMs on the IPU Host and configure link partner interface:
+
+- IPU HOST Terminal 1 : Configure the VMs on the IPU Host the script below uses **ip netns**
+```
+[root@host]# cd ovs_offload/scripts/lnv_ovs_scripts
+[root@host]# ./7_host_vm.sh
+```
+
+- Configure IP to the Link Partner Interface and Test Ping to the Host IDPF VF interfaces in the VMs.
+```
+# Link Partner connected to IPU Port 0
+sudo ip a a dev ens7f1 10.0.0.30/24
+
+# Link Partner connected to IPU Port 1
+sudo ip a a dev ens7f0 20.0.0.30/24
+
+# Test Ping LP(IPU Port 0) <-> VM0(IDPF SRIOV VF)
+ip netns exec VM0 ip -br a
+ping 10.0.0.10
+ip netns exec VM0 ping 10.0.0.30
+
+# Test Ping LP(IPU Port 1) <-> VM4(IDPF SRIOV VF)
+ip netns exec VM4 ip -br a
+ping 20.0.0.10
+ip netns exec VM4 ping 20.0.0.30
+
+```
+
+### 7. Optional: Setup OVS Bridge for VXLAN
+
+- This configuration script will setup OVS VXLAN Bridges.
+```
+[root@ipu-acc lnv_ovs_scripts]# pwd
+/opt/p4/p4sde/p4_test/lnv_ovs_scripts
+
+[root@ipu-acc lnv_ovs_scripts]# ./acc_ovs_vxlan.sh
+```
+
+- Stop firewalld on IPU Host and the ACC
+```
+systemctl stop firewalld
+```
+
+- Run simple script below to configure VXLAN on the Link Partner Connected to Port 0:
+```
+#!/bin/sh
+
+echo "Set up Tunnel End Point and the Vxlan config on the Link Partner on remote host"
+echo "Add HOST VF ens5f0v0 to the VM0 namespace"
+ip link del dev TEP10
+ip link del dev vxlan10
+
+echo ""
+echo "Configure the Remote Tunnel End Point TEP10"
+ip link add dev TEP10 type dummy
+ifconfig TEP10 10.1.1.2/24 up
+sleep 1
+ip addr show TEP10
+
+echo ""
+echo "Configure the VXLAN Interface vxlan10"
+ip link del vxlan10
+ip link add vxlan10 type vxlan id 10 dstport 4789 remote 10.1.1.1 local 10.1.1.2
+ip addr add 10.0.0.30/24 dev vxlan10
+ip link set vxlan10 up
+sleep 1
+ip addr show vxlan10
+
+echo ""
+echo "Configure the Link Partner interface Connected to Port 0"
+ip addr del dev ens7f1 10.0.0.30/24
+ifconfig ens7f1 1.1.1.2/24 up
+ip route change 10.1.1.0/24 via 1.1.1.1 dev ens7f1
+sleep 1
+ip addr show ens7f1
+
+echo "Verify the Configure interfaces"
+
+```
+
+- Run a Ping Test
+
+```
+[root@host lnv_ovs_scripts]# ip netns exec VM0 ip -br a
+lo               DOWN
+ens5f0v0         UP             10.0.0.10/24 fe80::21a:ff:fe00:314/64
+
+[root@host lnv_ovs_scripts]# ip -br a
+lo               UNKNOWN        127.0.0.1/8 ::1/128
+eno8303          UP             10.232.27.29/23 fe80::c6cb:e1ff:fea7:3c82/64
+eno8403          UP             100.0.0.1/24
+ens7f0           UP
+ens7f1           UP             1.1.1.2/24
+ens5f0           UP
+ens5f0d1         UP
+ens5f0d2         UP
+ens5f0d3         UP
+TEP10            UNKNOWN        10.1.1.2/24 fe80::fcf2:f4ff:fe2a:18f4/64
+vxlan10          UNKNOWN        10.0.0.30/24 fe80::7c76:4ff:fe03:8591/64
+
+[root@host lnv_ovs_scripts]# ip netns exec VM0 ping 10.0.0.30
+PING 10.0.0.30 (10.0.0.30) 56(84) bytes of data.
+64 bytes from 10.0.0.30: icmp_seq=1 ttl=64 time=0.072 ms
+64 bytes from 10.0.0.30: icmp_seq=2 ttl=64 time=0.047 ms
+64 bytes from 10.0.0.30: icmp_seq=3 ttl=64 time=0.041 ms
+^C
+--- 10.0.0.30 ping statistics ---
+3 packets transmitted, 3 received, 0% packet loss, time 2028ms
+rtt min/avg/max/mdev = 0.041/0.053/0.072/0.013 ms
+
+[root@host lnv_ovs_scripts]# ping 10.0.0.10
+PING 10.0.0.10 (10.0.0.10) 56(84) bytes of data.
+64 bytes from 10.0.0.10: icmp_seq=1 ttl=64 time=0.058 ms
+64 bytes from 10.0.0.10: icmp_seq=2 ttl=64 time=0.046 ms
+64 bytes from 10.0.0.10: icmp_seq=3 ttl=64 time=0.040 ms
+^C
+--- 10.0.0.10 ping statistics ---
+3 packets transmitted, 3 received, 0% packet loss, time 2050ms
+rtt min/avg/max/mdev = 0.040/0.048/0.058/0.007 ms
+
+```
+
+
+### OVS Offload VXLAN on 2 IPU Peers Connected back to back:
+
+- Ideally OVS Offload with VXLAN can be run with 2 IPU Peer Setups connected back to back.
+- Run python script **ovs_offload_lnv.py** as a root user on the 2 peer IPU Hosts to generate the configuration.
+- Update the config.yaml for OVS VXLAN for IPU 1 Setup.
+```
+> cat config.yaml
+test_params:
+....
+    # The ip_list contains the IP addresses that will be used for the Host IDPF VF interfaces that are mapped to the VM config (using: ip netns).
+    ip_list: ['10.0.0.10','10.0.0.11','10.0.0.12','10.0.0.13','20.0.0.10','20.0.0.11','20.0.0.12','20.0.0.13']
+    # User Input for OVS VXLAN Config.
+    # Local and remote vtep(virtual tunnel end-point) IPs are used in OVS vxlan config with ACC PRs mapped to host IDPF VF
+    local_vtep: ['10.1.1.1','11.1.1.1','12.1.1.1','13.1.1.1','14.1.1.1','15.1.1.1','16.1.1.1','17.1.1.1','18.1.1.1','19.1.1.1','20.1.1.1']
+    remote_vtep: ['10.1.1.2','11.1.1.2','12.1.1.2','13.1.1.2','14.1.1.2','15.1.1.2','16.1.1.2','17.1.1.2','18.1.1.2','19.1.1.2','20.1.1.2']
+    # Tunnel Termination Bridge IP for local and remote peer.
+    local_br_tun_ip: ['1.1.1.1','2.1.1.1']
+    remote_br_tun_ip: ['1.1.1.2','2.1.1.2']
+
+```
+- Update config.yaml for OVS VXLAN Config for IPU 2 Setup.
+```
+> cat config.yaml
+test_params:
+....
+    # The ip_list contains the IP addresses that will be used for the Host IDPF VF interfaces that are mapped to the VM config (using: ip netns).
+    ip_list: ['10.0.0.20','10.0.0.21','10.0.0.22','10.0.0.23','20.0.0.20','20.0.0.21','20.0.0.22','20.0.0.23']
+    # User Input for OVS VXLAN Config.
+    # Local and remote vtep(virtual tunnel end-point) IPs are used in OVS vxlan config with ACC PRs mapped to host IDPF VF
+    local_vtep: ['10.1.1.2','11.1.1.2','12.1.1.2','13.1.1.2','14.1.1.2','15.1.1.2','16.1.1.2','17.1.1.2','18.1.1.2','19.1.1.2','20.1.1.2']
+    remote_vtep: ['10.1.1.1','11.1.1.1','12.1.1.1','13.1.1.1','14.1.1.1','15.1.1.1','16.1.1.1','17.1.1.1','18.1.1.1','19.1.1.1','20.1.1.1']
+    # Tunnel Termination Bridge IP for local and remote peer.
+    local_br_tun_ip: ['1.1.1.2','2.1.1.2']
+    remote_br_tun_ip: ['1.1.1.1','2.1.1.1']
+
+```
+
+- Follow the instructions provided in previous sections to setup infrap4d, p4rt-ctl and OVS on both the IPU Peer setups.
+- Ping from VM0 on IPU 1 Host to VM0 on IPU 2 Host should be successful. similarly ping between other VMs like VM1 IPU1 to VM1 IPU2 and so on
+
+### Optional:  Clean up the configs
+
+- Run the tool with option **teardown**
+```
+> python ovs_offload_lnv.py teardown
+```
+
+or
+
+- IPU HOST Terminal 1: Delete the VMs created on the IPU Host
+```
+ip netns del VM0
+ip netns del VM1
+ip netns del VM2
+ip netns del VM3
+ip netns del VM4
+ip netns del VM5
+ip netns del VM6
+ip netns del VM7
+```
+
+- ACC Terminal 2 : Delete the OVS Bridge Config on the ACC
+```
+#!/bin/sh
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=$P4CP_INSTALL
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+ovs-vsctl show
+ovs-vsctl del-br br-int-1
+ovs-vsctl del-br br-int-2
+ovs-vsctl del-br br-tun-0
+ovs-vsctl del-br br-tun-1
+
+ip link del TEP0
+ovs-vsctl del-br br0
+ip link del TEP1
+ovs-vsctl del-br br1
+ip link del TEP2
+ovs-vsctl del-br br2
+ip link del TEP3
+ovs-vsctl del-br br3
+ip link del TEP4
+ovs-vsctl del-br br4
+ip link del TEP5
+ovs-vsctl del-br br5
+ip link del TEP6
+ovs-vsctl del-br br6
+ip link del TEP7
+ovs-vsctl del-br br7
+ovs-vsctl show
+
+```
+
+- ACC Terminal 2: Delete the p4rt-ctl runtime rules
+```
+[root@ipu-acc lnv_ovs_scripts]# pwd
+/opt/p4/p4sde/p4_test/lnv_ovs_scripts
+
+[root@ipu-acc lnv_ovs_scripts]# ./acc_p4rt_delete.sh
+
+[root@ipu-acc lnv_ovs_scripts]# ./4_acc_p4rt_dump.sh
+```
+
+- ACC Terminal 1: Terminate the infrap4d
+```
+[root@ipu-acc ~]# ctrl + c
+```
+or
+```
+[root@ipu-acc ~]# ps -aux | grep infrap4d
+root       11120  0.0  0.0   4392  3156 pts/0    S+   00:45   0:00 /bin/sh ./2_acc_infrap4d.sh
+root       11188  0.4  0.5 70305376 81572 pts/0  SLl+ 00:45   1:00 /opt/p4/p4-cp-nws/sbin/infrap4d --nodetach
+root       24663  0.0  0.0   3620  1732 pts/1    S+   04:24   0:00 grep --color=auto infrap4d
+
+[root@ipu-acc ~]# kill 11188
+```
diff --git a/ovs_offload/common/utils.py b/ovs_offload/common/utils.py
new file mode 100644
index 0000000..a8c9b2c
--- /dev/null
+++ b/ovs_offload/common/utils.py
@@ -0,0 +1,290 @@
+#!/usr/bin/python
+#
+# Copyright 2022-2024 Intel Corporation
+# SPDX-License-Identifier: Apache 2.0
+#
+# Common python APIs and utilities for Intel速 Infrastructure Processing Unit (Intel速 IPU)
+
+import subprocess, os, time, re
+import yaml
+
+def fetch_configurations(config_file=''):
+    with open(config_file, "r") as file:
+        config_data = yaml.safe_load(file)
+    return config_data
+
+#Fetch test configuration
+test_config = fetch_configurations(f'{os.path.dirname(os.path.abspath(__file__))}/../config.yaml')
+
+def run_cmd(cmd, output=False, check_returncode=True):
+    """
+    Execute a command in a subprocess.
+    :param cmd: The command to be executed as a string.
+    :param output: If True, capture and return the command's stdout.
+    :param check_returncode: If True, check the command's return code and raise an error if not 0.
+    :return: The stdout of the command if output is True, otherwise None.
+    """
+    print(f'Executing: {cmd}')
+    # Use a context manager to ensure the subprocess is cleaned up after execution
+    with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE if output else None, stderr=subprocess.PIPE, encoding="utf-8") as s:
+        outs, errs = s.communicate() if output else (None, None)
+        # Check the return code if required
+        if check_returncode and s.returncode != 0:
+            raise subprocess.CalledProcessError(s.returncode, cmd, output=outs, stderr=errs)
+        return outs.strip() if output else None
+
+def ssh_command(server_name, command, output=True, check_returncode=True):
+    """
+    Execute a command on a remote server via SSH.
+    :param server_name: The name of the server ('host', 'imc', or 'acc').
+    :param command: The command to be executed on the remote server.
+    :return: A dictionary with the return code and the command's output.
+    """
+    imc_ip = test_config['imc']['ssh']['ip']
+    acc_ip = test_config['acc']['ssh']['ip']
+    # SSH command templates
+    imc_access = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
+    acc_access = f'{imc_access} ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
+
+    # Determine the appropriate SSH command based on the server name
+    if server_name == 'host':
+        full_cmd = command
+    elif server_name == 'imc':
+        full_cmd = f'{imc_access} "{command}"'
+    elif server_name == 'acc':
+        full_cmd = f'{acc_access} "{command}"'
+    else:
+        raise ValueError(f"Unknown server name: {server_name}")
+
+    # Execute the command and capture the output
+    output = run_cmd(full_cmd, output = output, check_returncode = check_returncode)
+
+    # Return the result as a dictionary
+    return {'rc': 0, 'output': output}
+
+
+def copy_scripts(host_path='lnv_ovs_scripts', imc_path = '/mnt/imc/p4_test', acc_path = '/opt/p4/p4sde/p4_test'):
+    """
+    Copies configuration scripts from the host to the IMC and then to the ACC.
+
+    :param host_path: Path to the configuration scripts on the host machine
+    :param imc_path: Destination path on the IMC
+    :param acc_path: Destination path on the ACC
+    """
+    imc_ip = test_config['imc']['ssh']['ip']
+    acc_ip = test_config['acc']['ssh']['ip']
+
+    command = f'mkdir -p {imc_path}'
+    try:
+        result = ssh_command('imc', command)
+    except Exception as e:
+        print(f"Failed with exception:\n{e}")
+
+    command = f'mkdir -p {acc_path}'
+    try:
+        result = ssh_command('acc', command)
+    except Exception as e:
+        print(f"Failed with exception:\n{e}")
+
+    # Copy the configuration scripts from host to IMC
+    #command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {host_path}  root@100.0.0.100:{imc_path}/'
+    command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {host_path}  root@{imc_ip}:{imc_path}/'
+    try:
+        result = ssh_command('host', command)
+    except Exception as e:
+        print(f"Failed with exception:\n{e}")
+
+    command = f'chmod +x {imc_path}/{host_path}/*'
+    try:
+        result = ssh_command('imc', command)
+    except Exception as e:
+        print(f"Failed with exception:\n{e}")
+
+    # Copy the configuration scripts from IMC to ACC
+    #command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {imc_path}/{host_path} root@192.168.0.2:{acc_path}/'
+    command = f'scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r {imc_path}/{host_path} root@{acc_ip}:{acc_path}/'
+    try:
+        result = ssh_command('imc', command)
+    except Exception as e:
+        print(f"Failed with exception:\n{e}")
+
+    command = f'chmod +x {acc_path}/{host_path}/*'
+    try:
+        result = ssh_command('acc', command)
+    except Exception as e:
+        print(f"Failed with exception:\n{e}")
+
+
+def get_interface_info(server_name, interface_name):
+    """
+    Retrieve information about a network interface on a remote server.
+
+    :param server_name: The name of the server where the interface is located.
+    :param interface_name: The name of the network interface to query.
+    :return: A dictionary containing various pieces of information about the interface.
+    """
+    # Initialize an empty dictionary to store interface information
+    interface_info = {}
+
+    # Define a mapping of server names to host IDs
+    host_id = {
+        'host': '0x0',
+        'acc': '0x4',
+        'imc': '0x5'
+    }
+
+    # Command to get basic interface information using ifconfig
+    cmd = f"ifconfig {interface_name}"
+    try:
+        result = ssh_command(server_name, cmd)
+    except Exception as e:
+        logging.error(f"Failed to run ifconfig on '{interface_name}': {e}")
+        return interface_info
+
+    output = result['output']
+
+    # Regex patterns to extract IP, MAC, and other fields
+    ip_pattern = re.compile(r'inet (\d+\.\d+\.\d+\.\d+)')
+    mac_pattern = re.compile(r'ether ([0-9a-fA-F:]{17})')
+    mtu_pattern = re.compile(r'mtu (\d+)')
+
+    # Search for patterns in the output and populate the dictionary
+    interface_info['ip'] = ip_pattern.search(output).group(1) if ip_pattern.search(output) else None
+    interface_info['mac'] = mac_pattern.search(output).group(1) if mac_pattern.search(output) else None
+    interface_info['mtu'] = mtu_pattern.search(output).group(1) if mtu_pattern.search(output) else None
+
+    # Command to get detailed interface information using ethtool
+    cmd = f"ethtool -i {interface_name}"
+    try:
+        result = ssh_command(server_name, cmd)
+    except Exception as e:
+        logging.warning(f"Failed to run ethtool on '{interface_name}': {e}")
+        return interface_info
+
+    output = result['output']
+
+    # Parse ethtool output and add to the dictionary
+    for line in output.split('\n'):
+        field = line.split(': ')
+        if len(field) == 2:
+            interface_info[field[0].strip()] = field[1].strip()
+
+    # Check if the driver is not 'idpf' and return the info collected so far
+    if interface_info.get('driver') != 'idpf':
+        return interface_info
+
+    # Command to get additional interface information for 'idpf' interface from IMC
+    cmd = f"cli_client -q -c | grep 'host_id: {host_id[server_name]}' | grep '{interface_info['mac']}'"
+    try:
+        result = ssh_command('imc', cmd)
+    except Exception as e:
+        logging.warning(f"Failed to run cli_client on '{interface_name}': {e}")
+        return interface_info
+
+    output = result['output']
+
+    # Regex pattern to extract additional fields for 'idpf' driver
+    pattern = re.compile(r'fn_id:\s+(\w+)\s+host_id:\s+(\w+)\s+is_vf:\s+(\w+)\s+vsi_id:\s+(\w+)\s+vport_id\s+(\w+)\s+is_created:\s+(\w+)\s+is_enabled:\s+(\w+)\s+mac\s+addr:\s+([0-9a-fA-F:]{17})')
+    match = pattern.search(output)
+
+    # Populate the dictionary with additional information if available
+    if match:
+        interface_info.update({
+            'fn_id': match.group(1),
+            'host_id': match.group(2),
+            'is_vf': match.group(3),
+            'vsi_id': match.group(4),
+            'vport_id': match.group(5),
+            'is_created': match.group(6),
+            'is_enabled': match.group(7),
+            'mac_addr': match.group(8)
+        })
+
+        # Calculate additional fields based on 'vsi_id'
+        if interface_info['vsi_id']:
+            interface_info['vsi_num'] = str(int(interface_info['vsi_id'], 16))
+            port_offset = str(int(interface_info['vsi_id'], 16) + 16)
+            interface_info['port'] = port_offset
+
+    return interface_info
+
+
+def ping_test(dst_ip, count=4, vm = None):
+    if vm:
+        cmd = f"ip netns exec {vm} ping {dst_ip} -c {count}"
+    else:
+        cmd = f"ping {dst_ip} -c {count}"
+    try:
+        #result = ssh_command('host', cmd)
+        result = run_cmd(cmd, output=True)
+        #print(f"cmd:{cmd}")
+        pkt_loss = 100
+        if result:
+            match = re.search('(\d*)% packet loss', result)
+            if match:
+                pkt_loss = int(match.group(1))
+            if f"{count} received, 0% packet loss" in result:
+                print(f"PASS: Ping successful to destination {dst_ip}\n")
+                return True
+            else:
+                raise RuntimeError(f"FAIL: Ping Failed to destination {dst_ip} with" f" {pkt_loss}% loss\n")
+    except Exception as E:
+        print(f"Ping run failed with error:'{E}'\n")
+        return False
+
+class tmux_term:
+    def __init__(self, tmux_name="", tmux_override=False):
+        # Initialize a new tmux terminal session
+        if not tmux_name:
+            raise ValueError("Error: No tmux name specified!")
+        self.tmux_name = tmux_name
+
+        # Check if the specified tmux session already exists
+        command = 'tmux ls'
+        try:
+            result = ssh_command('host', command, check_returncode=False)
+        except Exception as e:
+            raise Exception(f"Failed to list tmux sessions with exception:\n{e}")
+
+        # Parse the output to find an existing session
+        lines = result['output']
+        found = any(self.tmux_name in line for line in lines.split('\n'))
+
+        # If the session is found and override is allowed, kill the existing session
+        if found and tmux_override:
+            command = f'tmux kill-session -t {self.tmux_name}'
+            ssh_command('host', command)
+
+        # If the session was not found or was killed, create a new one
+        if not found or tmux_override:
+            command = f'tmux new-session -d -s {self.tmux_name}'
+            ssh_command('host', command)
+
+    def tmux_send_keys(self, cmd, delay=1, output=True):
+        # Send a command to the tmux session and optionally capture the output
+        time.sleep(0.5)  # Short delay before sending the command
+
+        if output:
+            # Set up piping to capture the output of the command
+            output_file = os.path.join(os.getcwd(), 'tmux_output.txt')
+            command = f'tmux pipe-pane -t {self.tmux_name} "cat > {output_file}"'
+            ssh_command('host', command)
+
+        # Send the actual command to the tmux session
+        command = f'tmux send-keys -t {self.tmux_name} "{cmd}" C-m'
+        ssh_command('host', command)
+
+        if output:
+            # Wait for the specified delay to allow the command to execute and output to be captured
+            if delay > 0:
+                time.sleep(delay)
+
+            # Stop piping the output
+            command = f'tmux pipe-pane -t {self.tmux_name}'
+            ssh_command('host', command)
+
+            # Read the captured output from the file
+            with open(output_file, "r") as f:
+                result = f.read()
+
+        return result
diff --git a/ovs_offload/config.yaml b/ovs_offload/config.yaml
new file mode 100644
index 0000000..6acfc23
--- /dev/null
+++ b/ovs_offload/config.yaml
@@ -0,0 +1,44 @@
+host:
+  ssh:
+    ip: 127.0.0.1
+    username: root
+    # Update the login password for the IPU Host
+    password: ""
+  # Link Partner interfaces on IPU host - lp_interfaces[0]<->IPU Port0, lp_interfaces[1]<->IPU Port1
+  lp_interfaces: ['ens7f1','ens7f0']
+  lp_interface_ip: ['10.0.0.30','20.0.0.30']
+
+imc:
+  ssh:
+    ip: 100.0.0.100
+    username: root
+    password: ""
+
+acc:
+# SSH to ACC from the IMC
+  ssh:
+    ip: 192.168.0.2
+    username: root
+    password: ""
+
+test_params:
+    #path fields specify the location where the configuration scripts will be copied to on the Host,IMC and ACC
+    host_path: 'lnv_ovs_scripts'
+    imc_path: '/mnt/imc/p4_test'
+    acc_path:  '/opt/p4/p4sde/p4_test'
+    # Update the correct IDPF Interface on the Host
+    idpf_interface: 'ens5f0'
+    # Update the list of Host IDPF Interfaces on the Host to Map to ACC Port representors
+    # Interfaces ['0','1'] below represents the IPU Physical Port 0 and Port 1 and the remaining as the Host IDPF Vfs
+    vf_interfaces: ['0','1','ens5f0v0','ens5f0v1','ens5f0v2','ens5f0v3','ens5f0v4','ens5f0v5','ens5f0v6','ens5f0v7']
+    # These are the ACC Port representors that will be used to map to the interfaces in the above list vf_interfaces
+    acc_pr_interfaces:  ['enp0s1f0d4','enp0s1f0d5','enp0s1f0d6','enp0s1f0d7','enp0s1f0d8','enp0s1f0d9','enp0s1f0d10','enp0s1f0d11','enp0s1f0d12','enp0s1f0d13']
+    # The ip_list contains the IP addresses that will be used for the Host IDPF VF interfaces that are mapped to the VM config (using: ip netns).
+    ip_list: ['10.0.0.10','10.0.0.11','10.0.0.12','10.0.0.13','20.0.0.10','20.0.0.11','20.0.0.12','20.0.0.13']
+    # User Input for OVS VXLAN Config.
+    # Local and remote vtep(virtual tunnel end-point) IPs are used in OVS vxlan config with ACC PRs mapped to host IDPF VF
+    local_vtep: ['10.1.1.1','11.1.1.1','12.1.1.1','13.1.1.1','14.1.1.1','15.1.1.1','16.1.1.1','17.1.1.1','18.1.1.1','19.1.1.1','20.1.1.1']
+    remote_vtep: ['10.1.1.2','11.1.1.2','12.1.1.2','13.1.1.2','14.1.1.2','15.1.1.2','16.1.1.2','17.1.1.2','18.1.1.2','19.1.1.2','20.1.1.2']
+    # Tunnel Termination Bridge IP for local and remote peer.
+    local_br_tun_ip: ['1.1.1.1','2.1.1.1']
+    remote_br_tun_ip: ['1.1.1.2','2.1.1.2']
diff --git a/ovs_offload/ovs_offload_lnv.py b/ovs_offload/ovs_offload_lnv.py
new file mode 100755
index 0000000..70e2856
--- /dev/null
+++ b/ovs_offload/ovs_offload_lnv.py
@@ -0,0 +1,770 @@
+#!/usr/bin/python
+#
+# Copyright 2022-2024 Intel Corporation
+# SPDX-License-Identifier: Apache 2.0
+#
+# Python tool to setup Linux Networking with OVS Offload on Intel速 Infrastructure Processing Unit (Intel速 IPU)
+
+import sys,argparse
+from common.utils import *
+
+def build_p4rt_config(vf_list=[], acc_pr_list=[],vm_ip_list=[], host_idpf_intf='', path=''):
+
+    print("---------- Generating Configs to run infrap4d, p4rt and OVS ----------")
+
+    if len(vf_list) != len(acc_pr_list):
+        print("ERROR: number of vfs and ACC PRs should be the same")
+        return None
+
+    host_command_list = []
+    cmd = f"mkdir -p {path}"
+    host_command_list.append(cmd)
+
+    file = f'{path}/1_host_idpf.sh'
+    host_idpf = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+#Load the driver
+echo "Load the IDPF Driver on the Host"
+#rmmod idpf
+modprobe idpf
+sleep 4
+
+echo ""
+echo "Check the Interfaces are up"
+ip -br a
+#Setup number of sriov devices on the IDPF interface
+echo "Create SRIOV VFs on IDPF interface '''+host_idpf_intf+'''"
+echo 8 > /sys/class/net/'''+host_idpf_intf+'''/device/sriov_numvfs
+
+echo ""
+echo "Wait for the interfaces to come up"
+sleep 5
+ip -br a
+EOF
+'''
+    host_command_list.append(host_idpf)
+    host_command_list.append(f"chmod +x ./{file}")
+    #host_command_list.append(f"./{file}")
+
+    for command in host_command_list:
+        try:
+            result = ssh_command('host', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+    time.sleep(5)
+
+    mac_list = []
+    vf_to_acc = ''
+    phy_to_acc = ''
+    vf_to_vm = ''
+    ovs_vxlan = ''
+    local_vtep = test_config['test_params']['local_vtep']
+    remote_vtep = test_config['test_params']['remote_vtep']
+    local_br_tun = test_config['test_params']['local_br_tun_ip']
+    remote_br_tun = test_config['test_params']['remote_br_tun_ip']
+    vm_id = 0
+    command_list = []
+    cmd = f"mkdir -p {path}"
+    command_list.append(cmd)
+    for i in range(len(vf_list)):
+
+        if str(vf_list[i]) == '0' or str(vf_list[i]) == '1':
+        #Physical port   VSI_ID  PORT             ACC port representer  VSI_ID    PORT
+        #Phy port 0      (0x0)    0     <---->    enp0s1f0d10         (0x11) 17   33
+            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            phy_to_acc += f"""echo ""
+echo "IPU Physical Port {vf_list[i]} maps to "
+echo "ACC IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.rx_source_port "vmeta.common.port_id={vf_list[i]},zero_padding=0,action=linux_networking_control.set_source_port({vf_list[i]})"
+p4rt-ctl add-entry br0 linux_networking_control.rx_phy_port_to_pr_map "vmeta.common.port_id={vf_list[i]},zero_padding=0,action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.source_port_to_pr_map "user_meta.cmeta.source_port={vf_list[i]},zero_padding=0,action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.tx_acc_vsi "vmeta.common.vsi={acc_pr['vsi_num']},zero_padding=0,action=linux_networking_control.l2_fwd_and_bypass_bridge({vf_list[i]})"
+sleep 2
+
+"""
+
+            ovs_vxlan += f"""echo ""
+echo "IPU Port {vf_list[i]} mapped to ACC Port {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']}:{acc_pr['port']})"
+echo "ACC Port {acc_pr_list[i]} is added to OVS bridge br-tun-{vf_list[i]}"
+ovs-vsctl del-br br-tun-{vf_list[i]}
+ovs-vsctl add-br br-tun-{vf_list[i]}
+ovs-vsctl add-port br-tun-{vf_list[i]} {acc_pr_list[i]}
+
+"""
+        else:
+            vf = get_interface_info(server_name='host', interface_name=vf_list[i])
+            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            #print(vf)
+            #print(acc_pr)
+            vf_to_acc += f"""echo ""
+echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']})  PORT ({vf['port']}) maps to"
+echo "ACC  IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.tx_source_port "vmeta.common.vsi={vf['vsi_num']}/2047,priority=1,action=linux_networking_control.set_source_port({vf['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.source_port_to_pr_map "user_meta.cmeta.source_port={vf['port']},zero_padding=0,action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.tx_acc_vsi "vmeta.common.vsi={acc_pr['vsi_num']},zero_padding=0,action=linux_networking_control.l2_fwd_and_bypass_bridge({vf['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.vsi_to_vsi_loopback "vmeta.common.vsi={acc_pr['vsi_num']},target_vsi={vf['vsi_num']},action=linux_networking_control.fwd_to_vsi({vf['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.vsi_to_vsi_loopback "vmeta.common.vsi={vf['vsi_num']},target_vsi={acc_pr['vsi_num']},action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+sleep 2
+
+"""
+            ovs_vxlan += f"""echo ""
+echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']}:{vf['port']}) maps to"
+echo "ACC Port {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']}:{acc_pr['port']})"
+echo "ACC Port {acc_pr_list[i]} is added to OVS bridge br{vm_id}"
+ip link del TEP{vm_id}
+ovs-vsctl del-br br{vm_id}
+ip link add dev TEP{vm_id} type dummy
+ifconfig TEP{vm_id} {local_vtep[vm_id]}/24 up
+ovs-vsctl add-br br{vm_id}
+ovs-vsctl add-port br{vm_id} {acc_pr_list[i]}
+ovs-vsctl add-port br{vm_id} vxlan{vm_id} -- set interface vxlan{vm_id} type=vxlan options:local_ip={local_vtep[vm_id]} options:remote_ip={remote_vtep[vm_id]} options:key=1{vm_id} options:dst_port=4789
+
+"""
+            vf_to_vm += f'''
+echo ""
+echo "Setup VM{vm_id} using ip netns (Network Namespace) to simulate a Virtual Machine"
+echo "Add HOST VF {vf_list[i]} to the VM{vm_id} namespace"
+ip netns del VM{vm_id}
+ip netns add VM{vm_id}
+sleep 1
+ip link set {vf_list[i]} netns VM{vm_id}
+ip netns exec VM{vm_id} ip addr add {vm_ip_list[vm_id]}/24 dev {vf_list[i]}
+ip netns exec VM{vm_id} ifconfig {vf_list[i]} up
+sleep 2
+ip netns exec VM{vm_id} ip -br a
+
+'''
+            vm_id += 1
+
+        mac_list.append(str(acc_pr['mac']))
+
+
+    misc = """p4rt-ctl add-entry br0 linux_networking_control.ipv4_lpm_root_lut "user_meta.cmeta.bit16_zeros=4/65535,priority=2048,action=linux_networking_control.ipv4_lpm_root_lut_action(0)"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=0/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=1/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=2/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=3/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=4/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=5/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=6/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=7/7,priority=1,action=linux_networking_control.bypass"
+"""
+
+    acc_path = test_config['test_params']['acc_path']
+    acc_p4_path = f'{acc_path}/fxp-net_linux-networking'
+    file = f'{path}/es2k_skip_p4.conf'
+    p4_config = 'cat <<EOF > ./'+file+'''
+{
+    "chip_list": [
+        {
+            "id": "asic-0",
+            "chip_family": "mev",
+            "instance": 0,
+            "pcie_bdf": "0000:00:01.6",
+            "iommu_grp_num": 7,
+            "ctrl_map" : ["NETDEV","''' + '","'.join(mac_list) + '''" ,1]
+        }
+    ],
+    "instance": 0,
+    "cfgqs-idx": "0-15",
+    "p4_devices": [
+        {
+            "device-id": 0,
+            "eal-args": "--lcores=1-2 -a 00:01.6,vport=[0-1] -- -i --rxq=1 --txq=1 --hairpinq=1 --hairpin-mode=0x0",
+            "p4_programs": [
+                {
+                    "program-name": "fxp-net_linux-networking",
+                    "tdi-config": "'''+acc_p4_path+'''/tdi.json",
+                    "p4_pipelines": [
+                        {
+                            "p4_pipeline_name": "main",
+                            "context": "'''+acc_p4_path+'''/context.json",
+                            "config": "'''+acc_p4_path+'''/ipu.bin",
+                            "pipe_scope": [
+                                0,
+                                1,
+                                2,
+                                3
+                            ],
+                            "path": "'''+acc_p4_path+'''/"
+                        }
+                    ]
+                }
+            ],
+            "agent0": "lib/libpltfm_mgr.so"
+        }
+    ]
+}
+EOF
+'''
+    command_list.append(p4_config)
+
+    command_list.append(host_idpf)
+
+    file = f'{path}/2_acc_infrap4d.sh'
+    acc_infrap4d = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+#ACC Environment for Infrap4d:
+echo ""
+echo "Setup the environment in ACC to run Infrap4d"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export no_proxy=localhost,127.0.0.1,192.168.0.0/16
+export NO_PROXY=localhost,127.0.0.1,192.168.0.0/16
+unset http_proxy
+unset https_proxy
+
+bash \$P4CP_INSTALL/sbin/setup_env.sh \$P4CP_INSTALL \$SDE_INSTALL \$DEPEND_INSTALL
+sudo \$P4CP_INSTALL/sbin/copy_config_files.sh \$P4CP_INSTALL \$SDE_INSTALL
+
+export OUTPUT_DIR='''+acc_p4_path+'''
+
+echo ""
+echo "Load the vfio-pci driver to bind the vfio-pci 00:01.6"
+sudo modprobe vfio-pci
+sudo /opt/p4/p4sde/bin/dpdk-devbind.py -b vfio-pci 00:01.6
+
+echo ""
+echo "Copy Infrap4d Config file es2k_skip_p4.conf to /usr/share/stratum/es2k/es2k_skip_p4.conf"
+touch \$OUTPUT_DIR/ipu.bin
+cp -f \$OUTPUT_DIR/es2k_skip_p4.conf /usr/share/stratum/es2k/es2k_skip_p4.conf
+
+echo ""
+echo "Verify the infrap4d config"
+cat /usr/share/stratum/es2k/es2k_skip_p4.conf
+
+#TLS CERTS
+echo ""
+echo "Generate the TLS Certs for Infrap4d"
+cd /usr/share/stratum/
+COMMON_NAME=localhost ./generate-certs.sh
+sleep 2
+
+echo ""
+echo "Start Infrap4d"
+#Start Infrap4d
+/opt/p4/p4-cp-nws/sbin/infrap4d --nodetach
+EOF
+'''
+
+    command_list.append(acc_infrap4d)
+
+    file = f'{path}/3_acc_p4rt.sh'
+    acc_p4rt = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup P4 Runtime Pipeline"
+echo "P4 Artifacts are in Folder : OUTPUT_DIR='''+acc_p4_path+'''"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+
+tdi_pipeline_builder --p4c_conf_file=/usr/share/stratum/es2k/es2k_skip_p4.conf --tdi_pipeline_config_binary_file=\$OUTPUT_DIR/fxp-net_linux-networking.pb.bin
+
+sleep 2
+echo ""
+echo "Use p4rt-ctl set-pipe to setup the runtime pipeline"
+p4rt-ctl set-pipe br0 \$OUTPUT_DIR/fxp-net_linux-networking.pb.bin \$OUTPUT_DIR/p4Info.txt
+sleep 2
+echo ""
+echo "Get IDPF Interface MAC and VSI info from IMC command : cli_client -q -c"
+echo "VSI (hexadecimal:decimal) PORT (VSI+16)"
+echo "Use p4rt-ctl to configure the VFs -- ACC PR"
+'''+vf_to_acc+'''
+sleep 2
+echo ""
+echo "Use p4rt-ctl to configure the Physical Ports -- ACC PR"
+'''+phy_to_acc+'''
+sleep 2
+echo ""
+echo "Configure supporting p4 runtime tables for LPM and LAG bypass"
+'''+misc+'''
+EOF
+'''
+    command_list.append(acc_p4rt)
+
+    file = f'{path}/acc_p4rt_delete.sh'
+    acc_p4rt_delete = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Delete the P4 Runtime Rules"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+
+
+echo "Use p4rt-ctl to remove the rules for the VFs -- ACC PR"
+'''+vf_to_acc+'''
+sleep 2
+echo ""
+echo "Use p4rt-ctl to remove the rules for Physical Ports -- ACC PR"
+'''+phy_to_acc+'''
+sleep 2
+echo ""
+echo "Remove supporting p4 runtime tables for LPM and LAG bypass"
+'''+misc+'''
+EOF
+'''
+    command_list.append(acc_p4rt_delete)
+
+    delete_command = f'''
+sed -i 's/add-entry/del-entry/g' {file}
+sed -i 's/,action.*"/"/g' {file}
+'''
+    command_list.append(delete_command)
+
+    file = f'{path}/4_acc_p4rt_dump.sh'
+    acc_p4rt_dump = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup P4 Runtime Pipeline"
+echo "P4 Artifacts are in Folder : OUTPUT_DIR='''+acc_p4_path+'''"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+
+
+echo ""
+echo "p4rt-ctl dump-entries br0 linux_networking_control.rx_source_port "
+p4rt-ctl dump-entries br0 linux_networking_control.rx_source_port
+
+#Run the p4rt-ctl dump-entries to display the table entries
+echo ""
+echo "Dump linux_networking_control.tx_source_port entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.tx_source_port"
+p4rt-ctl dump-entries br0 linux_networking_control.tx_source_port
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.source_port_to_pr_map entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.source_port_to_pr_map"
+p4rt-ctl dump-entries br0 linux_networking_control.source_port_to_pr_map
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.tx_acc_vsi entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.tx_acc_vsi"
+p4rt-ctl dump-entries br0 linux_networking_control.tx_acc_vsi
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.vsi_to_vsi_loopback entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.vsi_to_vsi_loopback"
+p4rt-ctl dump-entries br0 linux_networking_control.vsi_to_vsi_loopback
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.rx_phy_port_to_pr_map entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.rx_phy_port_to_pr_map"
+p4rt-ctl dump-entries br0 linux_networking_control.rx_phy_port_to_pr_map
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.tx_lag_table entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.tx_lag_table"
+p4rt-ctl dump-entries br0 linux_networking_control.tx_lag_table
+EOF
+'''
+
+    command_list.append(acc_p4rt_dump)
+    file = f'{path}/5_acc_setup_ovs.sh'
+    acc_setup_ovs = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+killall ovsdb-server
+killall ovs-vswitchd
+
+echo ""
+echo "Setup the Environment to run OVS"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+rm -rf \$RUN_OVS/etc/openvswitch
+rm -rf \$RUN_OVS/var/run/openvswitch
+mkdir -p \$RUN_OVS/etc/openvswitch/
+mkdir -p \$RUN_OVS/var/run/openvswitch
+
+ovsdb-tool create \$RUN_OVS/etc/openvswitch/conf.db \$RUN_OVS/share/openvswitch/vswitch.ovsschema
+
+echo ""
+echo "Start the ovsdb-server"
+ovsdb-server --remote=punix:\$RUN_OVS/var/run/openvswitch/db.sock --remote=db:Open_vSwitch,Open_vSwitch,manager_options --pidfile --detach
+
+ovs-vsctl --no-wait init
+
+echo ""
+echo "Start the ovs-vswitchd"
+mkdir -p /tmp/logs
+ovs-vswitchd --pidfile --detach --mlockall --log-file=/tmp/logs/ovs-vswitchd.log
+
+ovs-vsctl set Open_vSwitch . other_config:n-revalidator-threads=1
+ovs-vsctl set Open_vSwitch . other_config:n-handler-threads=1
+echo ""
+echo "Verify OVS: ovsdb-server and ovs-vswitchd are running"
+ovs-vsctl  show
+
+ps -aux | grep ovs
+EOF
+'''
+    command_list.append(acc_setup_ovs)
+    file = f'{path}/6_acc_ovs_bridge.sh'
+    acc_ovs_bridge = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup the Environment to run OVS"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+echo ""
+echo "Setup an OVS Bridge br-int-1"
+
+ovs-vsctl del-br br-int-1
+ovs-vsctl del-br br-int-2
+ovs-vsctl del-br br-tun-0
+ovs-vsctl del-br br-tun-1
+
+ip link del TEP0
+ovs-vsctl del-br br0
+ip link del TEP1
+ovs-vsctl del-br br1
+ip link del TEP2
+ovs-vsctl del-br br2
+ip link del TEP3
+ovs-vsctl del-br br3
+ip link del TEP4
+ovs-vsctl del-br br4
+ip link del TEP5
+ovs-vsctl del-br br5
+ip link del TEP6
+ovs-vsctl del-br br6
+ip link del TEP7
+ovs-vsctl del-br br7
+ip link del TEP8
+ovs-vsctl del-br br8
+
+#ovs-vsctl add-br br-int-1
+#ovs-vsctl add-port br-int-1 enp0s1f0d1
+#ovs-vsctl add-port br-int-1 enp0s1f0d2
+#ovs-vsctl add-port br-int-1 enp0s1f0d3
+#ovs-vsctl add-port br-int-1 enp0s1f0d4
+#ovs-vsctl add-port br-int-1 enp0s1f0d5
+#ovs-vsctl add-port br-int-1 enp0s1f0d6
+#ovs-vsctl add-port br-int-1 enp0s1f0d7
+#ovs-vsctl add-port br-int-1 enp0s1f0d8
+#ovs-vsctl add-port br-int-1 enp0s1f0d9
+#ovs-vsctl add-port br-int-1 enp0s1f0d10
+#ovs-vsctl add-port br-int-1 enp0s1f0d11
+#ovs-vsctl add-port br-int-1 enp0s1f0d12
+#ifconfig br-int-1 up
+
+ovs-vsctl add-br br-int-1
+ovs-vsctl add-port br-int-1 enp0s1f0d4
+ovs-vsctl add-port br-int-1 enp0s1f0d6
+ovs-vsctl add-port br-int-1 enp0s1f0d7
+ovs-vsctl add-port br-int-1 enp0s1f0d8
+ovs-vsctl add-port br-int-1 enp0s1f0d9
+ifconfig br-int-1 up
+
+ovs-vsctl add-br br-int-2
+ovs-vsctl add-port br-int-2 enp0s1f0d5
+ovs-vsctl add-port br-int-2 enp0s1f0d10
+ovs-vsctl add-port br-int-2 enp0s1f0d11
+ovs-vsctl add-port br-int-2 enp0s1f0d12
+ovs-vsctl add-port br-int-2 enp0s1f0d13
+ifconfig br-int-2 up
+
+sleep 2
+ovs-vsctl show
+
+echo "Check the interface configuration"
+sleep 1
+ip -br a
+
+echo ""
+echo "Configure the Host VM and Link Partner to test connectivity"
+EOF
+'''
+    command_list.append(acc_ovs_bridge)
+
+
+    file = f'{path}/acc_ovs_vxlan.sh'
+    acc_ovs_vxlan = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup the Environment to run OVS"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+ovs-vsctl del-br br-int-1
+ovs-vsctl del-br br-int-2
+
+'''+ovs_vxlan+'''
+ifconfig br-tun-0 '''+local_br_tun[0]+'''/24 up
+ifconfig br-tun-1 '''+local_br_tun[1]+'''/24 up
+ip route change 10.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+ip route change 11.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+ip route change 12.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+ip route change 13.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+ip route change 14.1.1.0/24 via '''+remote_br_tun[1]+''' dev br-tun-1
+ip route change 15.1.1.0/24 via '''+remote_br_tun[1]+''' dev br-tun-1
+ip route change 16.1.1.0/24 via '''+remote_br_tun[1]+''' dev br-tun-1
+ip route change 17.1.1.0/24 via '''+remote_br_tun[1]+''' dev br-tun-1
+
+sleep 2
+ovs-vsctl show
+
+echo "Check the interface configuration"
+sleep 1
+ip -br a
+
+EOF
+'''
+    command_list.append(acc_ovs_vxlan)
+
+    file = f'{path}/7_host_vm.sh'
+    host_vm = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+echo "Setup the Host VMs and VFs"
+
+'''+vf_to_vm+'''
+
+EOF
+'''
+    command_list.append(host_vm)
+    command_list.append(f"chmod +x {path}/*")
+
+    for command in command_list:
+        try:
+            result = ssh_command('host', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+
+    return None
+
+
+def build_args():
+    # Create the top-level parser
+    parser = argparse.ArgumentParser(description='Run Linux networking with OVS Offload')
+    subparsers = parser.add_subparsers(dest='command', help='options')
+    # Create the parser for the "create_script" command
+    parser_create_script = subparsers.add_parser('create_script', help='Generate configuration scripts in localhost')
+    # Create the parser for the "copy_script" command
+    parser_copy_script = subparsers.add_parser('copy_script', help='Copy configuration scripts to IMC and ACC')
+    # Create the parser for the "setup" command
+    parser_setup = subparsers.add_parser('setup', help='Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for scripts to be available in ACC')
+    # Create the parser for the "teardown" command
+    parser_teardown = subparsers.add_parser('teardown', help='Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once for scripts to be available in ACC')
+    return parser
+
+
+if __name__ == "__main__":
+    host_path = test_config['test_params']['host_path']
+    imc_path = test_config['test_params']['imc_path']
+    acc_path = test_config['test_params']['acc_path']
+    idpf_interface = test_config['test_params']['idpf_interface']
+    vf_interfaces = test_config['test_params']['vf_interfaces']
+    acc_pr_interfaces = test_config['test_params']['acc_pr_interfaces']
+    ip_list=test_config['test_params']['ip_list']
+    imc_ip = test_config['imc']['ssh']['ip']
+    acc_ip = test_config['acc']['ssh']['ip']
+    acc_p4_path = f'{acc_path}/fxp-net_linux-networking'
+    lp_interfaces = test_config['host']['lp_interfaces']
+    lp_interface_ip = test_config['host']['lp_interface_ip']
+    host_password = test_config['host']['ssh']['password']
+    imc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
+    acc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
+
+    parser = build_args()
+    # Parse the arguments
+    args = parser.parse_args()
+
+    # Execute the appropriate function based on the subcommand
+    if args.command == 'create_script':
+
+        print("\n----------------Create OVS OFFLOAD scripts----------------")
+        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list,host_idpf_intf=idpf_interface, path=host_path)
+
+    elif args.command == 'copy_script':
+        print("\n----------------Create OVS OFFLOAD scripts----------------")
+        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list,host_idpf_intf=idpf_interface, path=host_path)
+        print("\n----------------Copy OVS OFFLOAD scripts to the ACC----------------")
+        copy_scripts(host_path = host_path, imc_path = imc_path , acc_path = acc_path)
+
+    elif args.command == 'setup':
+
+        if host_password == '':
+            print("Enter correct IPU Host SSH root password in config.yaml and retry")
+            sys.exit()
+
+        print("\n----------------Setup Linux Networking with OVS OFFLOAD----------------")
+
+        # Setup a TMUX session, Login to ACC and start infrap4d
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        infrap4d = tmux_term(tmux_name="test1_infrap4d",tmux_override=True)
+        result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
+        result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
+
+        print("\n----------------Copy Infrap4d Configuration file----------------")
+        result = infrap4d.tmux_send_keys(f'yes | cp -f {acc_path}/{host_path}/es2k_skip_p4.conf {acc_path}/fxp-net_linux-networking/', delay=2, output=True)
+        print(result)
+        result = infrap4d.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+        result = infrap4d.tmux_send_keys('ls -lrt', delay=2, output=True)
+
+        print("\n----------------Start Infrap4d, wait for initialization to complete----------------")
+        result = infrap4d.tmux_send_keys('./2_acc_infrap4d.sh', delay=180, output=True)
+        print(result)
+
+        # Setup a TMUX session, Login to ACC, configure p4rt rules and ovs bridges
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        p4rt = tmux_term(tmux_name="test2_p4rt",tmux_override=True)
+        result = p4rt.tmux_send_keys(imc_login, delay=2)
+        result = p4rt.tmux_send_keys(acc_login, delay=2)
+        result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+
+        print("\n----------------Use p4rt-ctl to Add the rules----------------")
+        result = p4rt.tmux_send_keys('./3_acc_p4rt.sh', delay=60, output=True)
+        print(result)
+        print("\n----------------Use p4rt-ctl to Dump the rules----------------")
+        result = p4rt.tmux_send_keys('./4_acc_p4rt_dump.sh', delay=20, output=True)
+        print(result)
+
+        print("\n----------------Setup OVS Environment on the ACC----------------")
+        result = p4rt.tmux_send_keys('./5_acc_setup_ovs.sh', delay=10, output=True)
+        print(result)
+        print("\n----------------Configure OVS Bridges----------------")
+        result = p4rt.tmux_send_keys('./6_acc_ovs_bridge.sh', delay=10, output=True)
+        print(result)
+
+        print("\n----------------Setup TMUX Session and Login to the Host----------------")
+        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
+        result = host.tmux_send_keys('sudo -s', delay=2, output=True)
+        result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
+
+        print("\n----------------Configure the VMs on the Host and ADD the IDPF SR-IOV VFs----------------")
+        result = host.tmux_send_keys('ls -lrt', delay=2, output=True)
+        print(f'{result}')
+        result = host.tmux_send_keys('./7_host_vm.sh', delay=30, output=True)
+        print(result)
+
+        print("\n----------------Configure the Link Partner Interfaces----------------")
+        for idx in range(len(lp_interfaces)):
+            result = host.tmux_send_keys(f'ip a a dev {lp_interfaces[idx]} {lp_interface_ip[idx]}/24', delay=3, output=True)
+        result = host.tmux_send_keys('ip -br a', delay=3, output=True)
+        print(result)
+
+        print("\n----------------PING TEST: LINK Partner to Host VM IDPF VF----------------")
+        print(f"\nLINK Partner Interface IP : {lp_interface_ip}")
+        print(f"\nHost VM IDPF VF Interface IP : {ip_list}\n")
+        for ip in ip_list:
+            ping_test(dst_ip=ip, count=4)
+
+    elif args.command == 'teardown':
+
+        if host_password == '':
+            print("Enter correct IPU Host root password in config.yaml and retry")
+            sys.exit()
+
+        print("\n----------------Teardown Linux Networking with OVS OFFLOAD----------------")
+
+        print("\n----------------Setup TMUX Session and Login to the Host----------------")
+        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
+        result = host.tmux_send_keys('sudo -s', delay=2, output=True)
+        result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
+
+        print("\n----------------Delete the VMs on the Host----------------")
+        result = host.tmux_send_keys('ls -lrt', delay=2, output=True)
+        print(f'{result}')
+        command = '''ip netns del VM0
+ip netns del VM1
+ip netns del VM2
+ip netns del VM3
+ip netns del VM4
+ip netns del VM5
+ip netns del VM6
+ip netns del VM7
+'''
+        result = host.tmux_send_keys(command, delay=10, output=True)
+        print(result)
+        for idx in range(len(lp_interfaces)):
+            result = host.tmux_send_keys(f'ip a d dev {lp_interfaces[idx]} {lp_interface_ip[idx]}/24', delay=3, output=True)
+        result = host.tmux_send_keys('ip -br a', delay=3, output=True)
+        print(result)
+
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        p4rt = tmux_term(tmux_name="test2_p4rt",tmux_override=True)
+        result = p4rt.tmux_send_keys(imc_login, delay=2)
+        result = p4rt.tmux_send_keys(acc_login, delay=2)
+        result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+
+        print("\n----------------Cleanup OVS Bridge Configuration----------------")
+        command = f'''export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=$P4CP_INSTALL
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+ovs-vsctl show
+ovs-vsctl del-br br-int-1
+ovs-vsctl del-br br-int-2
+ovs-vsctl del-br br-tun-0
+ovs-vsctl del-br br-tun-1
+
+ip link del TEP0
+ovs-vsctl del-br br0
+ip link del TEP1
+ovs-vsctl del-br br1
+ip link del TEP2
+ovs-vsctl del-br br2
+ip link del TEP3
+ovs-vsctl del-br br3
+ip link del TEP4
+ovs-vsctl del-br br4
+ip link del TEP5
+ovs-vsctl del-br br5
+ip link del TEP6
+ovs-vsctl del-br br6
+ip link del TEP7
+ovs-vsctl del-br br7
+ovs-vsctl show
+'''
+        result = p4rt.tmux_send_keys(command, delay=20, output=True)
+        print(result)
+
+        print("\n----------------Use p4rt-ctl to Delete the rules----------------")
+        result = p4rt.tmux_send_keys('./acc_p4rt_delete.sh', delay=60, output=True)
+        print(result)
+        print("\n----------------Use p4rt-ctl to Dump the rules after cleanup----------------")
+        result = p4rt.tmux_send_keys('./4_acc_p4rt_dump.sh', delay=30, output=True)
+        print(result)
+
+        print("\n----------------Stop Infrap4d on the ACC----------------")
+        infrap4d = tmux_term(tmux_name="test1_infrap4d",tmux_override=True)
+        result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
+        result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
+        result = infrap4d.tmux_send_keys('ps -aux | grep infrap4d', delay=2, output=True)
+        print(result)
+
+    else:
+        parser.print_help()
+
diff --git a/ovs_offload/ovs_offload_lnv2.py b/ovs_offload/ovs_offload_lnv2.py
new file mode 100755
index 0000000..b0307b8
--- /dev/null
+++ b/ovs_offload/ovs_offload_lnv2.py
@@ -0,0 +1,770 @@
+#!/usr/bin/python
+#
+# Copyright 2022-2024 Intel Corporation
+# SPDX-License-Identifier: Apache 2.0
+#
+# Python tool to setup Linux Networking with OVS Offload on Intel速 Infrastructure Processing Unit (Intel速 IPU)
+
+import sys,argparse
+from common.utils import *
+
+def build_p4rt_config(vf_list=[], acc_pr_list=[],vm_ip_list=[], host_idpf_intf='', path=''):
+
+    print("---------- Generating Configs to run infrap4d, p4rt and OVS ----------")
+
+    if len(vf_list) != len(acc_pr_list):
+        print("ERROR: number of vfs and ACC PRs should be the same")
+        return None
+
+    host_command_list = []
+    cmd = f"mkdir -p {path}"
+    host_command_list.append(cmd)
+
+    file = f'{path}/1_host_idpf.sh'
+    host_idpf = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+#Load the driver
+echo "Load the IDPF Driver on the Host"
+#rmmod idpf
+modprobe idpf
+sleep 4
+
+echo ""
+echo "Check the Interfaces are up"
+ip -br a
+#Setup number of sriov devices on the IDPF interface
+echo "Create SRIOV VFs on IDPF interface '''+host_idpf_intf+'''"
+echo 8 > /sys/class/net/'''+host_idpf_intf+'''/device/sriov_numvfs
+
+echo ""
+echo "Wait for the interfaces to come up"
+sleep 5
+ip -br a
+EOF
+'''
+    host_command_list.append(host_idpf)
+    host_command_list.append(f"chmod +x ./{file}")
+    #host_command_list.append(f"./{file}")
+
+    for command in host_command_list:
+        try:
+            result = ssh_command('host', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+    time.sleep(5)
+
+    mac_list = []
+    vf_to_acc = ''
+    phy_to_acc = ''
+    vf_to_vm = ''
+    ovs_vxlan = ''
+    local_vtep = test_config['test_params']['local_vtep']
+    remote_vtep = test_config['test_params']['remote_vtep']
+    local_br_tun = test_config['test_params']['local_br_tun_ip']
+    remote_br_tun = test_config['test_params']['remote_br_tun_ip']
+    vm_id = 0
+    command_list = []
+    cmd = f"mkdir -p {path}"
+    command_list.append(cmd)
+    for i in range(len(vf_list)):
+
+        if str(vf_list[i]) == '0' or str(vf_list[i]) == '1':
+        #Physical port   VSI_ID  PORT             ACC port representer  VSI_ID    PORT
+        #Phy port 0      (0x0)    0     <---->    enp0s1f0d10         (0x11) 17   33
+            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            phy_to_acc += f"""echo ""
+echo "IPU Physical Port {vf_list[i]} maps to "
+echo "ACC IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.rx_source_port "vmeta.common.port_id={vf_list[i]},zero_padding=0,action=linux_networking_control.set_source_port({vf_list[i]})"
+p4rt-ctl add-entry br0 linux_networking_control.rx_phy_port_to_pr_map "vmeta.common.port_id={vf_list[i]},zero_padding=0,action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.source_port_to_pr_map "user_meta.cmeta.source_port={vf_list[i]},zero_padding=0,action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.tx_acc_vsi "vmeta.common.vsi={acc_pr['vsi_num']},zero_padding=0,action=linux_networking_control.l2_fwd_and_bypass_bridge({vf_list[i]})"
+sleep 2
+
+"""
+
+            ovs_vxlan += f"""echo ""
+echo "IPU Port {vf_list[i]} mapped to ACC Port {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']}:{acc_pr['port']})"
+echo "ACC Port {acc_pr_list[i]} is added to OVS bridge br-tun-{vf_list[i]}"
+ovs-vsctl del-br br-tun-{vf_list[i]}
+ovs-vsctl add-br br-tun-{vf_list[i]}
+ovs-vsctl add-port br-tun-{vf_list[i]} {acc_pr_list[i]}
+
+"""
+        else:
+            vf = get_interface_info(server_name='host', interface_name=vf_list[i])
+            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            #print(vf)
+            #print(acc_pr)
+            vf_to_acc += f"""echo ""
+echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']})  PORT ({vf['port']}) maps to"
+echo "ACC  IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.tx_source_port_v4 "vmeta.common.vsi={vf['vsi_num']},zero_padding=0,action=linux_networking_control.set_source_port({vf['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.source_port_to_pr_map "user_meta.cmeta.source_port={vf['port']},zero_padding=0,action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.tx_acc_vsi "vmeta.common.vsi={acc_pr['vsi_num']},zero_padding=0,action=linux_networking_control.l2_fwd_and_bypass_bridge({vf['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.vsi_to_vsi_loopback "vmeta.common.vsi={acc_pr['vsi_num']},target_vsi={vf['vsi_num']},action=linux_networking_control.fwd_to_vsi({vf['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.vsi_to_vsi_loopback "vmeta.common.vsi={vf['vsi_num']},target_vsi={acc_pr['vsi_num']},action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+sleep 2
+
+"""
+            ovs_vxlan += f"""echo ""
+echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']}:{vf['port']}) maps to"
+echo "ACC Port {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']}:{acc_pr['port']})"
+echo "ACC Port {acc_pr_list[i]} is added to OVS bridge br{vm_id}"
+ip link del TEP{vm_id}
+ovs-vsctl del-br br{vm_id}
+ip link add dev TEP{vm_id} type dummy
+ifconfig TEP{vm_id} {local_vtep[vm_id]}/24 up
+ovs-vsctl add-br br{vm_id}
+ovs-vsctl add-port br{vm_id} {acc_pr_list[i]}
+ovs-vsctl add-port br{vm_id} vxlan{vm_id} -- set interface vxlan{vm_id} type=vxlan options:local_ip={local_vtep[vm_id]} options:remote_ip={remote_vtep[vm_id]} options:key=1{vm_id} options:dst_port=4789
+
+"""
+            vf_to_vm += f'''
+echo ""
+echo "Setup VM{vm_id} using ip netns (Network Namespace) to simulate a Virtual Machine"
+echo "Add HOST VF {vf_list[i]} to the VM{vm_id} namespace"
+ip netns del VM{vm_id}
+ip netns add VM{vm_id}
+sleep 1
+ip link set {vf_list[i]} netns VM{vm_id}
+ip netns exec VM{vm_id} ip addr add {vm_ip_list[vm_id]}/24 dev {vf_list[i]}
+ip netns exec VM{vm_id} ifconfig {vf_list[i]} up
+sleep 2
+ip netns exec VM{vm_id} ip -br a
+
+'''
+            vm_id += 1
+
+        mac_list.append(str(acc_pr['mac']))
+
+
+    misc = """p4rt-ctl add-entry br0 linux_networking_control.ipv4_lpm_root_lut "user_meta.cmeta.bit32_zeros=4/255.255.255.255,priority=65535,action=linux_networking_control.ipv4_lpm_root_lut_action(0)"
+p4rt-ctl add-entry br0  linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0,hash=0,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0  linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0,hash=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0  linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0,hash=2,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0  linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0,hash=3,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0  linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0,hash=4,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0  linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0,hash=5,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0  linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0,hash=6,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0  linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0,hash=7,action=linux_networking_control.bypass"
+"""
+
+    acc_path = test_config['test_params']['acc_path']
+    acc_p4_path = f'{acc_path}/fxp-net_linux-networking-v2'
+    file = f'{path}/es2k_skip_p4.conf'
+    p4_config = 'cat <<EOF > ./'+file+'''
+{
+    "chip_list": [
+        {
+            "id": "asic-0",
+            "chip_family": "mev",
+            "instance": 0,
+            "pcie_bdf": "0000:00:01.6",
+            "iommu_grp_num": 7,
+            "ctrl_map" : ["NETDEV","''' + '","'.join(mac_list) + '''" ,1]
+        }
+    ],
+    "instance": 0,
+    "cfgqs-idx": "0-15",
+    "p4_devices": [
+        {
+            "device-id": 0,
+            "eal-args": "--lcores=1-2 -a 00:01.6,vport=[0-1] -- -i --rxq=1 --txq=1 --hairpinq=1 --hairpin-mode=0x0",
+            "p4_programs": [
+                {
+                    "program-name": "fxp-net_linux-networking-v2",
+                    "tdi-config": "'''+acc_p4_path+'''/tdi.json",
+                    "p4_pipelines": [
+                        {
+                            "p4_pipeline_name": "main",
+                            "context": "'''+acc_p4_path+'''/context.json",
+                            "config": "'''+acc_p4_path+'''/ipu.bin",
+                            "pipe_scope": [
+                                0,
+                                1,
+                                2,
+                                3
+                            ],
+                            "path": "'''+acc_p4_path+'''/"
+                        }
+                    ]
+                }
+            ],
+            "agent0": "lib/libpltfm_mgr.so"
+        }
+    ]
+}
+EOF
+'''
+    command_list.append(p4_config)
+
+    command_list.append(host_idpf)
+
+    file = f'{path}/2_acc_infrap4d.sh'
+    acc_infrap4d = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+#ACC Environment for Infrap4d:
+echo ""
+echo "Setup the environment in ACC to run Infrap4d"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export no_proxy=localhost,127.0.0.1,192.168.0.0/16
+export NO_PROXY=localhost,127.0.0.1,192.168.0.0/16
+unset http_proxy
+unset https_proxy
+
+bash \$P4CP_INSTALL/sbin/setup_env.sh \$P4CP_INSTALL \$SDE_INSTALL \$DEPEND_INSTALL
+sudo \$P4CP_INSTALL/sbin/copy_config_files.sh \$P4CP_INSTALL \$SDE_INSTALL
+
+export OUTPUT_DIR='''+acc_p4_path+'''
+
+echo ""
+echo "Load the vfio-pci driver to bind the vfio-pci 00:01.6"
+sudo modprobe vfio-pci
+sudo /opt/p4/p4sde/bin/dpdk-devbind.py -b vfio-pci 00:01.6
+
+echo ""
+echo "Copy Infrap4d Config file es2k_skip_p4.conf to /usr/share/stratum/es2k/es2k_skip_p4.conf"
+touch \$OUTPUT_DIR/ipu.bin
+cp -f \$OUTPUT_DIR/es2k_skip_p4.conf /usr/share/stratum/es2k/es2k_skip_p4.conf
+
+echo ""
+echo "Verify the infrap4d config"
+cat /usr/share/stratum/es2k/es2k_skip_p4.conf
+
+#TLS CERTS
+echo ""
+echo "Generate the TLS Certs for Infrap4d"
+cd /usr/share/stratum/
+COMMON_NAME=localhost ./generate-certs.sh
+sleep 2
+
+echo ""
+echo "Start Infrap4d"
+#Start Infrap4d
+/opt/p4/p4-cp-nws/sbin/infrap4d --nodetach
+EOF
+'''
+
+    command_list.append(acc_infrap4d)
+
+    file = f'{path}/3_acc_p4rt.sh'
+    acc_p4rt = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup P4 Runtime Pipeline"
+echo "P4 Artifacts are in Folder : OUTPUT_DIR='''+acc_p4_path+'''"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+
+tdi_pipeline_builder --p4c_conf_file=/usr/share/stratum/es2k/es2k_skip_p4.conf --bf_pipeline_config_binary_file=\$OUTPUT_DIR/fxp-net_linux-networking-v2.pb.bin
+
+sleep 2
+echo ""
+echo "Use p4rt-ctl set-pipe to setup the runtime pipeline"
+p4rt-ctl set-pipe br0 \$OUTPUT_DIR/fxp-net_linux-networking-v2.pb.bin \$OUTPUT_DIR/p4Info.txt
+sleep 2
+echo ""
+echo "Get IDPF Interface MAC and VSI info from IMC command : cli_client -q -c"
+echo "VSI (hexadecimal:decimal) PORT (VSI+16)"
+echo "Use p4rt-ctl to configure the VFs -- ACC PR"
+'''+vf_to_acc+'''
+sleep 2
+echo ""
+echo "Use p4rt-ctl to configure the Physical Ports -- ACC PR"
+'''+phy_to_acc+'''
+sleep 2
+echo ""
+echo "Configure supporting p4 runtime tables for LPM and LAG bypass"
+'''+misc+'''
+EOF
+'''
+    command_list.append(acc_p4rt)
+
+    file = f'{path}/acc_p4rt_delete.sh'
+    acc_p4rt_delete = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Delete the P4 Runtime Rules"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+
+
+echo "Use p4rt-ctl to remove the rules for the VFs -- ACC PR"
+'''+vf_to_acc+'''
+sleep 2
+echo ""
+echo "Use p4rt-ctl to remove the rules for Physical Ports -- ACC PR"
+'''+phy_to_acc+'''
+sleep 2
+echo ""
+echo "Remove supporting p4 runtime tables for LPM and LAG bypass"
+'''+misc+'''
+EOF
+'''
+    command_list.append(acc_p4rt_delete)
+
+    delete_command = f'''
+sed -i 's/add-entry/del-entry/g' {file}
+sed -i 's/,action.*"/"/g' {file}
+'''
+    command_list.append(delete_command)
+
+    file = f'{path}/4_acc_p4rt_dump.sh'
+    acc_p4rt_dump = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup P4 Runtime Pipeline"
+echo "P4 Artifacts are in Folder : OUTPUT_DIR='''+acc_p4_path+'''"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+
+
+echo ""
+echo "p4rt-ctl dump-entries br0 linux_networking_control.rx_source_port "
+p4rt-ctl dump-entries br0 linux_networking_control.rx_source_port
+
+#Run the p4rt-ctl dump-entries to display the table entries
+echo ""
+echo "Dump linux_networking_control.tx_source_port_v4 entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.tx_source_port_v4"
+p4rt-ctl dump-entries br0 linux_networking_control.tx_source_port_v4
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.source_port_to_pr_map entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.source_port_to_pr_map"
+p4rt-ctl dump-entries br0 linux_networking_control.source_port_to_pr_map
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.tx_acc_vsi entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.tx_acc_vsi"
+p4rt-ctl dump-entries br0 linux_networking_control.tx_acc_vsi
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.vsi_to_vsi_loopback entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.vsi_to_vsi_loopback"
+p4rt-ctl dump-entries br0 linux_networking_control.vsi_to_vsi_loopback
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.rx_phy_port_to_pr_map entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.rx_phy_port_to_pr_map"
+p4rt-ctl dump-entries br0 linux_networking_control.rx_phy_port_to_pr_map
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.tx_lag_table entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.tx_lag_table"
+p4rt-ctl dump-entries br0 linux_networking_control.tx_lag_table
+EOF
+'''
+
+    command_list.append(acc_p4rt_dump)
+    file = f'{path}/5_acc_setup_ovs.sh'
+    acc_setup_ovs = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+killall ovsdb-server
+killall ovs-vswitchd
+
+echo ""
+echo "Setup the Environment to run OVS"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+rm -rf \$RUN_OVS/etc/openvswitch
+rm -rf \$RUN_OVS/var/run/openvswitch
+mkdir -p \$RUN_OVS/etc/openvswitch/
+mkdir -p \$RUN_OVS/var/run/openvswitch
+
+ovsdb-tool create \$RUN_OVS/etc/openvswitch/conf.db \$RUN_OVS/share/openvswitch/vswitch.ovsschema
+
+echo ""
+echo "Start the ovsdb-server"
+ovsdb-server --remote=punix:\$RUN_OVS/var/run/openvswitch/db.sock --remote=db:Open_vSwitch,Open_vSwitch,manager_options --pidfile --detach
+
+ovs-vsctl --no-wait init
+
+echo ""
+echo "Start the ovs-vswitchd"
+mkdir -p /tmp/logs
+ovs-vswitchd --pidfile --detach --mlockall --log-file=/tmp/logs/ovs-vswitchd.log
+
+ovs-vsctl set Open_vSwitch . other_config:n-revalidator-threads=1
+ovs-vsctl set Open_vSwitch . other_config:n-handler-threads=1
+echo ""
+echo "Verify OVS: ovsdb-server and ovs-vswitchd are running"
+ovs-vsctl  show
+
+ps -aux | grep ovs
+EOF
+'''
+    command_list.append(acc_setup_ovs)
+    file = f'{path}/6_acc_ovs_bridge.sh'
+    acc_ovs_bridge = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup the Environment to run OVS"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+echo ""
+echo "Setup an OVS Bridge br-int-1"
+
+ovs-vsctl del-br br-int-1
+ovs-vsctl del-br br-int-2
+ovs-vsctl del-br br-tun-0
+ovs-vsctl del-br br-tun-1
+
+ip link del TEP0
+ovs-vsctl del-br br0
+ip link del TEP1
+ovs-vsctl del-br br1
+ip link del TEP2
+ovs-vsctl del-br br2
+ip link del TEP3
+ovs-vsctl del-br br3
+ip link del TEP4
+ovs-vsctl del-br br4
+ip link del TEP5
+ovs-vsctl del-br br5
+ip link del TEP6
+ovs-vsctl del-br br6
+ip link del TEP7
+ovs-vsctl del-br br7
+ip link del TEP8
+ovs-vsctl del-br br8
+
+#ovs-vsctl add-br br-int-1
+#ovs-vsctl add-port br-int-1 enp0s1f0d1
+#ovs-vsctl add-port br-int-1 enp0s1f0d2
+#ovs-vsctl add-port br-int-1 enp0s1f0d3
+#ovs-vsctl add-port br-int-1 enp0s1f0d4
+#ovs-vsctl add-port br-int-1 enp0s1f0d5
+#ovs-vsctl add-port br-int-1 enp0s1f0d6
+#ovs-vsctl add-port br-int-1 enp0s1f0d7
+#ovs-vsctl add-port br-int-1 enp0s1f0d8
+#ovs-vsctl add-port br-int-1 enp0s1f0d9
+#ovs-vsctl add-port br-int-1 enp0s1f0d10
+#ovs-vsctl add-port br-int-1 enp0s1f0d11
+#ovs-vsctl add-port br-int-1 enp0s1f0d12
+#ifconfig br-int-1 up
+
+ovs-vsctl add-br br-int-1
+ovs-vsctl add-port br-int-1 enp0s1f0d4
+ovs-vsctl add-port br-int-1 enp0s1f0d6
+ovs-vsctl add-port br-int-1 enp0s1f0d7
+ovs-vsctl add-port br-int-1 enp0s1f0d8
+ovs-vsctl add-port br-int-1 enp0s1f0d9
+ifconfig br-int-1 up
+
+ovs-vsctl add-br br-int-2
+ovs-vsctl add-port br-int-2 enp0s1f0d5
+ovs-vsctl add-port br-int-2 enp0s1f0d10
+ovs-vsctl add-port br-int-2 enp0s1f0d11
+ovs-vsctl add-port br-int-2 enp0s1f0d12
+ovs-vsctl add-port br-int-2 enp0s1f0d13
+ifconfig br-int-2 up
+
+sleep 2
+ovs-vsctl show
+
+echo "Check the interface configuration"
+sleep 1
+ip -br a
+
+echo ""
+echo "Configure the Host VM and Link Partner to test connectivity"
+EOF
+'''
+    command_list.append(acc_ovs_bridge)
+
+
+    file = f'{path}/acc_ovs_vxlan.sh'
+    acc_ovs_vxlan = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup the Environment to run OVS"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+ovs-vsctl del-br br-int-1
+ovs-vsctl del-br br-int-2
+
+'''+ovs_vxlan+'''
+ifconfig br-tun-0 '''+local_br_tun[0]+'''/24 up
+ifconfig br-tun-1 '''+local_br_tun[1]+'''/24 up
+ip route change 10.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+ip route change 11.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+ip route change 12.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+ip route change 13.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+ip route change 14.1.1.0/24 via '''+remote_br_tun[1]+''' dev br-tun-1
+ip route change 15.1.1.0/24 via '''+remote_br_tun[1]+''' dev br-tun-1
+ip route change 16.1.1.0/24 via '''+remote_br_tun[1]+''' dev br-tun-1
+ip route change 17.1.1.0/24 via '''+remote_br_tun[1]+''' dev br-tun-1
+
+sleep 2
+ovs-vsctl show
+
+echo "Check the interface configuration"
+sleep 1
+ip -br a
+
+EOF
+'''
+    command_list.append(acc_ovs_vxlan)
+
+    file = f'{path}/7_host_vm.sh'
+    host_vm = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+echo "Setup the Host VMs and VFs"
+
+'''+vf_to_vm+'''
+
+EOF
+'''
+    command_list.append(host_vm)
+    command_list.append(f"chmod +x {path}/*")
+
+    for command in command_list:
+        try:
+            result = ssh_command('host', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+
+    return None
+
+
+def build_args():
+    # Create the top-level parser
+    parser = argparse.ArgumentParser(description='Run Linux networking with OVS Offload')
+    subparsers = parser.add_subparsers(dest='command', help='options')
+    # Create the parser for the "create_script" command
+    parser_create_script = subparsers.add_parser('create_script', help='Generate configuration scripts in localhost')
+    # Create the parser for the "copy_script" command
+    parser_copy_script = subparsers.add_parser('copy_script', help='Copy configuration scripts to IMC and ACC')
+    # Create the parser for the "setup" command
+    parser_setup = subparsers.add_parser('setup', help='Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for scripts to be available in ACC')
+    # Create the parser for the "teardown" command
+    parser_teardown = subparsers.add_parser('teardown', help='Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once for scripts to be available in ACC')
+    return parser
+
+
+if __name__ == "__main__":
+    host_path = test_config['test_params']['host_path']
+    imc_path = test_config['test_params']['imc_path']
+    acc_path = test_config['test_params']['acc_path']
+    idpf_interface = test_config['test_params']['idpf_interface']
+    vf_interfaces = test_config['test_params']['vf_interfaces']
+    acc_pr_interfaces = test_config['test_params']['acc_pr_interfaces']
+    ip_list=test_config['test_params']['ip_list']
+    imc_ip = test_config['imc']['ssh']['ip']
+    acc_ip = test_config['acc']['ssh']['ip']
+    acc_p4_path = f'{acc_path}/fxp-net_linux-networking'
+    lp_interfaces = test_config['host']['lp_interfaces']
+    lp_interface_ip = test_config['host']['lp_interface_ip']
+    host_password = test_config['host']['ssh']['password']
+    imc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
+    acc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
+
+    parser = build_args()
+    # Parse the arguments
+    args = parser.parse_args()
+
+    # Execute the appropriate function based on the subcommand
+    if args.command == 'create_script':
+
+        print("\n----------------Create OVS OFFLOAD scripts----------------")
+        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list,host_idpf_intf=idpf_interface, path=host_path)
+
+    elif args.command == 'copy_script':
+        print("\n----------------Create OVS OFFLOAD scripts----------------")
+        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list,host_idpf_intf=idpf_interface, path=host_path)
+        print("\n----------------Copy OVS OFFLOAD scripts to the ACC----------------")
+        copy_scripts(host_path = host_path, imc_path = imc_path , acc_path = acc_path)
+
+    elif args.command == 'setup':
+
+        if host_password == '':
+            print("Enter correct IPU Host SSH root password in config.yaml and retry")
+            sys.exit()
+
+        print("\n----------------Setup Linux Networking with OVS OFFLOAD----------------")
+
+        # Setup a TMUX session, Login to ACC and start infrap4d
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        infrap4d = tmux_term(tmux_name="test1_infrap4d",tmux_override=True)
+        result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
+        result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
+
+        print("\n----------------Copy Infrap4d Configuration file----------------")
+        result = infrap4d.tmux_send_keys(f'yes | cp -f {acc_path}/{host_path}/es2k_skip_p4.conf {acc_path}/fxp-net_linux-networking/', delay=2, output=True)
+        print(result)
+        result = infrap4d.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+        result = infrap4d.tmux_send_keys('ls -lrt', delay=2, output=True)
+
+        print("\n----------------Start Infrap4d, wait for initialization to complete----------------")
+        result = infrap4d.tmux_send_keys('./2_acc_infrap4d.sh', delay=180, output=True)
+        print(result)
+
+        # Setup a TMUX session, Login to ACC, configure p4rt rules and ovs bridges
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        p4rt = tmux_term(tmux_name="test2_p4rt",tmux_override=True)
+        result = p4rt.tmux_send_keys(imc_login, delay=2)
+        result = p4rt.tmux_send_keys(acc_login, delay=2)
+        result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+
+        print("\n----------------Use p4rt-ctl to Add the rules----------------")
+        result = p4rt.tmux_send_keys('./3_acc_p4rt.sh', delay=60, output=True)
+        print(result)
+        print("\n----------------Use p4rt-ctl to Dump the rules----------------")
+        result = p4rt.tmux_send_keys('./4_acc_p4rt_dump.sh', delay=20, output=True)
+        print(result)
+
+        print("\n----------------Setup OVS Environment on the ACC----------------")
+        result = p4rt.tmux_send_keys('./5_acc_setup_ovs.sh', delay=10, output=True)
+        print(result)
+        print("\n----------------Configure OVS Bridges----------------")
+        result = p4rt.tmux_send_keys('./6_acc_ovs_bridge.sh', delay=10, output=True)
+        print(result)
+
+        print("\n----------------Setup TMUX Session and Login to the Host----------------")
+        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
+        result = host.tmux_send_keys('sudo -s', delay=2, output=True)
+        result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
+
+        print("\n----------------Configure the VMs on the Host and ADD the IDPF SR-IOV VFs----------------")
+        result = host.tmux_send_keys('ls -lrt', delay=2, output=True)
+        print(f'{result}')
+        result = host.tmux_send_keys('./7_host_vm.sh', delay=30, output=True)
+        print(result)
+
+        print("\n----------------Configure the Link Partner Interfaces----------------")
+        for idx in range(len(lp_interfaces)):
+            result = host.tmux_send_keys(f'ip a a dev {lp_interfaces[idx]} {lp_interface_ip[idx]}/24', delay=3, output=True)
+        result = host.tmux_send_keys('ip -br a', delay=3, output=True)
+        print(result)
+
+        print("\n----------------PING TEST: LINK Partner to Host VM IDPF VF----------------")
+        print(f"\nLINK Partner Interface IP : {lp_interface_ip}")
+        print(f"\nHost VM IDPF VF Interface IP : {ip_list}\n")
+        for ip in ip_list:
+            ping_test(dst_ip=ip, count=4)
+
+    elif args.command == 'teardown':
+
+        if host_password == '':
+            print("Enter correct IPU Host root password in config.yaml and retry")
+            sys.exit()
+
+        print("\n----------------Teardown Linux Networking with OVS OFFLOAD----------------")
+
+        print("\n----------------Setup TMUX Session and Login to the Host----------------")
+        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
+        result = host.tmux_send_keys('sudo -s', delay=2, output=True)
+        result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
+
+        print("\n----------------Delete the VMs on the Host----------------")
+        result = host.tmux_send_keys('ls -lrt', delay=2, output=True)
+        print(f'{result}')
+        command = '''ip netns del VM0
+ip netns del VM1
+ip netns del VM2
+ip netns del VM3
+ip netns del VM4
+ip netns del VM5
+ip netns del VM6
+ip netns del VM7
+'''
+        result = host.tmux_send_keys(command, delay=10, output=True)
+        print(result)
+        for idx in range(len(lp_interfaces)):
+            result = host.tmux_send_keys(f'ip a d dev {lp_interfaces[idx]} {lp_interface_ip[idx]}/24', delay=3, output=True)
+        result = host.tmux_send_keys('ip -br a', delay=3, output=True)
+        print(result)
+
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        p4rt = tmux_term(tmux_name="test2_p4rt",tmux_override=True)
+        result = p4rt.tmux_send_keys(imc_login, delay=2)
+        result = p4rt.tmux_send_keys(acc_login, delay=2)
+        result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+
+        print("\n----------------Cleanup OVS Bridge Configuration----------------")
+        command = f'''export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=$P4CP_INSTALL
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+ovs-vsctl show
+ovs-vsctl del-br br-int-1
+ovs-vsctl del-br br-int-2
+ovs-vsctl del-br br-tun-0
+ovs-vsctl del-br br-tun-1
+
+ip link del TEP0
+ovs-vsctl del-br br0
+ip link del TEP1
+ovs-vsctl del-br br1
+ip link del TEP2
+ovs-vsctl del-br br2
+ip link del TEP3
+ovs-vsctl del-br br3
+ip link del TEP4
+ovs-vsctl del-br br4
+ip link del TEP5
+ovs-vsctl del-br br5
+ip link del TEP6
+ovs-vsctl del-br br6
+ip link del TEP7
+ovs-vsctl del-br br7
+ovs-vsctl show
+'''
+        result = p4rt.tmux_send_keys(command, delay=20, output=True)
+        print(result)
+
+        print("\n----------------Use p4rt-ctl to Delete the rules----------------")
+        result = p4rt.tmux_send_keys('./acc_p4rt_delete.sh', delay=60, output=True)
+        print(result)
+        print("\n----------------Use p4rt-ctl to Dump the rules after cleanup----------------")
+        result = p4rt.tmux_send_keys('./4_acc_p4rt_dump.sh', delay=30, output=True)
+        print(result)
+
+        print("\n----------------Stop Infrap4d on the ACC----------------")
+        infrap4d = tmux_term(tmux_name="test1_infrap4d",tmux_override=True)
+        result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
+        result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
+        result = infrap4d.tmux_send_keys('ps -aux | grep infrap4d', delay=2, output=True)
+        print(result)
+
+    else:
+        parser.print_help()
+
diff --git a/ovs_offload/ovs_offload_lnv3.py b/ovs_offload/ovs_offload_lnv3.py
new file mode 100755
index 0000000..827f0e7
--- /dev/null
+++ b/ovs_offload/ovs_offload_lnv3.py
@@ -0,0 +1,770 @@
+#!/usr/bin/python
+#
+# Copyright 2022-2024 Intel Corporation
+# SPDX-License-Identifier: Apache 2.0
+#
+# Python tool to setup Linux Networking with OVS Offload on Intel速 Infrastructure Processing Unit (Intel速 IPU)
+
+import sys,argparse
+from common.utils import *
+
+def build_p4rt_config(vf_list=[], acc_pr_list=[],vm_ip_list=[], host_idpf_intf='', path=''):
+
+    print("---------- Generating Configs to run infrap4d, p4rt and OVS ----------")
+
+    if len(vf_list) != len(acc_pr_list):
+        print("ERROR: number of vfs and ACC PRs should be the same")
+        return None
+
+    host_command_list = []
+    cmd = f"mkdir -p {path}"
+    host_command_list.append(cmd)
+
+    file = f'{path}/1_host_idpf.sh'
+    host_idpf = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+#Load the driver
+echo "Load the IDPF Driver on the Host"
+#rmmod idpf
+modprobe idpf
+sleep 4
+
+echo ""
+echo "Check the Interfaces are up"
+ip -br a
+#Setup number of sriov devices on the IDPF interface
+echo "Create SRIOV VFs on IDPF interface '''+host_idpf_intf+'''"
+echo 8 > /sys/class/net/'''+host_idpf_intf+'''/device/sriov_numvfs
+
+echo ""
+echo "Wait for the interfaces to come up"
+sleep 5
+ip -br a
+EOF
+'''
+    host_command_list.append(host_idpf)
+    host_command_list.append(f"chmod +x ./{file}")
+    #host_command_list.append(f"./{file}")
+
+    for command in host_command_list:
+        try:
+            result = ssh_command('host', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+    time.sleep(5)
+
+    mac_list = []
+    vf_to_acc = ''
+    phy_to_acc = ''
+    vf_to_vm = ''
+    ovs_vxlan = ''
+    local_vtep = test_config['test_params']['local_vtep']
+    remote_vtep = test_config['test_params']['remote_vtep']
+    local_br_tun = test_config['test_params']['local_br_tun_ip']
+    remote_br_tun = test_config['test_params']['remote_br_tun_ip']
+    vm_id = 0
+    command_list = []
+    cmd = f"mkdir -p {path}"
+    command_list.append(cmd)
+    for i in range(len(vf_list)):
+
+        if str(vf_list[i]) == '0' or str(vf_list[i]) == '1':
+        #Physical port   VSI_ID  PORT             ACC port representer  VSI_ID    PORT
+        #Phy port 0      (0x0)    0     <---->    enp0s1f0d10         (0x11) 17   33
+            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            phy_to_acc += f"""echo ""
+echo "IPU Physical Port {vf_list[i]} maps to "
+echo "ACC IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.rx_source_port "vmeta.common.port_id={vf_list[i]},zero_padding=0,action=linux_networking_control.set_source_port({vf_list[i]})"
+p4rt-ctl add-entry br0 linux_networking_control.rx_phy_port_to_pr_map "vmeta.common.port_id={vf_list[i]},zero_padding=0,action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.source_port_to_pr_map "user_meta.cmeta.source_port={vf_list[i]},zero_padding=0,action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.tx_acc_vsi "vmeta.common.vsi={acc_pr['vsi_num']},zero_padding=0,action=linux_networking_control.l2_fwd_and_bypass_bridge({vf_list[i]})"
+sleep 2
+
+"""
+
+            ovs_vxlan += f"""echo ""
+echo "IPU Port {vf_list[i]} mapped to ACC Port {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']}:{acc_pr['port']})"
+echo "ACC Port {acc_pr_list[i]} is added to OVS bridge br-tun-{vf_list[i]}"
+ovs-vsctl del-br br-tun-{vf_list[i]}
+ovs-vsctl add-br br-tun-{vf_list[i]}
+ovs-vsctl add-port br-tun-{vf_list[i]} {acc_pr_list[i]}
+
+"""
+        else:
+            vf = get_interface_info(server_name='host', interface_name=vf_list[i])
+            acc_pr = get_interface_info(server_name='acc', interface_name=acc_pr_list[i])
+            #print(vf)
+            #print(acc_pr)
+            vf_to_acc += f"""echo ""
+echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']})  PORT ({vf['port']}) maps to"
+echo "ACC  IDPF Interface {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']})  PORT ({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.tx_source_port_v4 "vmeta.common.vsi={vf['vsi_num']}/2047,priority=1,action=linux_networking_control.set_source_port({vf['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.source_port_to_pr_map "user_meta.cmeta.source_port={vf['port']},zero_padding=0,action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.tx_acc_vsi "vmeta.common.vsi={acc_pr['vsi_num']},zero_padding=0,action=linux_networking_control.l2_fwd_and_bypass_bridge({vf['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.vsi_to_vsi_loopback "vmeta.common.vsi={acc_pr['vsi_num']},target_vsi={vf['vsi_num']},action=linux_networking_control.fwd_to_vsi({vf['port']})"
+p4rt-ctl add-entry br0 linux_networking_control.vsi_to_vsi_loopback "vmeta.common.vsi={vf['vsi_num']},target_vsi={acc_pr['vsi_num']},action=linux_networking_control.fwd_to_vsi({acc_pr['port']})"
+sleep 2
+
+"""
+            ovs_vxlan += f"""echo ""
+echo "Host IDPF Interface {vf_list[i]} MAC ({vf['mac']})  VSI ({vf['vsi_id']}:{vf['vsi_num']}:{vf['port']}) maps to"
+echo "ACC Port {acc_pr_list[i]} MAC ({acc_pr['mac']})  VSI ({acc_pr['vsi_id']}:{acc_pr['vsi_num']}:{acc_pr['port']})"
+echo "ACC Port {acc_pr_list[i]} is added to OVS bridge br{vm_id}"
+ip link del TEP{vm_id}
+ovs-vsctl del-br br{vm_id}
+ip link add dev TEP{vm_id} type dummy
+ifconfig TEP{vm_id} {local_vtep[vm_id]}/24 up
+ovs-vsctl add-br br{vm_id}
+ovs-vsctl add-port br{vm_id} {acc_pr_list[i]}
+ovs-vsctl add-port br{vm_id} vxlan{vm_id} -- set interface vxlan{vm_id} type=vxlan options:local_ip={local_vtep[vm_id]} options:remote_ip={remote_vtep[vm_id]} options:key=1{vm_id} options:dst_port=4789
+
+"""
+            vf_to_vm += f'''
+echo ""
+echo "Setup VM{vm_id} using ip netns (Network Namespace) to simulate a Virtual Machine"
+echo "Add HOST VF {vf_list[i]} to the VM{vm_id} namespace"
+ip netns del VM{vm_id}
+ip netns add VM{vm_id}
+sleep 1
+ip link set {vf_list[i]} netns VM{vm_id}
+ip netns exec VM{vm_id} ip addr add {vm_ip_list[vm_id]}/24 dev {vf_list[i]}
+ip netns exec VM{vm_id} ifconfig {vf_list[i]} up
+sleep 2
+ip netns exec VM{vm_id} ip -br a
+
+'''
+            vm_id += 1
+
+        mac_list.append(str(acc_pr['mac']))
+
+
+    misc = """p4rt-ctl add-entry br0 linux_networking_control.ipv4_lpm_root_lut "user_meta.cmeta.bit16_zeros=4/65535,priority=2048,action=linux_networking_control.ipv4_lpm_root_lut_action(0)"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=0/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=1/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=2/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=3/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=4/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=5/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=6/7,priority=1,action=linux_networking_control.bypass"
+p4rt-ctl add-entry br0 linux_networking_control.tx_lag_table "user_meta.cmeta.lag_group_id=0/255,hash=7/7,priority=1,action=linux_networking_control.bypass"
+"""
+
+    acc_path = test_config['test_params']['acc_path']
+    acc_p4_path = f'{acc_path}/fxp-net_linux-networking-v3'
+    file = f'{path}/es2k_skip_p4.conf'
+    p4_config = 'cat <<EOF > ./'+file+'''
+{
+    "chip_list": [
+        {
+            "id": "asic-0",
+            "chip_family": "mev",
+            "instance": 0,
+            "pcie_bdf": "0000:00:01.6",
+            "iommu_grp_num": 7,
+            "ctrl_map" : ["NETDEV","''' + '","'.join(mac_list) + '''" ,1]
+        }
+    ],
+    "instance": 0,
+    "cfgqs-idx": "0-15",
+    "p4_devices": [
+        {
+            "device-id": 0,
+            "eal-args": "--lcores=1-2 -a 00:01.6,vport=[0-1] -- -i --rxq=1 --txq=1 --hairpinq=1 --hairpin-mode=0x0",
+            "p4_programs": [
+                {
+                    "program-name": "fxp-net_linux-networking-v3",
+                    "tdi-config": "'''+acc_p4_path+'''/tdi.json",
+                    "p4_pipelines": [
+                        {
+                            "p4_pipeline_name": "main",
+                            "context": "'''+acc_p4_path+'''/context.json",
+                            "config": "'''+acc_p4_path+'''/ipu.bin",
+                            "pipe_scope": [
+                                0,
+                                1,
+                                2,
+                                3
+                            ],
+                            "path": "'''+acc_p4_path+'''/"
+                        }
+                    ]
+                }
+            ],
+            "agent0": "lib/libpltfm_mgr.so"
+        }
+    ]
+}
+EOF
+'''
+    command_list.append(p4_config)
+
+    command_list.append(host_idpf)
+
+    file = f'{path}/2_acc_infrap4d.sh'
+    acc_infrap4d = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+#ACC Environment for Infrap4d:
+echo ""
+echo "Setup the environment in ACC to run Infrap4d"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export no_proxy=localhost,127.0.0.1,192.168.0.0/16
+export NO_PROXY=localhost,127.0.0.1,192.168.0.0/16
+unset http_proxy
+unset https_proxy
+
+bash \$P4CP_INSTALL/sbin/setup_env.sh \$P4CP_INSTALL \$SDE_INSTALL \$DEPEND_INSTALL
+sudo \$P4CP_INSTALL/sbin/copy_config_files.sh \$P4CP_INSTALL \$SDE_INSTALL
+
+export OUTPUT_DIR='''+acc_p4_path+'''
+
+echo ""
+echo "Load the vfio-pci driver to bind the vfio-pci 00:01.6"
+sudo modprobe vfio-pci
+sudo /opt/p4/p4sde/bin/dpdk-devbind.py -b vfio-pci 00:01.6
+
+echo ""
+echo "Copy Infrap4d Config file es2k_skip_p4.conf to /usr/share/stratum/es2k/es2k_skip_p4.conf"
+touch \$OUTPUT_DIR/ipu.bin
+cp -f \$OUTPUT_DIR/es2k_skip_p4.conf /usr/share/stratum/es2k/es2k_skip_p4.conf
+
+echo ""
+echo "Verify the infrap4d config"
+cat /usr/share/stratum/es2k/es2k_skip_p4.conf
+
+#TLS CERTS
+echo ""
+echo "Generate the TLS Certs for Infrap4d"
+cd /usr/share/stratum/
+COMMON_NAME=localhost ./generate-certs.sh
+sleep 2
+
+echo ""
+echo "Start Infrap4d"
+#Start Infrap4d
+/opt/p4/p4-cp-nws/sbin/infrap4d --nodetach
+EOF
+'''
+
+    command_list.append(acc_infrap4d)
+
+    file = f'{path}/3_acc_p4rt.sh'
+    acc_p4rt = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup P4 Runtime Pipeline"
+echo "P4 Artifacts are in Folder : OUTPUT_DIR='''+acc_p4_path+'''"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+
+tdi_pipeline_builder --p4c_conf_file=/usr/share/stratum/es2k/es2k_skip_p4.conf --tdi_pipeline_config_binary_file=\$OUTPUT_DIR/fxp-net_linux-networking-v3.pb.bin
+
+sleep 2
+echo ""
+echo "Use p4rt-ctl set-pipe to setup the runtime pipeline"
+p4rt-ctl set-pipe br0 \$OUTPUT_DIR/fxp-net_linux-networking-v3.pb.bin \$OUTPUT_DIR/p4Info.txt
+sleep 2
+echo ""
+echo "Get IDPF Interface MAC and VSI info from IMC command : cli_client -q -c"
+echo "VSI (hexadecimal:decimal) PORT (VSI+16)"
+echo "Use p4rt-ctl to configure the VFs -- ACC PR"
+'''+vf_to_acc+'''
+sleep 2
+echo ""
+echo "Use p4rt-ctl to configure the Physical Ports -- ACC PR"
+'''+phy_to_acc+'''
+sleep 2
+echo ""
+echo "Configure supporting p4 runtime tables for LPM and LAG bypass"
+'''+misc+'''
+EOF
+'''
+    command_list.append(acc_p4rt)
+
+    file = f'{path}/acc_p4rt_delete.sh'
+    acc_p4rt_delete = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Delete the P4 Runtime Rules"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+
+
+echo "Use p4rt-ctl to remove the rules for the VFs -- ACC PR"
+'''+vf_to_acc+'''
+sleep 2
+echo ""
+echo "Use p4rt-ctl to remove the rules for Physical Ports -- ACC PR"
+'''+phy_to_acc+'''
+sleep 2
+echo ""
+echo "Remove supporting p4 runtime tables for LPM and LAG bypass"
+'''+misc+'''
+EOF
+'''
+    command_list.append(acc_p4rt_delete)
+
+    delete_command = f'''
+sed -i 's/add-entry/del-entry/g' {file}
+sed -i 's/,action.*"/"/g' {file}
+'''
+    command_list.append(delete_command)
+
+    file = f'{path}/4_acc_p4rt_dump.sh'
+    acc_p4rt_dump = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup P4 Runtime Pipeline"
+echo "P4 Artifacts are in Folder : OUTPUT_DIR='''+acc_p4_path+'''"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+
+
+echo ""
+echo "p4rt-ctl dump-entries br0 linux_networking_control.rx_source_port "
+p4rt-ctl dump-entries br0 linux_networking_control.rx_source_port
+
+#Run the p4rt-ctl dump-entries to display the table entries
+echo ""
+echo "Dump linux_networking_control.tx_source_port_v4 entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.tx_source_port_v4"
+p4rt-ctl dump-entries br0 linux_networking_control.tx_source_port_v4
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.source_port_to_pr_map entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.source_port_to_pr_map"
+p4rt-ctl dump-entries br0 linux_networking_control.source_port_to_pr_map
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.tx_acc_vsi entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.tx_acc_vsi"
+p4rt-ctl dump-entries br0 linux_networking_control.tx_acc_vsi
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.vsi_to_vsi_loopback entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.vsi_to_vsi_loopback"
+p4rt-ctl dump-entries br0 linux_networking_control.vsi_to_vsi_loopback
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.rx_phy_port_to_pr_map entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.rx_phy_port_to_pr_map"
+p4rt-ctl dump-entries br0 linux_networking_control.rx_phy_port_to_pr_map
+sleep 1
+
+echo ""
+echo "Dump linux_networking_control.tx_lag_table entries:"
+echo "p4rt-ctl dump-entries br0 linux_networking_control.tx_lag_table"
+p4rt-ctl dump-entries br0 linux_networking_control.tx_lag_table
+EOF
+'''
+
+    command_list.append(acc_p4rt_dump)
+    file = f'{path}/5_acc_setup_ovs.sh'
+    acc_setup_ovs = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+killall ovsdb-server
+killall ovs-vswitchd
+
+echo ""
+echo "Setup the Environment to run OVS"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+rm -rf \$RUN_OVS/etc/openvswitch
+rm -rf \$RUN_OVS/var/run/openvswitch
+mkdir -p \$RUN_OVS/etc/openvswitch/
+mkdir -p \$RUN_OVS/var/run/openvswitch
+
+ovsdb-tool create \$RUN_OVS/etc/openvswitch/conf.db \$RUN_OVS/share/openvswitch/vswitch.ovsschema
+
+echo ""
+echo "Start the ovsdb-server"
+ovsdb-server --remote=punix:\$RUN_OVS/var/run/openvswitch/db.sock --remote=db:Open_vSwitch,Open_vSwitch,manager_options --pidfile --detach
+
+ovs-vsctl --no-wait init
+
+echo ""
+echo "Start the ovs-vswitchd"
+mkdir -p /tmp/logs
+ovs-vswitchd --pidfile --detach --mlockall --log-file=/tmp/logs/ovs-vswitchd.log
+
+ovs-vsctl set Open_vSwitch . other_config:n-revalidator-threads=1
+ovs-vsctl set Open_vSwitch . other_config:n-handler-threads=1
+echo ""
+echo "Verify OVS: ovsdb-server and ovs-vswitchd are running"
+ovs-vsctl  show
+
+ps -aux | grep ovs
+EOF
+'''
+    command_list.append(acc_setup_ovs)
+    file = f'{path}/6_acc_ovs_bridge.sh'
+    acc_ovs_bridge = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup the Environment to run OVS"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+echo ""
+echo "Setup an OVS Bridge br-int-1"
+
+ovs-vsctl del-br br-int-1
+ovs-vsctl del-br br-int-2
+ovs-vsctl del-br br-tun-0
+ovs-vsctl del-br br-tun-1
+
+ip link del TEP0
+ovs-vsctl del-br br0
+ip link del TEP1
+ovs-vsctl del-br br1
+ip link del TEP2
+ovs-vsctl del-br br2
+ip link del TEP3
+ovs-vsctl del-br br3
+ip link del TEP4
+ovs-vsctl del-br br4
+ip link del TEP5
+ovs-vsctl del-br br5
+ip link del TEP6
+ovs-vsctl del-br br6
+ip link del TEP7
+ovs-vsctl del-br br7
+ip link del TEP8
+ovs-vsctl del-br br8
+
+#ovs-vsctl add-br br-int-1
+#ovs-vsctl add-port br-int-1 enp0s1f0d1
+#ovs-vsctl add-port br-int-1 enp0s1f0d2
+#ovs-vsctl add-port br-int-1 enp0s1f0d3
+#ovs-vsctl add-port br-int-1 enp0s1f0d4
+#ovs-vsctl add-port br-int-1 enp0s1f0d5
+#ovs-vsctl add-port br-int-1 enp0s1f0d6
+#ovs-vsctl add-port br-int-1 enp0s1f0d7
+#ovs-vsctl add-port br-int-1 enp0s1f0d8
+#ovs-vsctl add-port br-int-1 enp0s1f0d9
+#ovs-vsctl add-port br-int-1 enp0s1f0d10
+#ovs-vsctl add-port br-int-1 enp0s1f0d11
+#ovs-vsctl add-port br-int-1 enp0s1f0d12
+#ifconfig br-int-1 up
+
+ovs-vsctl add-br br-int-1
+ovs-vsctl add-port br-int-1 enp0s1f0d4
+ovs-vsctl add-port br-int-1 enp0s1f0d6
+ovs-vsctl add-port br-int-1 enp0s1f0d7
+ovs-vsctl add-port br-int-1 enp0s1f0d8
+ovs-vsctl add-port br-int-1 enp0s1f0d9
+ifconfig br-int-1 up
+
+ovs-vsctl add-br br-int-2
+ovs-vsctl add-port br-int-2 enp0s1f0d5
+ovs-vsctl add-port br-int-2 enp0s1f0d10
+ovs-vsctl add-port br-int-2 enp0s1f0d11
+ovs-vsctl add-port br-int-2 enp0s1f0d12
+ovs-vsctl add-port br-int-2 enp0s1f0d13
+ifconfig br-int-2 up
+
+sleep 2
+ovs-vsctl show
+
+echo "Check the interface configuration"
+sleep 1
+ip -br a
+
+echo ""
+echo "Configure the Host VM and Link Partner to test connectivity"
+EOF
+'''
+    command_list.append(acc_ovs_bridge)
+
+
+    file = f'{path}/acc_ovs_vxlan.sh'
+    acc_ovs_vxlan = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+
+echo "Setup the Environment to run OVS"
+export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=\$P4CP_INSTALL
+export OUTPUT_DIR='''+acc_p4_path+'''
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+ovs-vsctl del-br br-int-1
+ovs-vsctl del-br br-int-2
+
+'''+ovs_vxlan+'''
+ifconfig br-tun-0 '''+local_br_tun[0]+'''/24 up
+ifconfig br-tun-1 '''+local_br_tun[1]+'''/24 up
+ip route change 10.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+ip route change 11.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+ip route change 12.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+ip route change 13.1.1.0/24 via '''+remote_br_tun[0]+''' dev br-tun-0
+ip route change 14.1.1.0/24 via '''+remote_br_tun[1]+''' dev br-tun-1
+ip route change 15.1.1.0/24 via '''+remote_br_tun[1]+''' dev br-tun-1
+ip route change 16.1.1.0/24 via '''+remote_br_tun[1]+''' dev br-tun-1
+ip route change 17.1.1.0/24 via '''+remote_br_tun[1]+''' dev br-tun-1
+
+sleep 2
+ovs-vsctl show
+
+echo "Check the interface configuration"
+sleep 1
+ip -br a
+
+EOF
+'''
+    command_list.append(acc_ovs_vxlan)
+
+    file = f'{path}/7_host_vm.sh'
+    host_vm = 'cat <<EOF > ./'+file+'''
+#!/bin/sh
+echo "Setup the Host VMs and VFs"
+
+'''+vf_to_vm+'''
+
+EOF
+'''
+    command_list.append(host_vm)
+    command_list.append(f"chmod +x {path}/*")
+
+    for command in command_list:
+        try:
+            result = ssh_command('host', command)
+        except Exception as e:
+            print(f"Failed with exception:\n{e}")
+
+    return None
+
+
+def build_args():
+    # Create the top-level parser
+    parser = argparse.ArgumentParser(description='Run Linux networking with OVS Offload')
+    subparsers = parser.add_subparsers(dest='command', help='options')
+    # Create the parser for the "create_script" command
+    parser_create_script = subparsers.add_parser('create_script', help='Generate configuration scripts in localhost')
+    # Create the parser for the "copy_script" command
+    parser_copy_script = subparsers.add_parser('copy_script', help='Copy configuration scripts to IMC and ACC')
+    # Create the parser for the "setup" command
+    parser_setup = subparsers.add_parser('setup', help='Setup the complete OVS offload Recipe, pre-requisite: run copy_script option once for scripts to be available in ACC')
+    # Create the parser for the "teardown" command
+    parser_teardown = subparsers.add_parser('teardown', help='Teardown the complete OVS offload Recipe, pre-requisite: run copy_script option once for scripts to be available in ACC')
+    return parser
+
+
+if __name__ == "__main__":
+    host_path = test_config['test_params']['host_path']
+    imc_path = test_config['test_params']['imc_path']
+    acc_path = test_config['test_params']['acc_path']
+    idpf_interface = test_config['test_params']['idpf_interface']
+    vf_interfaces = test_config['test_params']['vf_interfaces']
+    acc_pr_interfaces = test_config['test_params']['acc_pr_interfaces']
+    ip_list=test_config['test_params']['ip_list']
+    imc_ip = test_config['imc']['ssh']['ip']
+    acc_ip = test_config['acc']['ssh']['ip']
+    acc_p4_path = f'{acc_path}/fxp-net_linux-networking'
+    lp_interfaces = test_config['host']['lp_interfaces']
+    lp_interface_ip = test_config['host']['lp_interface_ip']
+    host_password = test_config['host']['ssh']['password']
+    imc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{imc_ip}'
+    acc_login = f'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@{acc_ip}'
+
+    parser = build_args()
+    # Parse the arguments
+    args = parser.parse_args()
+
+    # Execute the appropriate function based on the subcommand
+    if args.command == 'create_script':
+
+        print("\n----------------Create OVS OFFLOAD scripts----------------")
+        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list,host_idpf_intf=idpf_interface, path=host_path)
+
+    elif args.command == 'copy_script':
+        print("\n----------------Create OVS OFFLOAD scripts----------------")
+        build_p4rt_config(vf_list=vf_interfaces, acc_pr_list=acc_pr_interfaces, vm_ip_list=ip_list,host_idpf_intf=idpf_interface, path=host_path)
+        print("\n----------------Copy OVS OFFLOAD scripts to the ACC----------------")
+        copy_scripts(host_path = host_path, imc_path = imc_path , acc_path = acc_path)
+
+    elif args.command == 'setup':
+
+        if host_password == '':
+            print("Enter correct IPU Host SSH root password in config.yaml and retry")
+            sys.exit()
+
+        print("\n----------------Setup Linux Networking with OVS OFFLOAD----------------")
+
+        # Setup a TMUX session, Login to ACC and start infrap4d
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        infrap4d = tmux_term(tmux_name="test1_infrap4d",tmux_override=True)
+        result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
+        result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
+
+        print("\n----------------Copy Infrap4d Configuration file----------------")
+        result = infrap4d.tmux_send_keys(f'yes | cp -f {acc_path}/{host_path}/es2k_skip_p4.conf {acc_path}/fxp-net_linux-networking/', delay=2, output=True)
+        print(result)
+        result = infrap4d.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+        result = infrap4d.tmux_send_keys('ls -lrt', delay=2, output=True)
+
+        print("\n----------------Start Infrap4d, wait for initialization to complete----------------")
+        result = infrap4d.tmux_send_keys('./2_acc_infrap4d.sh', delay=180, output=True)
+        print(result)
+
+        # Setup a TMUX session, Login to ACC, configure p4rt rules and ovs bridges
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        p4rt = tmux_term(tmux_name="test2_p4rt",tmux_override=True)
+        result = p4rt.tmux_send_keys(imc_login, delay=2)
+        result = p4rt.tmux_send_keys(acc_login, delay=2)
+        result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+
+        print("\n----------------Use p4rt-ctl to Add the rules----------------")
+        result = p4rt.tmux_send_keys('./3_acc_p4rt.sh', delay=60, output=True)
+        print(result)
+        print("\n----------------Use p4rt-ctl to Dump the rules----------------")
+        result = p4rt.tmux_send_keys('./4_acc_p4rt_dump.sh', delay=20, output=True)
+        print(result)
+
+        print("\n----------------Setup OVS Environment on the ACC----------------")
+        result = p4rt.tmux_send_keys('./5_acc_setup_ovs.sh', delay=10, output=True)
+        print(result)
+        print("\n----------------Configure OVS Bridges----------------")
+        result = p4rt.tmux_send_keys('./6_acc_ovs_bridge.sh', delay=10, output=True)
+        print(result)
+
+        print("\n----------------Setup TMUX Session and Login to the Host----------------")
+        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
+        result = host.tmux_send_keys('sudo -s', delay=2, output=True)
+        result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
+
+        print("\n----------------Configure the VMs on the Host and ADD the IDPF SR-IOV VFs----------------")
+        result = host.tmux_send_keys('ls -lrt', delay=2, output=True)
+        print(f'{result}')
+        result = host.tmux_send_keys('./7_host_vm.sh', delay=30, output=True)
+        print(result)
+
+        print("\n----------------Configure the Link Partner Interfaces----------------")
+        for idx in range(len(lp_interfaces)):
+            result = host.tmux_send_keys(f'ip a a dev {lp_interfaces[idx]} {lp_interface_ip[idx]}/24', delay=3, output=True)
+        result = host.tmux_send_keys('ip -br a', delay=3, output=True)
+        print(result)
+
+        print("\n----------------PING TEST: LINK Partner to Host VM IDPF VF----------------")
+        print(f"\nLINK Partner Interface IP : {lp_interface_ip}")
+        print(f"\nHost VM IDPF VF Interface IP : {ip_list}\n")
+        for ip in ip_list:
+            ping_test(dst_ip=ip, count=4)
+
+    elif args.command == 'teardown':
+
+        if host_password == '':
+            print("Enter correct IPU Host root password in config.yaml and retry")
+            sys.exit()
+
+        print("\n----------------Teardown Linux Networking with OVS OFFLOAD----------------")
+
+        print("\n----------------Setup TMUX Session and Login to the Host----------------")
+        host = tmux_term(tmux_name="test3_host",tmux_override=True)
+        result = host.tmux_send_keys(f'cd {host_path}', delay=2, output=True)
+        result = host.tmux_send_keys('sudo -s', delay=2, output=True)
+        result = host.tmux_send_keys(f'{host_password}', delay=2, output=True)
+
+        print("\n----------------Delete the VMs on the Host----------------")
+        result = host.tmux_send_keys('ls -lrt', delay=2, output=True)
+        print(f'{result}')
+        command = '''ip netns del VM0
+ip netns del VM1
+ip netns del VM2
+ip netns del VM3
+ip netns del VM4
+ip netns del VM5
+ip netns del VM6
+ip netns del VM7
+'''
+        result = host.tmux_send_keys(command, delay=10, output=True)
+        print(result)
+        for idx in range(len(lp_interfaces)):
+            result = host.tmux_send_keys(f'ip a d dev {lp_interfaces[idx]} {lp_interface_ip[idx]}/24', delay=3, output=True)
+        result = host.tmux_send_keys('ip -br a', delay=3, output=True)
+        print(result)
+
+        print("\n----------------Setup TMUX Session, Login to ACC----------------")
+        p4rt = tmux_term(tmux_name="test2_p4rt",tmux_override=True)
+        result = p4rt.tmux_send_keys(imc_login, delay=2)
+        result = p4rt.tmux_send_keys(acc_login, delay=2)
+        result = p4rt.tmux_send_keys(f'cd {acc_path}/{host_path}', delay=2, output=True)
+
+        print("\n----------------Cleanup OVS Bridge Configuration----------------")
+        command = f'''export SDE_INSTALL=/opt/p4/p4sde
+export P4CP_INSTALL=/opt/p4/p4-cp-nws
+export DEPEND_INSTALL=$P4CP_INSTALL
+export PATH=/root/.local/bin:/root/bin:/usr/share/Modules/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/p4/p4-cp-nws/bin:/opt/p4/p4-cp-nws/sbin
+export RUN_OVS=/opt/p4/p4-cp-nws
+
+ovs-vsctl show
+ovs-vsctl del-br br-int-1
+ovs-vsctl del-br br-int-2
+ovs-vsctl del-br br-tun-0
+ovs-vsctl del-br br-tun-1
+
+ip link del TEP0
+ovs-vsctl del-br br0
+ip link del TEP1
+ovs-vsctl del-br br1
+ip link del TEP2
+ovs-vsctl del-br br2
+ip link del TEP3
+ovs-vsctl del-br br3
+ip link del TEP4
+ovs-vsctl del-br br4
+ip link del TEP5
+ovs-vsctl del-br br5
+ip link del TEP6
+ovs-vsctl del-br br6
+ip link del TEP7
+ovs-vsctl del-br br7
+ovs-vsctl show
+'''
+        result = p4rt.tmux_send_keys(command, delay=20, output=True)
+        print(result)
+
+        print("\n----------------Use p4rt-ctl to Delete the rules----------------")
+        result = p4rt.tmux_send_keys('./acc_p4rt_delete.sh', delay=60, output=True)
+        print(result)
+        print("\n----------------Use p4rt-ctl to Dump the rules after cleanup----------------")
+        result = p4rt.tmux_send_keys('./4_acc_p4rt_dump.sh', delay=30, output=True)
+        print(result)
+
+        print("\n----------------Stop Infrap4d on the ACC----------------")
+        infrap4d = tmux_term(tmux_name="test1_infrap4d",tmux_override=True)
+        result = infrap4d.tmux_send_keys(imc_login, delay=2, output=True)
+        result = infrap4d.tmux_send_keys(acc_login, delay=2, output=True)
+        result = infrap4d.tmux_send_keys('ps -aux | grep infrap4d', delay=2, output=True)
+        print(result)
+
+    else:
+        parser.print_help()
+
diff --git a/ovs_offload/requirements.txt b/ovs_offload/requirements.txt
new file mode 100644
index 0000000..5500f00
--- /dev/null
+++ b/ovs_offload/requirements.txt
@@ -0,0 +1 @@
+PyYAML

commit e625d6ca3c199f605e11cec32370a24ac82d3ea6
Author: Dan Daly <dandaly@pobox.com>
Date:   Wed Sep 4 13:25:55 2024 -0700

    Initial commit

diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..261eeb9
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..1a66500
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+# ipu-playbook
\ No newline at end of file
